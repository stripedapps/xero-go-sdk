/*
Xero Accounting API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.40.0
Contact: api@xero.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
	"time"
)


// AccountingAPIService AccountingAPI service
type AccountingAPIService service

type ApiCreateAccountRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	account *Account
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateAccountRequest) XeroTenantId(xeroTenantId string) ApiCreateAccountRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Account object in body of request
func (r ApiCreateAccountRequest) Account(account Account) ApiCreateAccountRequest {
	r.account = &account
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateAccountRequest) IdempotencyKey(idempotencyKey string) ApiCreateAccountRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateAccountRequest) Execute() (*Accounts, *http.Response, error) {
	return r.ApiService.CreateAccountExecute(r)
}

/*
CreateAccount Creates a new chart of accounts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccountRequest
*/
func (a *AccountingAPIService) CreateAccount(ctx context.Context) ApiCreateAccountRequest {
	return ApiCreateAccountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Accounts
func (a *AccountingAPIService) CreateAccountExecute(r ApiCreateAccountRequest) (*Accounts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Accounts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.account == nil {
		return localVarReturnValue, nil, reportError("account is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.account
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAccountAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	accountID string
	fileName string
	body *string
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateAccountAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiCreateAccountAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Byte array of file in body of request
func (r ApiCreateAccountAttachmentByFileNameRequest) Body(body string) ApiCreateAccountAttachmentByFileNameRequest {
	r.body = &body
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateAccountAttachmentByFileNameRequest) IdempotencyKey(idempotencyKey string) ApiCreateAccountAttachmentByFileNameRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateAccountAttachmentByFileNameRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.CreateAccountAttachmentByFileNameExecute(r)
}

/*
CreateAccountAttachmentByFileName Creates an attachment on a specific account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID Unique identifier for Account object
 @param fileName Name of the attachment
 @return ApiCreateAccountAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) CreateAccountAttachmentByFileName(ctx context.Context, accountID string, fileName string) ApiCreateAccountAttachmentByFileNameRequest {
	return ApiCreateAccountAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) CreateAccountAttachmentByFileNameExecute(r ApiCreateAccountAttachmentByFileNameRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateAccountAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Accounts/{AccountID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountID"+"}", url.PathEscape(parameterValueToString(r.accountID, "accountID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBankTransactionAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	bankTransactionID string
	fileName string
	body *string
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateBankTransactionAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiCreateBankTransactionAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Byte array of file in body of request
func (r ApiCreateBankTransactionAttachmentByFileNameRequest) Body(body string) ApiCreateBankTransactionAttachmentByFileNameRequest {
	r.body = &body
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateBankTransactionAttachmentByFileNameRequest) IdempotencyKey(idempotencyKey string) ApiCreateBankTransactionAttachmentByFileNameRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateBankTransactionAttachmentByFileNameRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.CreateBankTransactionAttachmentByFileNameExecute(r)
}

/*
CreateBankTransactionAttachmentByFileName Creates an attachment for a specific bank transaction by filename

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bankTransactionID Xero generated unique identifier for a bank transaction
 @param fileName Name of the attachment
 @return ApiCreateBankTransactionAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) CreateBankTransactionAttachmentByFileName(ctx context.Context, bankTransactionID string, fileName string) ApiCreateBankTransactionAttachmentByFileNameRequest {
	return ApiCreateBankTransactionAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		bankTransactionID: bankTransactionID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) CreateBankTransactionAttachmentByFileNameExecute(r ApiCreateBankTransactionAttachmentByFileNameRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateBankTransactionAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BankTransactions/{BankTransactionID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"BankTransactionID"+"}", url.PathEscape(parameterValueToString(r.bankTransactionID, "bankTransactionID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBankTransactionHistoryRecordRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	bankTransactionID string
	historyRecords *HistoryRecords
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateBankTransactionHistoryRecordRequest) XeroTenantId(xeroTenantId string) ApiCreateBankTransactionHistoryRecordRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// HistoryRecords containing an array of HistoryRecord objects in body of request
func (r ApiCreateBankTransactionHistoryRecordRequest) HistoryRecords(historyRecords HistoryRecords) ApiCreateBankTransactionHistoryRecordRequest {
	r.historyRecords = &historyRecords
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateBankTransactionHistoryRecordRequest) IdempotencyKey(idempotencyKey string) ApiCreateBankTransactionHistoryRecordRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateBankTransactionHistoryRecordRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.CreateBankTransactionHistoryRecordExecute(r)
}

/*
CreateBankTransactionHistoryRecord Creates a history record for a specific bank transactions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bankTransactionID Xero generated unique identifier for a bank transaction
 @return ApiCreateBankTransactionHistoryRecordRequest
*/
func (a *AccountingAPIService) CreateBankTransactionHistoryRecord(ctx context.Context, bankTransactionID string) ApiCreateBankTransactionHistoryRecordRequest {
	return ApiCreateBankTransactionHistoryRecordRequest{
		ApiService: a,
		ctx: ctx,
		bankTransactionID: bankTransactionID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) CreateBankTransactionHistoryRecordExecute(r ApiCreateBankTransactionHistoryRecordRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateBankTransactionHistoryRecord")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BankTransactions/{BankTransactionID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"BankTransactionID"+"}", url.PathEscape(parameterValueToString(r.bankTransactionID, "bankTransactionID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.historyRecords == nil {
		return localVarReturnValue, nil, reportError("historyRecords is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.historyRecords
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBankTransactionsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	bankTransactions *BankTransactions
	idempotencyKey *string
	summarizeErrors *bool
	unitdp *int32
}

// Xero identifier for Tenant
func (r ApiCreateBankTransactionsRequest) XeroTenantId(xeroTenantId string) ApiCreateBankTransactionsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// BankTransactions with an array of BankTransaction objects in body of request
func (r ApiCreateBankTransactionsRequest) BankTransactions(bankTransactions BankTransactions) ApiCreateBankTransactionsRequest {
	r.bankTransactions = &bankTransactions
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateBankTransactionsRequest) IdempotencyKey(idempotencyKey string) ApiCreateBankTransactionsRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// If false return 200 OK and mix of successfully created objects and any with validation errors
func (r ApiCreateBankTransactionsRequest) SummarizeErrors(summarizeErrors bool) ApiCreateBankTransactionsRequest {
	r.summarizeErrors = &summarizeErrors
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiCreateBankTransactionsRequest) Unitdp(unitdp int32) ApiCreateBankTransactionsRequest {
	r.unitdp = &unitdp
	return r
}

func (r ApiCreateBankTransactionsRequest) Execute() (*BankTransactions, *http.Response, error) {
	return r.ApiService.CreateBankTransactionsExecute(r)
}

/*
CreateBankTransactions Creates one or more spent or received money transaction

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBankTransactionsRequest
*/
func (a *AccountingAPIService) CreateBankTransactions(ctx context.Context) ApiCreateBankTransactionsRequest {
	return ApiCreateBankTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BankTransactions
func (a *AccountingAPIService) CreateBankTransactionsExecute(r ApiCreateBankTransactionsRequest) (*BankTransactions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BankTransactions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateBankTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BankTransactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.bankTransactions == nil {
		return localVarReturnValue, nil, reportError("bankTransactions is required and must be specified")
	}

	if r.summarizeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarizeErrors", r.summarizeErrors, "")
	}
	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.bankTransactions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBankTransferRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	bankTransfers *BankTransfers
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateBankTransferRequest) XeroTenantId(xeroTenantId string) ApiCreateBankTransferRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// BankTransfers with array of BankTransfer objects in request body
func (r ApiCreateBankTransferRequest) BankTransfers(bankTransfers BankTransfers) ApiCreateBankTransferRequest {
	r.bankTransfers = &bankTransfers
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateBankTransferRequest) IdempotencyKey(idempotencyKey string) ApiCreateBankTransferRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateBankTransferRequest) Execute() (*BankTransfers, *http.Response, error) {
	return r.ApiService.CreateBankTransferExecute(r)
}

/*
CreateBankTransfer Creates a bank transfer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBankTransferRequest
*/
func (a *AccountingAPIService) CreateBankTransfer(ctx context.Context) ApiCreateBankTransferRequest {
	return ApiCreateBankTransferRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BankTransfers
func (a *AccountingAPIService) CreateBankTransferExecute(r ApiCreateBankTransferRequest) (*BankTransfers, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BankTransfers
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateBankTransfer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BankTransfers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.bankTransfers == nil {
		return localVarReturnValue, nil, reportError("bankTransfers is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.bankTransfers
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBankTransferAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	bankTransferID string
	fileName string
	body *string
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateBankTransferAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiCreateBankTransferAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Byte array of file in body of request
func (r ApiCreateBankTransferAttachmentByFileNameRequest) Body(body string) ApiCreateBankTransferAttachmentByFileNameRequest {
	r.body = &body
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateBankTransferAttachmentByFileNameRequest) IdempotencyKey(idempotencyKey string) ApiCreateBankTransferAttachmentByFileNameRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateBankTransferAttachmentByFileNameRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.CreateBankTransferAttachmentByFileNameExecute(r)
}

/*
CreateBankTransferAttachmentByFileName Method for CreateBankTransferAttachmentByFileName

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bankTransferID Xero generated unique identifier for a bank transfer
 @param fileName Name of the attachment
 @return ApiCreateBankTransferAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) CreateBankTransferAttachmentByFileName(ctx context.Context, bankTransferID string, fileName string) ApiCreateBankTransferAttachmentByFileNameRequest {
	return ApiCreateBankTransferAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		bankTransferID: bankTransferID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) CreateBankTransferAttachmentByFileNameExecute(r ApiCreateBankTransferAttachmentByFileNameRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateBankTransferAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BankTransfers/{BankTransferID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"BankTransferID"+"}", url.PathEscape(parameterValueToString(r.bankTransferID, "bankTransferID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBankTransferHistoryRecordRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	bankTransferID string
	historyRecords *HistoryRecords
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateBankTransferHistoryRecordRequest) XeroTenantId(xeroTenantId string) ApiCreateBankTransferHistoryRecordRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// HistoryRecords containing an array of HistoryRecord objects in body of request
func (r ApiCreateBankTransferHistoryRecordRequest) HistoryRecords(historyRecords HistoryRecords) ApiCreateBankTransferHistoryRecordRequest {
	r.historyRecords = &historyRecords
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateBankTransferHistoryRecordRequest) IdempotencyKey(idempotencyKey string) ApiCreateBankTransferHistoryRecordRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateBankTransferHistoryRecordRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.CreateBankTransferHistoryRecordExecute(r)
}

/*
CreateBankTransferHistoryRecord Creates a history record for a specific bank transfer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bankTransferID Xero generated unique identifier for a bank transfer
 @return ApiCreateBankTransferHistoryRecordRequest
*/
func (a *AccountingAPIService) CreateBankTransferHistoryRecord(ctx context.Context, bankTransferID string) ApiCreateBankTransferHistoryRecordRequest {
	return ApiCreateBankTransferHistoryRecordRequest{
		ApiService: a,
		ctx: ctx,
		bankTransferID: bankTransferID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) CreateBankTransferHistoryRecordExecute(r ApiCreateBankTransferHistoryRecordRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateBankTransferHistoryRecord")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BankTransfers/{BankTransferID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"BankTransferID"+"}", url.PathEscape(parameterValueToString(r.bankTransferID, "bankTransferID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.historyRecords == nil {
		return localVarReturnValue, nil, reportError("historyRecords is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.historyRecords
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBatchPaymentRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	batchPayments *BatchPayments
	summarizeErrors *bool
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateBatchPaymentRequest) XeroTenantId(xeroTenantId string) ApiCreateBatchPaymentRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// BatchPayments with an array of Payments in body of request
func (r ApiCreateBatchPaymentRequest) BatchPayments(batchPayments BatchPayments) ApiCreateBatchPaymentRequest {
	r.batchPayments = &batchPayments
	return r
}

// If false return 200 OK and mix of successfully created objects and any with validation errors
func (r ApiCreateBatchPaymentRequest) SummarizeErrors(summarizeErrors bool) ApiCreateBatchPaymentRequest {
	r.summarizeErrors = &summarizeErrors
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateBatchPaymentRequest) IdempotencyKey(idempotencyKey string) ApiCreateBatchPaymentRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateBatchPaymentRequest) Execute() (*BatchPayments, *http.Response, error) {
	return r.ApiService.CreateBatchPaymentExecute(r)
}

/*
CreateBatchPayment Creates one or many batch payments for invoices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBatchPaymentRequest
*/
func (a *AccountingAPIService) CreateBatchPayment(ctx context.Context) ApiCreateBatchPaymentRequest {
	return ApiCreateBatchPaymentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchPayments
func (a *AccountingAPIService) CreateBatchPaymentExecute(r ApiCreateBatchPaymentRequest) (*BatchPayments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchPayments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateBatchPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BatchPayments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.batchPayments == nil {
		return localVarReturnValue, nil, reportError("batchPayments is required and must be specified")
	}

	if r.summarizeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarizeErrors", r.summarizeErrors, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.batchPayments
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBatchPaymentHistoryRecordRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	batchPaymentID string
	historyRecords *HistoryRecords
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateBatchPaymentHistoryRecordRequest) XeroTenantId(xeroTenantId string) ApiCreateBatchPaymentHistoryRecordRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// HistoryRecords containing an array of HistoryRecord objects in body of request
func (r ApiCreateBatchPaymentHistoryRecordRequest) HistoryRecords(historyRecords HistoryRecords) ApiCreateBatchPaymentHistoryRecordRequest {
	r.historyRecords = &historyRecords
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateBatchPaymentHistoryRecordRequest) IdempotencyKey(idempotencyKey string) ApiCreateBatchPaymentHistoryRecordRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateBatchPaymentHistoryRecordRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.CreateBatchPaymentHistoryRecordExecute(r)
}

/*
CreateBatchPaymentHistoryRecord Creates a history record for a specific batch payment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchPaymentID Unique identifier for BatchPayment
 @return ApiCreateBatchPaymentHistoryRecordRequest
*/
func (a *AccountingAPIService) CreateBatchPaymentHistoryRecord(ctx context.Context, batchPaymentID string) ApiCreateBatchPaymentHistoryRecordRequest {
	return ApiCreateBatchPaymentHistoryRecordRequest{
		ApiService: a,
		ctx: ctx,
		batchPaymentID: batchPaymentID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) CreateBatchPaymentHistoryRecordExecute(r ApiCreateBatchPaymentHistoryRecordRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateBatchPaymentHistoryRecord")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BatchPayments/{BatchPaymentID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"BatchPaymentID"+"}", url.PathEscape(parameterValueToString(r.batchPaymentID, "batchPaymentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.historyRecords == nil {
		return localVarReturnValue, nil, reportError("historyRecords is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.historyRecords
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBrandingThemePaymentServicesRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	brandingThemeID string
	paymentServices *PaymentServices
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateBrandingThemePaymentServicesRequest) XeroTenantId(xeroTenantId string) ApiCreateBrandingThemePaymentServicesRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// PaymentServices array with PaymentService object in body of request
func (r ApiCreateBrandingThemePaymentServicesRequest) PaymentServices(paymentServices PaymentServices) ApiCreateBrandingThemePaymentServicesRequest {
	r.paymentServices = &paymentServices
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateBrandingThemePaymentServicesRequest) IdempotencyKey(idempotencyKey string) ApiCreateBrandingThemePaymentServicesRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateBrandingThemePaymentServicesRequest) Execute() (*PaymentServices, *http.Response, error) {
	return r.ApiService.CreateBrandingThemePaymentServicesExecute(r)
}

/*
CreateBrandingThemePaymentServices Creates a new custom payment service for a specific branding theme

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param brandingThemeID Unique identifier for a Branding Theme
 @return ApiCreateBrandingThemePaymentServicesRequest
*/
func (a *AccountingAPIService) CreateBrandingThemePaymentServices(ctx context.Context, brandingThemeID string) ApiCreateBrandingThemePaymentServicesRequest {
	return ApiCreateBrandingThemePaymentServicesRequest{
		ApiService: a,
		ctx: ctx,
		brandingThemeID: brandingThemeID,
	}
}

// Execute executes the request
//  @return PaymentServices
func (a *AccountingAPIService) CreateBrandingThemePaymentServicesExecute(r ApiCreateBrandingThemePaymentServicesRequest) (*PaymentServices, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentServices
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateBrandingThemePaymentServices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BrandingThemes/{BrandingThemeID}/PaymentServices"
	localVarPath = strings.Replace(localVarPath, "{"+"BrandingThemeID"+"}", url.PathEscape(parameterValueToString(r.brandingThemeID, "brandingThemeID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.paymentServices == nil {
		return localVarReturnValue, nil, reportError("paymentServices is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.paymentServices
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateContactAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	contactID string
	fileName string
	body *string
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateContactAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiCreateContactAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Byte array of file in body of request
func (r ApiCreateContactAttachmentByFileNameRequest) Body(body string) ApiCreateContactAttachmentByFileNameRequest {
	r.body = &body
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateContactAttachmentByFileNameRequest) IdempotencyKey(idempotencyKey string) ApiCreateContactAttachmentByFileNameRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateContactAttachmentByFileNameRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.CreateContactAttachmentByFileNameExecute(r)
}

/*
CreateContactAttachmentByFileName Method for CreateContactAttachmentByFileName

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactID Unique identifier for a Contact
 @param fileName Name of the attachment
 @return ApiCreateContactAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) CreateContactAttachmentByFileName(ctx context.Context, contactID string, fileName string) ApiCreateContactAttachmentByFileNameRequest {
	return ApiCreateContactAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		contactID: contactID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) CreateContactAttachmentByFileNameExecute(r ApiCreateContactAttachmentByFileNameRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateContactAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Contacts/{ContactID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"ContactID"+"}", url.PathEscape(parameterValueToString(r.contactID, "contactID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateContactGroupRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	contactGroups *ContactGroups
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateContactGroupRequest) XeroTenantId(xeroTenantId string) ApiCreateContactGroupRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// ContactGroups with an array of names in request body
func (r ApiCreateContactGroupRequest) ContactGroups(contactGroups ContactGroups) ApiCreateContactGroupRequest {
	r.contactGroups = &contactGroups
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateContactGroupRequest) IdempotencyKey(idempotencyKey string) ApiCreateContactGroupRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateContactGroupRequest) Execute() (*ContactGroups, *http.Response, error) {
	return r.ApiService.CreateContactGroupExecute(r)
}

/*
CreateContactGroup Creates a contact group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateContactGroupRequest
*/
func (a *AccountingAPIService) CreateContactGroup(ctx context.Context) ApiCreateContactGroupRequest {
	return ApiCreateContactGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ContactGroups
func (a *AccountingAPIService) CreateContactGroupExecute(r ApiCreateContactGroupRequest) (*ContactGroups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContactGroups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateContactGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ContactGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contactGroups == nil {
		return localVarReturnValue, nil, reportError("contactGroups is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.contactGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateContactGroupContactsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	contactGroupID string
	contacts *Contacts
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateContactGroupContactsRequest) XeroTenantId(xeroTenantId string) ApiCreateContactGroupContactsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Contacts with array of contacts specifying the ContactID to be added to ContactGroup in body of request
func (r ApiCreateContactGroupContactsRequest) Contacts(contacts Contacts) ApiCreateContactGroupContactsRequest {
	r.contacts = &contacts
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateContactGroupContactsRequest) IdempotencyKey(idempotencyKey string) ApiCreateContactGroupContactsRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateContactGroupContactsRequest) Execute() (*Contacts, *http.Response, error) {
	return r.ApiService.CreateContactGroupContactsExecute(r)
}

/*
CreateContactGroupContacts Creates contacts to a specific contact group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactGroupID Unique identifier for a Contact Group
 @return ApiCreateContactGroupContactsRequest
*/
func (a *AccountingAPIService) CreateContactGroupContacts(ctx context.Context, contactGroupID string) ApiCreateContactGroupContactsRequest {
	return ApiCreateContactGroupContactsRequest{
		ApiService: a,
		ctx: ctx,
		contactGroupID: contactGroupID,
	}
}

// Execute executes the request
//  @return Contacts
func (a *AccountingAPIService) CreateContactGroupContactsExecute(r ApiCreateContactGroupContactsRequest) (*Contacts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Contacts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateContactGroupContacts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ContactGroups/{ContactGroupID}/Contacts"
	localVarPath = strings.Replace(localVarPath, "{"+"ContactGroupID"+"}", url.PathEscape(parameterValueToString(r.contactGroupID, "contactGroupID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contacts == nil {
		return localVarReturnValue, nil, reportError("contacts is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.contacts
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateContactHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	contactID string
	historyRecords *HistoryRecords
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateContactHistoryRequest) XeroTenantId(xeroTenantId string) ApiCreateContactHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// HistoryRecords containing an array of HistoryRecord objects in body of request
func (r ApiCreateContactHistoryRequest) HistoryRecords(historyRecords HistoryRecords) ApiCreateContactHistoryRequest {
	r.historyRecords = &historyRecords
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateContactHistoryRequest) IdempotencyKey(idempotencyKey string) ApiCreateContactHistoryRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateContactHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.CreateContactHistoryExecute(r)
}

/*
CreateContactHistory Creates a new history record for a specific contact

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactID Unique identifier for a Contact
 @return ApiCreateContactHistoryRequest
*/
func (a *AccountingAPIService) CreateContactHistory(ctx context.Context, contactID string) ApiCreateContactHistoryRequest {
	return ApiCreateContactHistoryRequest{
		ApiService: a,
		ctx: ctx,
		contactID: contactID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) CreateContactHistoryExecute(r ApiCreateContactHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateContactHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Contacts/{ContactID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"ContactID"+"}", url.PathEscape(parameterValueToString(r.contactID, "contactID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.historyRecords == nil {
		return localVarReturnValue, nil, reportError("historyRecords is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.historyRecords
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateContactsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	contacts *Contacts
	idempotencyKey *string
	summarizeErrors *bool
}

// Xero identifier for Tenant
func (r ApiCreateContactsRequest) XeroTenantId(xeroTenantId string) ApiCreateContactsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Contacts with an array of Contact objects to create in body of request
func (r ApiCreateContactsRequest) Contacts(contacts Contacts) ApiCreateContactsRequest {
	r.contacts = &contacts
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateContactsRequest) IdempotencyKey(idempotencyKey string) ApiCreateContactsRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// If false return 200 OK and mix of successfully created objects and any with validation errors
func (r ApiCreateContactsRequest) SummarizeErrors(summarizeErrors bool) ApiCreateContactsRequest {
	r.summarizeErrors = &summarizeErrors
	return r
}

func (r ApiCreateContactsRequest) Execute() (*Contacts, *http.Response, error) {
	return r.ApiService.CreateContactsExecute(r)
}

/*
CreateContacts Creates multiple contacts (bulk) in a Xero organisation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateContactsRequest
*/
func (a *AccountingAPIService) CreateContacts(ctx context.Context) ApiCreateContactsRequest {
	return ApiCreateContactsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Contacts
func (a *AccountingAPIService) CreateContactsExecute(r ApiCreateContactsRequest) (*Contacts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Contacts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateContacts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Contacts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contacts == nil {
		return localVarReturnValue, nil, reportError("contacts is required and must be specified")
	}

	if r.summarizeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarizeErrors", r.summarizeErrors, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.contacts
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCreditNoteAllocationRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	creditNoteID string
	allocations *Allocations
	idempotencyKey *string
	summarizeErrors *bool
}

// Xero identifier for Tenant
func (r ApiCreateCreditNoteAllocationRequest) XeroTenantId(xeroTenantId string) ApiCreateCreditNoteAllocationRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Allocations with array of Allocation object in body of request.
func (r ApiCreateCreditNoteAllocationRequest) Allocations(allocations Allocations) ApiCreateCreditNoteAllocationRequest {
	r.allocations = &allocations
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateCreditNoteAllocationRequest) IdempotencyKey(idempotencyKey string) ApiCreateCreditNoteAllocationRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// If false return 200 OK and mix of successfully created objects and any with validation errors
func (r ApiCreateCreditNoteAllocationRequest) SummarizeErrors(summarizeErrors bool) ApiCreateCreditNoteAllocationRequest {
	r.summarizeErrors = &summarizeErrors
	return r
}

func (r ApiCreateCreditNoteAllocationRequest) Execute() (*Allocations, *http.Response, error) {
	return r.ApiService.CreateCreditNoteAllocationExecute(r)
}

/*
CreateCreditNoteAllocation Creates allocation for a specific credit note

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param creditNoteID Unique identifier for a Credit Note
 @return ApiCreateCreditNoteAllocationRequest
*/
func (a *AccountingAPIService) CreateCreditNoteAllocation(ctx context.Context, creditNoteID string) ApiCreateCreditNoteAllocationRequest {
	return ApiCreateCreditNoteAllocationRequest{
		ApiService: a,
		ctx: ctx,
		creditNoteID: creditNoteID,
	}
}

// Execute executes the request
//  @return Allocations
func (a *AccountingAPIService) CreateCreditNoteAllocationExecute(r ApiCreateCreditNoteAllocationRequest) (*Allocations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Allocations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateCreditNoteAllocation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CreditNotes/{CreditNoteID}/Allocations"
	localVarPath = strings.Replace(localVarPath, "{"+"CreditNoteID"+"}", url.PathEscape(parameterValueToString(r.creditNoteID, "creditNoteID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.allocations == nil {
		return localVarReturnValue, nil, reportError("allocations is required and must be specified")
	}

	if r.summarizeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarizeErrors", r.summarizeErrors, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.allocations
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCreditNoteAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	creditNoteID string
	fileName string
	body *string
	idempotencyKey *string
	includeOnline *bool
}

// Xero identifier for Tenant
func (r ApiCreateCreditNoteAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiCreateCreditNoteAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Byte array of file in body of request
func (r ApiCreateCreditNoteAttachmentByFileNameRequest) Body(body string) ApiCreateCreditNoteAttachmentByFileNameRequest {
	r.body = &body
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateCreditNoteAttachmentByFileNameRequest) IdempotencyKey(idempotencyKey string) ApiCreateCreditNoteAttachmentByFileNameRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// Allows an attachment to be seen by the end customer within their online invoice
func (r ApiCreateCreditNoteAttachmentByFileNameRequest) IncludeOnline(includeOnline bool) ApiCreateCreditNoteAttachmentByFileNameRequest {
	r.includeOnline = &includeOnline
	return r
}

func (r ApiCreateCreditNoteAttachmentByFileNameRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.CreateCreditNoteAttachmentByFileNameExecute(r)
}

/*
CreateCreditNoteAttachmentByFileName Creates an attachment for a specific credit note

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param creditNoteID Unique identifier for a Credit Note
 @param fileName Name of the attachment
 @return ApiCreateCreditNoteAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) CreateCreditNoteAttachmentByFileName(ctx context.Context, creditNoteID string, fileName string) ApiCreateCreditNoteAttachmentByFileNameRequest {
	return ApiCreateCreditNoteAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		creditNoteID: creditNoteID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) CreateCreditNoteAttachmentByFileNameExecute(r ApiCreateCreditNoteAttachmentByFileNameRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateCreditNoteAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CreditNotes/{CreditNoteID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"CreditNoteID"+"}", url.PathEscape(parameterValueToString(r.creditNoteID, "creditNoteID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.includeOnline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeOnline", r.includeOnline, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCreditNoteHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	creditNoteID string
	historyRecords *HistoryRecords
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateCreditNoteHistoryRequest) XeroTenantId(xeroTenantId string) ApiCreateCreditNoteHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// HistoryRecords containing an array of HistoryRecord objects in body of request
func (r ApiCreateCreditNoteHistoryRequest) HistoryRecords(historyRecords HistoryRecords) ApiCreateCreditNoteHistoryRequest {
	r.historyRecords = &historyRecords
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateCreditNoteHistoryRequest) IdempotencyKey(idempotencyKey string) ApiCreateCreditNoteHistoryRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateCreditNoteHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.CreateCreditNoteHistoryExecute(r)
}

/*
CreateCreditNoteHistory Retrieves history records of a specific credit note

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param creditNoteID Unique identifier for a Credit Note
 @return ApiCreateCreditNoteHistoryRequest
*/
func (a *AccountingAPIService) CreateCreditNoteHistory(ctx context.Context, creditNoteID string) ApiCreateCreditNoteHistoryRequest {
	return ApiCreateCreditNoteHistoryRequest{
		ApiService: a,
		ctx: ctx,
		creditNoteID: creditNoteID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) CreateCreditNoteHistoryExecute(r ApiCreateCreditNoteHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateCreditNoteHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CreditNotes/{CreditNoteID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"CreditNoteID"+"}", url.PathEscape(parameterValueToString(r.creditNoteID, "creditNoteID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.historyRecords == nil {
		return localVarReturnValue, nil, reportError("historyRecords is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.historyRecords
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCreditNotesRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	creditNotes *CreditNotes
	idempotencyKey *string
	summarizeErrors *bool
	unitdp *int32
}

// Xero identifier for Tenant
func (r ApiCreateCreditNotesRequest) XeroTenantId(xeroTenantId string) ApiCreateCreditNotesRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Credit Notes with array of CreditNote object in body of request
func (r ApiCreateCreditNotesRequest) CreditNotes(creditNotes CreditNotes) ApiCreateCreditNotesRequest {
	r.creditNotes = &creditNotes
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateCreditNotesRequest) IdempotencyKey(idempotencyKey string) ApiCreateCreditNotesRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// If false return 200 OK and mix of successfully created objects and any with validation errors
func (r ApiCreateCreditNotesRequest) SummarizeErrors(summarizeErrors bool) ApiCreateCreditNotesRequest {
	r.summarizeErrors = &summarizeErrors
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiCreateCreditNotesRequest) Unitdp(unitdp int32) ApiCreateCreditNotesRequest {
	r.unitdp = &unitdp
	return r
}

func (r ApiCreateCreditNotesRequest) Execute() (*CreditNotes, *http.Response, error) {
	return r.ApiService.CreateCreditNotesExecute(r)
}

/*
CreateCreditNotes Creates a new credit note

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCreditNotesRequest
*/
func (a *AccountingAPIService) CreateCreditNotes(ctx context.Context) ApiCreateCreditNotesRequest {
	return ApiCreateCreditNotesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreditNotes
func (a *AccountingAPIService) CreateCreditNotesExecute(r ApiCreateCreditNotesRequest) (*CreditNotes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreditNotes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateCreditNotes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CreditNotes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.creditNotes == nil {
		return localVarReturnValue, nil, reportError("creditNotes is required and must be specified")
	}

	if r.summarizeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarizeErrors", r.summarizeErrors, "")
	}
	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.creditNotes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCurrencyRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	currency *Currency
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateCurrencyRequest) XeroTenantId(xeroTenantId string) ApiCreateCurrencyRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Currency object in the body of request
func (r ApiCreateCurrencyRequest) Currency(currency Currency) ApiCreateCurrencyRequest {
	r.currency = &currency
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateCurrencyRequest) IdempotencyKey(idempotencyKey string) ApiCreateCurrencyRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateCurrencyRequest) Execute() (*Currencies, *http.Response, error) {
	return r.ApiService.CreateCurrencyExecute(r)
}

/*
CreateCurrency Create a new currency for a Xero organisation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCurrencyRequest
*/
func (a *AccountingAPIService) CreateCurrency(ctx context.Context) ApiCreateCurrencyRequest {
	return ApiCreateCurrencyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Currencies
func (a *AccountingAPIService) CreateCurrencyExecute(r ApiCreateCurrencyRequest) (*Currencies, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Currencies
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateCurrency")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Currencies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.currency == nil {
		return localVarReturnValue, nil, reportError("currency is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.currency
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateEmployeesRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	employees *Employees
	idempotencyKey *string
	summarizeErrors *bool
}

// Xero identifier for Tenant
func (r ApiCreateEmployeesRequest) XeroTenantId(xeroTenantId string) ApiCreateEmployeesRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Employees with array of Employee object in body of request
func (r ApiCreateEmployeesRequest) Employees(employees Employees) ApiCreateEmployeesRequest {
	r.employees = &employees
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateEmployeesRequest) IdempotencyKey(idempotencyKey string) ApiCreateEmployeesRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// If false return 200 OK and mix of successfully created objects and any with validation errors
func (r ApiCreateEmployeesRequest) SummarizeErrors(summarizeErrors bool) ApiCreateEmployeesRequest {
	r.summarizeErrors = &summarizeErrors
	return r
}

func (r ApiCreateEmployeesRequest) Execute() (*Employees, *http.Response, error) {
	return r.ApiService.CreateEmployeesExecute(r)
}

/*
CreateEmployees Creates new employees used in Xero payrun

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateEmployeesRequest
*/
func (a *AccountingAPIService) CreateEmployees(ctx context.Context) ApiCreateEmployeesRequest {
	return ApiCreateEmployeesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Employees
func (a *AccountingAPIService) CreateEmployeesExecute(r ApiCreateEmployeesRequest) (*Employees, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Employees
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateEmployees")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Employees"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.employees == nil {
		return localVarReturnValue, nil, reportError("employees is required and must be specified")
	}

	if r.summarizeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarizeErrors", r.summarizeErrors, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.employees
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateExpenseClaimHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	expenseClaimID string
	historyRecords *HistoryRecords
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateExpenseClaimHistoryRequest) XeroTenantId(xeroTenantId string) ApiCreateExpenseClaimHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// HistoryRecords containing an array of HistoryRecord objects in body of request
func (r ApiCreateExpenseClaimHistoryRequest) HistoryRecords(historyRecords HistoryRecords) ApiCreateExpenseClaimHistoryRequest {
	r.historyRecords = &historyRecords
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateExpenseClaimHistoryRequest) IdempotencyKey(idempotencyKey string) ApiCreateExpenseClaimHistoryRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateExpenseClaimHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.CreateExpenseClaimHistoryExecute(r)
}

/*
CreateExpenseClaimHistory Creates a history record for a specific expense claim

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param expenseClaimID Unique identifier for a ExpenseClaim
 @return ApiCreateExpenseClaimHistoryRequest
*/
func (a *AccountingAPIService) CreateExpenseClaimHistory(ctx context.Context, expenseClaimID string) ApiCreateExpenseClaimHistoryRequest {
	return ApiCreateExpenseClaimHistoryRequest{
		ApiService: a,
		ctx: ctx,
		expenseClaimID: expenseClaimID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) CreateExpenseClaimHistoryExecute(r ApiCreateExpenseClaimHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateExpenseClaimHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ExpenseClaims/{ExpenseClaimID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"ExpenseClaimID"+"}", url.PathEscape(parameterValueToString(r.expenseClaimID, "expenseClaimID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.historyRecords == nil {
		return localVarReturnValue, nil, reportError("historyRecords is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.historyRecords
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateExpenseClaimsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	expenseClaims *ExpenseClaims
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateExpenseClaimsRequest) XeroTenantId(xeroTenantId string) ApiCreateExpenseClaimsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// ExpenseClaims with array of ExpenseClaim object in body of request
func (r ApiCreateExpenseClaimsRequest) ExpenseClaims(expenseClaims ExpenseClaims) ApiCreateExpenseClaimsRequest {
	r.expenseClaims = &expenseClaims
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateExpenseClaimsRequest) IdempotencyKey(idempotencyKey string) ApiCreateExpenseClaimsRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateExpenseClaimsRequest) Execute() (*ExpenseClaims, *http.Response, error) {
	return r.ApiService.CreateExpenseClaimsExecute(r)
}

/*
CreateExpenseClaims Creates expense claims

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateExpenseClaimsRequest
*/
func (a *AccountingAPIService) CreateExpenseClaims(ctx context.Context) ApiCreateExpenseClaimsRequest {
	return ApiCreateExpenseClaimsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExpenseClaims
func (a *AccountingAPIService) CreateExpenseClaimsExecute(r ApiCreateExpenseClaimsRequest) (*ExpenseClaims, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExpenseClaims
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateExpenseClaims")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ExpenseClaims"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.expenseClaims == nil {
		return localVarReturnValue, nil, reportError("expenseClaims is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.expenseClaims
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateInvoiceAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	invoiceID string
	fileName string
	body *string
	idempotencyKey *string
	includeOnline *bool
}

// Xero identifier for Tenant
func (r ApiCreateInvoiceAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiCreateInvoiceAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Byte array of file in body of request
func (r ApiCreateInvoiceAttachmentByFileNameRequest) Body(body string) ApiCreateInvoiceAttachmentByFileNameRequest {
	r.body = &body
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateInvoiceAttachmentByFileNameRequest) IdempotencyKey(idempotencyKey string) ApiCreateInvoiceAttachmentByFileNameRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// Allows an attachment to be seen by the end customer within their online invoice
func (r ApiCreateInvoiceAttachmentByFileNameRequest) IncludeOnline(includeOnline bool) ApiCreateInvoiceAttachmentByFileNameRequest {
	r.includeOnline = &includeOnline
	return r
}

func (r ApiCreateInvoiceAttachmentByFileNameRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.CreateInvoiceAttachmentByFileNameExecute(r)
}

/*
CreateInvoiceAttachmentByFileName Creates an attachment for a specific invoice or purchase bill by filename

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceID Unique identifier for an Invoice
 @param fileName Name of the attachment
 @return ApiCreateInvoiceAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) CreateInvoiceAttachmentByFileName(ctx context.Context, invoiceID string, fileName string) ApiCreateInvoiceAttachmentByFileNameRequest {
	return ApiCreateInvoiceAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		invoiceID: invoiceID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) CreateInvoiceAttachmentByFileNameExecute(r ApiCreateInvoiceAttachmentByFileNameRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateInvoiceAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Invoices/{InvoiceID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"InvoiceID"+"}", url.PathEscape(parameterValueToString(r.invoiceID, "invoiceID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.includeOnline != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IncludeOnline", r.includeOnline, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateInvoiceHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	invoiceID string
	historyRecords *HistoryRecords
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateInvoiceHistoryRequest) XeroTenantId(xeroTenantId string) ApiCreateInvoiceHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// HistoryRecords containing an array of HistoryRecord objects in body of request
func (r ApiCreateInvoiceHistoryRequest) HistoryRecords(historyRecords HistoryRecords) ApiCreateInvoiceHistoryRequest {
	r.historyRecords = &historyRecords
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateInvoiceHistoryRequest) IdempotencyKey(idempotencyKey string) ApiCreateInvoiceHistoryRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateInvoiceHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.CreateInvoiceHistoryExecute(r)
}

/*
CreateInvoiceHistory Creates a history record for a specific invoice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceID Unique identifier for an Invoice
 @return ApiCreateInvoiceHistoryRequest
*/
func (a *AccountingAPIService) CreateInvoiceHistory(ctx context.Context, invoiceID string) ApiCreateInvoiceHistoryRequest {
	return ApiCreateInvoiceHistoryRequest{
		ApiService: a,
		ctx: ctx,
		invoiceID: invoiceID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) CreateInvoiceHistoryExecute(r ApiCreateInvoiceHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateInvoiceHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Invoices/{InvoiceID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"InvoiceID"+"}", url.PathEscape(parameterValueToString(r.invoiceID, "invoiceID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.historyRecords == nil {
		return localVarReturnValue, nil, reportError("historyRecords is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.historyRecords
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateInvoicesRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	invoices *Invoices
	idempotencyKey *string
	summarizeErrors *bool
	unitdp *int32
}

// Xero identifier for Tenant
func (r ApiCreateInvoicesRequest) XeroTenantId(xeroTenantId string) ApiCreateInvoicesRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Invoices with an array of invoice objects in body of request
func (r ApiCreateInvoicesRequest) Invoices(invoices Invoices) ApiCreateInvoicesRequest {
	r.invoices = &invoices
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateInvoicesRequest) IdempotencyKey(idempotencyKey string) ApiCreateInvoicesRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// If false return 200 OK and mix of successfully created objects and any with validation errors
func (r ApiCreateInvoicesRequest) SummarizeErrors(summarizeErrors bool) ApiCreateInvoicesRequest {
	r.summarizeErrors = &summarizeErrors
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiCreateInvoicesRequest) Unitdp(unitdp int32) ApiCreateInvoicesRequest {
	r.unitdp = &unitdp
	return r
}

func (r ApiCreateInvoicesRequest) Execute() (*Invoices, *http.Response, error) {
	return r.ApiService.CreateInvoicesExecute(r)
}

/*
CreateInvoices Creates one or more sales invoices or purchase bills

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateInvoicesRequest
*/
func (a *AccountingAPIService) CreateInvoices(ctx context.Context) ApiCreateInvoicesRequest {
	return ApiCreateInvoicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Invoices
func (a *AccountingAPIService) CreateInvoicesExecute(r ApiCreateInvoicesRequest) (*Invoices, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Invoices
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateInvoices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Invoices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.invoices == nil {
		return localVarReturnValue, nil, reportError("invoices is required and must be specified")
	}

	if r.summarizeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarizeErrors", r.summarizeErrors, "")
	}
	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.invoices
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateItemHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	itemID string
	historyRecords *HistoryRecords
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateItemHistoryRequest) XeroTenantId(xeroTenantId string) ApiCreateItemHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// HistoryRecords containing an array of HistoryRecord objects in body of request
func (r ApiCreateItemHistoryRequest) HistoryRecords(historyRecords HistoryRecords) ApiCreateItemHistoryRequest {
	r.historyRecords = &historyRecords
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateItemHistoryRequest) IdempotencyKey(idempotencyKey string) ApiCreateItemHistoryRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateItemHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.CreateItemHistoryExecute(r)
}

/*
CreateItemHistory Creates a history record for a specific item

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemID Unique identifier for an Item
 @return ApiCreateItemHistoryRequest
*/
func (a *AccountingAPIService) CreateItemHistory(ctx context.Context, itemID string) ApiCreateItemHistoryRequest {
	return ApiCreateItemHistoryRequest{
		ApiService: a,
		ctx: ctx,
		itemID: itemID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) CreateItemHistoryExecute(r ApiCreateItemHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateItemHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{ItemID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"ItemID"+"}", url.PathEscape(parameterValueToString(r.itemID, "itemID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.historyRecords == nil {
		return localVarReturnValue, nil, reportError("historyRecords is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.historyRecords
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateItemsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	items *Items
	idempotencyKey *string
	summarizeErrors *bool
	unitdp *int32
}

// Xero identifier for Tenant
func (r ApiCreateItemsRequest) XeroTenantId(xeroTenantId string) ApiCreateItemsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Items with an array of Item objects in body of request
func (r ApiCreateItemsRequest) Items(items Items) ApiCreateItemsRequest {
	r.items = &items
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateItemsRequest) IdempotencyKey(idempotencyKey string) ApiCreateItemsRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// If false return 200 OK and mix of successfully created objects and any with validation errors
func (r ApiCreateItemsRequest) SummarizeErrors(summarizeErrors bool) ApiCreateItemsRequest {
	r.summarizeErrors = &summarizeErrors
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiCreateItemsRequest) Unitdp(unitdp int32) ApiCreateItemsRequest {
	r.unitdp = &unitdp
	return r
}

func (r ApiCreateItemsRequest) Execute() (*Items, *http.Response, error) {
	return r.ApiService.CreateItemsExecute(r)
}

/*
CreateItems Creates one or more items

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateItemsRequest
*/
func (a *AccountingAPIService) CreateItems(ctx context.Context) ApiCreateItemsRequest {
	return ApiCreateItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Items
func (a *AccountingAPIService) CreateItemsExecute(r ApiCreateItemsRequest) (*Items, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Items
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.items == nil {
		return localVarReturnValue, nil, reportError("items is required and must be specified")
	}

	if r.summarizeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarizeErrors", r.summarizeErrors, "")
	}
	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.items
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateLinkedTransactionRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	linkedTransaction *LinkedTransaction
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateLinkedTransactionRequest) XeroTenantId(xeroTenantId string) ApiCreateLinkedTransactionRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// LinkedTransaction object in body of request
func (r ApiCreateLinkedTransactionRequest) LinkedTransaction(linkedTransaction LinkedTransaction) ApiCreateLinkedTransactionRequest {
	r.linkedTransaction = &linkedTransaction
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateLinkedTransactionRequest) IdempotencyKey(idempotencyKey string) ApiCreateLinkedTransactionRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateLinkedTransactionRequest) Execute() (*LinkedTransactions, *http.Response, error) {
	return r.ApiService.CreateLinkedTransactionExecute(r)
}

/*
CreateLinkedTransaction Creates linked transactions (billable expenses)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateLinkedTransactionRequest
*/
func (a *AccountingAPIService) CreateLinkedTransaction(ctx context.Context) ApiCreateLinkedTransactionRequest {
	return ApiCreateLinkedTransactionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LinkedTransactions
func (a *AccountingAPIService) CreateLinkedTransactionExecute(r ApiCreateLinkedTransactionRequest) (*LinkedTransactions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LinkedTransactions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateLinkedTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LinkedTransactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.linkedTransaction == nil {
		return localVarReturnValue, nil, reportError("linkedTransaction is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.linkedTransaction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateManualJournalAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	manualJournalID string
	fileName string
	body *string
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateManualJournalAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiCreateManualJournalAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Byte array of file in body of request
func (r ApiCreateManualJournalAttachmentByFileNameRequest) Body(body string) ApiCreateManualJournalAttachmentByFileNameRequest {
	r.body = &body
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateManualJournalAttachmentByFileNameRequest) IdempotencyKey(idempotencyKey string) ApiCreateManualJournalAttachmentByFileNameRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateManualJournalAttachmentByFileNameRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.CreateManualJournalAttachmentByFileNameExecute(r)
}

/*
CreateManualJournalAttachmentByFileName Creates a specific attachment for a specific manual journal by file name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param manualJournalID Unique identifier for a ManualJournal
 @param fileName Name of the attachment
 @return ApiCreateManualJournalAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) CreateManualJournalAttachmentByFileName(ctx context.Context, manualJournalID string, fileName string) ApiCreateManualJournalAttachmentByFileNameRequest {
	return ApiCreateManualJournalAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		manualJournalID: manualJournalID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) CreateManualJournalAttachmentByFileNameExecute(r ApiCreateManualJournalAttachmentByFileNameRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateManualJournalAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ManualJournals/{ManualJournalID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"ManualJournalID"+"}", url.PathEscape(parameterValueToString(r.manualJournalID, "manualJournalID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateManualJournalHistoryRecordRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	manualJournalID string
	historyRecords *HistoryRecords
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateManualJournalHistoryRecordRequest) XeroTenantId(xeroTenantId string) ApiCreateManualJournalHistoryRecordRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// HistoryRecords containing an array of HistoryRecord objects in body of request
func (r ApiCreateManualJournalHistoryRecordRequest) HistoryRecords(historyRecords HistoryRecords) ApiCreateManualJournalHistoryRecordRequest {
	r.historyRecords = &historyRecords
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateManualJournalHistoryRecordRequest) IdempotencyKey(idempotencyKey string) ApiCreateManualJournalHistoryRecordRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateManualJournalHistoryRecordRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.CreateManualJournalHistoryRecordExecute(r)
}

/*
CreateManualJournalHistoryRecord Creates a history record for a specific manual journal

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param manualJournalID Unique identifier for a ManualJournal
 @return ApiCreateManualJournalHistoryRecordRequest
*/
func (a *AccountingAPIService) CreateManualJournalHistoryRecord(ctx context.Context, manualJournalID string) ApiCreateManualJournalHistoryRecordRequest {
	return ApiCreateManualJournalHistoryRecordRequest{
		ApiService: a,
		ctx: ctx,
		manualJournalID: manualJournalID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) CreateManualJournalHistoryRecordExecute(r ApiCreateManualJournalHistoryRecordRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateManualJournalHistoryRecord")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ManualJournals/{ManualJournalID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"ManualJournalID"+"}", url.PathEscape(parameterValueToString(r.manualJournalID, "manualJournalID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.historyRecords == nil {
		return localVarReturnValue, nil, reportError("historyRecords is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.historyRecords
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateManualJournalsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	manualJournals *ManualJournals
	idempotencyKey *string
	summarizeErrors *bool
}

// Xero identifier for Tenant
func (r ApiCreateManualJournalsRequest) XeroTenantId(xeroTenantId string) ApiCreateManualJournalsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// ManualJournals array with ManualJournal object in body of request
func (r ApiCreateManualJournalsRequest) ManualJournals(manualJournals ManualJournals) ApiCreateManualJournalsRequest {
	r.manualJournals = &manualJournals
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateManualJournalsRequest) IdempotencyKey(idempotencyKey string) ApiCreateManualJournalsRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// If false return 200 OK and mix of successfully created objects and any with validation errors
func (r ApiCreateManualJournalsRequest) SummarizeErrors(summarizeErrors bool) ApiCreateManualJournalsRequest {
	r.summarizeErrors = &summarizeErrors
	return r
}

func (r ApiCreateManualJournalsRequest) Execute() (*ManualJournals, *http.Response, error) {
	return r.ApiService.CreateManualJournalsExecute(r)
}

/*
CreateManualJournals Creates one or more manual journals

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateManualJournalsRequest
*/
func (a *AccountingAPIService) CreateManualJournals(ctx context.Context) ApiCreateManualJournalsRequest {
	return ApiCreateManualJournalsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ManualJournals
func (a *AccountingAPIService) CreateManualJournalsExecute(r ApiCreateManualJournalsRequest) (*ManualJournals, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManualJournals
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateManualJournals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ManualJournals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.manualJournals == nil {
		return localVarReturnValue, nil, reportError("manualJournals is required and must be specified")
	}

	if r.summarizeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarizeErrors", r.summarizeErrors, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.manualJournals
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOverpaymentAllocationsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	overpaymentID string
	allocations *Allocations
	idempotencyKey *string
	summarizeErrors *bool
}

// Xero identifier for Tenant
func (r ApiCreateOverpaymentAllocationsRequest) XeroTenantId(xeroTenantId string) ApiCreateOverpaymentAllocationsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Allocations array with Allocation object in body of request
func (r ApiCreateOverpaymentAllocationsRequest) Allocations(allocations Allocations) ApiCreateOverpaymentAllocationsRequest {
	r.allocations = &allocations
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateOverpaymentAllocationsRequest) IdempotencyKey(idempotencyKey string) ApiCreateOverpaymentAllocationsRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// If false return 200 OK and mix of successfully created objects and any with validation errors
func (r ApiCreateOverpaymentAllocationsRequest) SummarizeErrors(summarizeErrors bool) ApiCreateOverpaymentAllocationsRequest {
	r.summarizeErrors = &summarizeErrors
	return r
}

func (r ApiCreateOverpaymentAllocationsRequest) Execute() (*Allocations, *http.Response, error) {
	return r.ApiService.CreateOverpaymentAllocationsExecute(r)
}

/*
CreateOverpaymentAllocations Creates a single allocation for a specific overpayment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param overpaymentID Unique identifier for a Overpayment
 @return ApiCreateOverpaymentAllocationsRequest
*/
func (a *AccountingAPIService) CreateOverpaymentAllocations(ctx context.Context, overpaymentID string) ApiCreateOverpaymentAllocationsRequest {
	return ApiCreateOverpaymentAllocationsRequest{
		ApiService: a,
		ctx: ctx,
		overpaymentID: overpaymentID,
	}
}

// Execute executes the request
//  @return Allocations
func (a *AccountingAPIService) CreateOverpaymentAllocationsExecute(r ApiCreateOverpaymentAllocationsRequest) (*Allocations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Allocations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateOverpaymentAllocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Overpayments/{OverpaymentID}/Allocations"
	localVarPath = strings.Replace(localVarPath, "{"+"OverpaymentID"+"}", url.PathEscape(parameterValueToString(r.overpaymentID, "overpaymentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.allocations == nil {
		return localVarReturnValue, nil, reportError("allocations is required and must be specified")
	}

	if r.summarizeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarizeErrors", r.summarizeErrors, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.allocations
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOverpaymentHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	overpaymentID string
	historyRecords *HistoryRecords
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateOverpaymentHistoryRequest) XeroTenantId(xeroTenantId string) ApiCreateOverpaymentHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// HistoryRecords containing an array of HistoryRecord objects in body of request
func (r ApiCreateOverpaymentHistoryRequest) HistoryRecords(historyRecords HistoryRecords) ApiCreateOverpaymentHistoryRequest {
	r.historyRecords = &historyRecords
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateOverpaymentHistoryRequest) IdempotencyKey(idempotencyKey string) ApiCreateOverpaymentHistoryRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateOverpaymentHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.CreateOverpaymentHistoryExecute(r)
}

/*
CreateOverpaymentHistory Creates a history record for a specific overpayment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param overpaymentID Unique identifier for a Overpayment
 @return ApiCreateOverpaymentHistoryRequest
*/
func (a *AccountingAPIService) CreateOverpaymentHistory(ctx context.Context, overpaymentID string) ApiCreateOverpaymentHistoryRequest {
	return ApiCreateOverpaymentHistoryRequest{
		ApiService: a,
		ctx: ctx,
		overpaymentID: overpaymentID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) CreateOverpaymentHistoryExecute(r ApiCreateOverpaymentHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateOverpaymentHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Overpayments/{OverpaymentID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"OverpaymentID"+"}", url.PathEscape(parameterValueToString(r.overpaymentID, "overpaymentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.historyRecords == nil {
		return localVarReturnValue, nil, reportError("historyRecords is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.historyRecords
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePaymentRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	payment *Payment
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreatePaymentRequest) XeroTenantId(xeroTenantId string) ApiCreatePaymentRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Request body with a single Payment object
func (r ApiCreatePaymentRequest) Payment(payment Payment) ApiCreatePaymentRequest {
	r.payment = &payment
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreatePaymentRequest) IdempotencyKey(idempotencyKey string) ApiCreatePaymentRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreatePaymentRequest) Execute() (*Payments, *http.Response, error) {
	return r.ApiService.CreatePaymentExecute(r)
}

/*
CreatePayment Creates a single payment for invoice or credit notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatePaymentRequest
*/
func (a *AccountingAPIService) CreatePayment(ctx context.Context) ApiCreatePaymentRequest {
	return ApiCreatePaymentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Payments
func (a *AccountingAPIService) CreatePaymentExecute(r ApiCreatePaymentRequest) (*Payments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Payments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreatePayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Payments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.payment == nil {
		return localVarReturnValue, nil, reportError("payment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.payment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePaymentHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	paymentID string
	historyRecords *HistoryRecords
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreatePaymentHistoryRequest) XeroTenantId(xeroTenantId string) ApiCreatePaymentHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// HistoryRecords containing an array of HistoryRecord objects in body of request
func (r ApiCreatePaymentHistoryRequest) HistoryRecords(historyRecords HistoryRecords) ApiCreatePaymentHistoryRequest {
	r.historyRecords = &historyRecords
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreatePaymentHistoryRequest) IdempotencyKey(idempotencyKey string) ApiCreatePaymentHistoryRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreatePaymentHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.CreatePaymentHistoryExecute(r)
}

/*
CreatePaymentHistory Creates a history record for a specific payment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param paymentID Unique identifier for a Payment
 @return ApiCreatePaymentHistoryRequest
*/
func (a *AccountingAPIService) CreatePaymentHistory(ctx context.Context, paymentID string) ApiCreatePaymentHistoryRequest {
	return ApiCreatePaymentHistoryRequest{
		ApiService: a,
		ctx: ctx,
		paymentID: paymentID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) CreatePaymentHistoryExecute(r ApiCreatePaymentHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreatePaymentHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Payments/{PaymentID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"PaymentID"+"}", url.PathEscape(parameterValueToString(r.paymentID, "paymentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.historyRecords == nil {
		return localVarReturnValue, nil, reportError("historyRecords is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.historyRecords
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePaymentServiceRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	paymentServices *PaymentServices
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreatePaymentServiceRequest) XeroTenantId(xeroTenantId string) ApiCreatePaymentServiceRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// PaymentServices array with PaymentService object in body of request
func (r ApiCreatePaymentServiceRequest) PaymentServices(paymentServices PaymentServices) ApiCreatePaymentServiceRequest {
	r.paymentServices = &paymentServices
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreatePaymentServiceRequest) IdempotencyKey(idempotencyKey string) ApiCreatePaymentServiceRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreatePaymentServiceRequest) Execute() (*PaymentServices, *http.Response, error) {
	return r.ApiService.CreatePaymentServiceExecute(r)
}

/*
CreatePaymentService Creates a payment service

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatePaymentServiceRequest
*/
func (a *AccountingAPIService) CreatePaymentService(ctx context.Context) ApiCreatePaymentServiceRequest {
	return ApiCreatePaymentServiceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentServices
func (a *AccountingAPIService) CreatePaymentServiceExecute(r ApiCreatePaymentServiceRequest) (*PaymentServices, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentServices
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreatePaymentService")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PaymentServices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.paymentServices == nil {
		return localVarReturnValue, nil, reportError("paymentServices is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.paymentServices
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePaymentsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	payments *Payments
	idempotencyKey *string
	summarizeErrors *bool
}

// Xero identifier for Tenant
func (r ApiCreatePaymentsRequest) XeroTenantId(xeroTenantId string) ApiCreatePaymentsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Payments array with Payment object in body of request
func (r ApiCreatePaymentsRequest) Payments(payments Payments) ApiCreatePaymentsRequest {
	r.payments = &payments
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreatePaymentsRequest) IdempotencyKey(idempotencyKey string) ApiCreatePaymentsRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// If false return 200 OK and mix of successfully created objects and any with validation errors
func (r ApiCreatePaymentsRequest) SummarizeErrors(summarizeErrors bool) ApiCreatePaymentsRequest {
	r.summarizeErrors = &summarizeErrors
	return r
}

func (r ApiCreatePaymentsRequest) Execute() (*Payments, *http.Response, error) {
	return r.ApiService.CreatePaymentsExecute(r)
}

/*
CreatePayments Creates multiple payments for invoices or credit notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatePaymentsRequest
*/
func (a *AccountingAPIService) CreatePayments(ctx context.Context) ApiCreatePaymentsRequest {
	return ApiCreatePaymentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Payments
func (a *AccountingAPIService) CreatePaymentsExecute(r ApiCreatePaymentsRequest) (*Payments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Payments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreatePayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Payments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.payments == nil {
		return localVarReturnValue, nil, reportError("payments is required and must be specified")
	}

	if r.summarizeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarizeErrors", r.summarizeErrors, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.payments
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePrepaymentAllocationsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	prepaymentID string
	allocations *Allocations
	idempotencyKey *string
	summarizeErrors *bool
}

// Xero identifier for Tenant
func (r ApiCreatePrepaymentAllocationsRequest) XeroTenantId(xeroTenantId string) ApiCreatePrepaymentAllocationsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Allocations with an array of Allocation object in body of request
func (r ApiCreatePrepaymentAllocationsRequest) Allocations(allocations Allocations) ApiCreatePrepaymentAllocationsRequest {
	r.allocations = &allocations
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreatePrepaymentAllocationsRequest) IdempotencyKey(idempotencyKey string) ApiCreatePrepaymentAllocationsRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// If false return 200 OK and mix of successfully created objects and any with validation errors
func (r ApiCreatePrepaymentAllocationsRequest) SummarizeErrors(summarizeErrors bool) ApiCreatePrepaymentAllocationsRequest {
	r.summarizeErrors = &summarizeErrors
	return r
}

func (r ApiCreatePrepaymentAllocationsRequest) Execute() (*Allocations, *http.Response, error) {
	return r.ApiService.CreatePrepaymentAllocationsExecute(r)
}

/*
CreatePrepaymentAllocations Allows you to create an Allocation for prepayments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param prepaymentID Unique identifier for a PrePayment
 @return ApiCreatePrepaymentAllocationsRequest
*/
func (a *AccountingAPIService) CreatePrepaymentAllocations(ctx context.Context, prepaymentID string) ApiCreatePrepaymentAllocationsRequest {
	return ApiCreatePrepaymentAllocationsRequest{
		ApiService: a,
		ctx: ctx,
		prepaymentID: prepaymentID,
	}
}

// Execute executes the request
//  @return Allocations
func (a *AccountingAPIService) CreatePrepaymentAllocationsExecute(r ApiCreatePrepaymentAllocationsRequest) (*Allocations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Allocations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreatePrepaymentAllocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Prepayments/{PrepaymentID}/Allocations"
	localVarPath = strings.Replace(localVarPath, "{"+"PrepaymentID"+"}", url.PathEscape(parameterValueToString(r.prepaymentID, "prepaymentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.allocations == nil {
		return localVarReturnValue, nil, reportError("allocations is required and must be specified")
	}

	if r.summarizeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarizeErrors", r.summarizeErrors, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.allocations
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePrepaymentHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	prepaymentID string
	historyRecords *HistoryRecords
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreatePrepaymentHistoryRequest) XeroTenantId(xeroTenantId string) ApiCreatePrepaymentHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// HistoryRecords containing an array of HistoryRecord objects in body of request
func (r ApiCreatePrepaymentHistoryRequest) HistoryRecords(historyRecords HistoryRecords) ApiCreatePrepaymentHistoryRequest {
	r.historyRecords = &historyRecords
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreatePrepaymentHistoryRequest) IdempotencyKey(idempotencyKey string) ApiCreatePrepaymentHistoryRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreatePrepaymentHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.CreatePrepaymentHistoryExecute(r)
}

/*
CreatePrepaymentHistory Creates a history record for a specific prepayment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param prepaymentID Unique identifier for a PrePayment
 @return ApiCreatePrepaymentHistoryRequest
*/
func (a *AccountingAPIService) CreatePrepaymentHistory(ctx context.Context, prepaymentID string) ApiCreatePrepaymentHistoryRequest {
	return ApiCreatePrepaymentHistoryRequest{
		ApiService: a,
		ctx: ctx,
		prepaymentID: prepaymentID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) CreatePrepaymentHistoryExecute(r ApiCreatePrepaymentHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreatePrepaymentHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Prepayments/{PrepaymentID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"PrepaymentID"+"}", url.PathEscape(parameterValueToString(r.prepaymentID, "prepaymentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.historyRecords == nil {
		return localVarReturnValue, nil, reportError("historyRecords is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.historyRecords
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePurchaseOrderAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	purchaseOrderID string
	fileName string
	body *string
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreatePurchaseOrderAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiCreatePurchaseOrderAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Byte array of file in body of request
func (r ApiCreatePurchaseOrderAttachmentByFileNameRequest) Body(body string) ApiCreatePurchaseOrderAttachmentByFileNameRequest {
	r.body = &body
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreatePurchaseOrderAttachmentByFileNameRequest) IdempotencyKey(idempotencyKey string) ApiCreatePurchaseOrderAttachmentByFileNameRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreatePurchaseOrderAttachmentByFileNameRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.CreatePurchaseOrderAttachmentByFileNameExecute(r)
}

/*
CreatePurchaseOrderAttachmentByFileName Creates attachment for a specific purchase order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param purchaseOrderID Unique identifier for an Purchase Order
 @param fileName Name of the attachment
 @return ApiCreatePurchaseOrderAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) CreatePurchaseOrderAttachmentByFileName(ctx context.Context, purchaseOrderID string, fileName string) ApiCreatePurchaseOrderAttachmentByFileNameRequest {
	return ApiCreatePurchaseOrderAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		purchaseOrderID: purchaseOrderID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) CreatePurchaseOrderAttachmentByFileNameExecute(r ApiCreatePurchaseOrderAttachmentByFileNameRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreatePurchaseOrderAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PurchaseOrders/{PurchaseOrderID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"PurchaseOrderID"+"}", url.PathEscape(parameterValueToString(r.purchaseOrderID, "purchaseOrderID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePurchaseOrderHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	purchaseOrderID string
	historyRecords *HistoryRecords
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreatePurchaseOrderHistoryRequest) XeroTenantId(xeroTenantId string) ApiCreatePurchaseOrderHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// HistoryRecords containing an array of HistoryRecord objects in body of request
func (r ApiCreatePurchaseOrderHistoryRequest) HistoryRecords(historyRecords HistoryRecords) ApiCreatePurchaseOrderHistoryRequest {
	r.historyRecords = &historyRecords
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreatePurchaseOrderHistoryRequest) IdempotencyKey(idempotencyKey string) ApiCreatePurchaseOrderHistoryRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreatePurchaseOrderHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.CreatePurchaseOrderHistoryExecute(r)
}

/*
CreatePurchaseOrderHistory Creates a history record for a specific purchase orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param purchaseOrderID Unique identifier for an Purchase Order
 @return ApiCreatePurchaseOrderHistoryRequest
*/
func (a *AccountingAPIService) CreatePurchaseOrderHistory(ctx context.Context, purchaseOrderID string) ApiCreatePurchaseOrderHistoryRequest {
	return ApiCreatePurchaseOrderHistoryRequest{
		ApiService: a,
		ctx: ctx,
		purchaseOrderID: purchaseOrderID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) CreatePurchaseOrderHistoryExecute(r ApiCreatePurchaseOrderHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreatePurchaseOrderHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PurchaseOrders/{PurchaseOrderID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"PurchaseOrderID"+"}", url.PathEscape(parameterValueToString(r.purchaseOrderID, "purchaseOrderID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.historyRecords == nil {
		return localVarReturnValue, nil, reportError("historyRecords is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.historyRecords
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePurchaseOrdersRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	purchaseOrders *PurchaseOrders
	idempotencyKey *string
	summarizeErrors *bool
}

// Xero identifier for Tenant
func (r ApiCreatePurchaseOrdersRequest) XeroTenantId(xeroTenantId string) ApiCreatePurchaseOrdersRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// PurchaseOrders with an array of PurchaseOrder object in body of request
func (r ApiCreatePurchaseOrdersRequest) PurchaseOrders(purchaseOrders PurchaseOrders) ApiCreatePurchaseOrdersRequest {
	r.purchaseOrders = &purchaseOrders
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreatePurchaseOrdersRequest) IdempotencyKey(idempotencyKey string) ApiCreatePurchaseOrdersRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// If false return 200 OK and mix of successfully created objects and any with validation errors
func (r ApiCreatePurchaseOrdersRequest) SummarizeErrors(summarizeErrors bool) ApiCreatePurchaseOrdersRequest {
	r.summarizeErrors = &summarizeErrors
	return r
}

func (r ApiCreatePurchaseOrdersRequest) Execute() (*PurchaseOrders, *http.Response, error) {
	return r.ApiService.CreatePurchaseOrdersExecute(r)
}

/*
CreatePurchaseOrders Creates one or more purchase orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatePurchaseOrdersRequest
*/
func (a *AccountingAPIService) CreatePurchaseOrders(ctx context.Context) ApiCreatePurchaseOrdersRequest {
	return ApiCreatePurchaseOrdersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PurchaseOrders
func (a *AccountingAPIService) CreatePurchaseOrdersExecute(r ApiCreatePurchaseOrdersRequest) (*PurchaseOrders, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PurchaseOrders
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreatePurchaseOrders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PurchaseOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.purchaseOrders == nil {
		return localVarReturnValue, nil, reportError("purchaseOrders is required and must be specified")
	}

	if r.summarizeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarizeErrors", r.summarizeErrors, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.purchaseOrders
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateQuoteAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	quoteID string
	fileName string
	body *string
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateQuoteAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiCreateQuoteAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Byte array of file in body of request
func (r ApiCreateQuoteAttachmentByFileNameRequest) Body(body string) ApiCreateQuoteAttachmentByFileNameRequest {
	r.body = &body
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateQuoteAttachmentByFileNameRequest) IdempotencyKey(idempotencyKey string) ApiCreateQuoteAttachmentByFileNameRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateQuoteAttachmentByFileNameRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.CreateQuoteAttachmentByFileNameExecute(r)
}

/*
CreateQuoteAttachmentByFileName Creates attachment for a specific quote

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param quoteID Unique identifier for an Quote
 @param fileName Name of the attachment
 @return ApiCreateQuoteAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) CreateQuoteAttachmentByFileName(ctx context.Context, quoteID string, fileName string) ApiCreateQuoteAttachmentByFileNameRequest {
	return ApiCreateQuoteAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		quoteID: quoteID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) CreateQuoteAttachmentByFileNameExecute(r ApiCreateQuoteAttachmentByFileNameRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateQuoteAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Quotes/{QuoteID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"QuoteID"+"}", url.PathEscape(parameterValueToString(r.quoteID, "quoteID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateQuoteHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	quoteID string
	historyRecords *HistoryRecords
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateQuoteHistoryRequest) XeroTenantId(xeroTenantId string) ApiCreateQuoteHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// HistoryRecords containing an array of HistoryRecord objects in body of request
func (r ApiCreateQuoteHistoryRequest) HistoryRecords(historyRecords HistoryRecords) ApiCreateQuoteHistoryRequest {
	r.historyRecords = &historyRecords
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateQuoteHistoryRequest) IdempotencyKey(idempotencyKey string) ApiCreateQuoteHistoryRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateQuoteHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.CreateQuoteHistoryExecute(r)
}

/*
CreateQuoteHistory Creates a history record for a specific quote

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param quoteID Unique identifier for an Quote
 @return ApiCreateQuoteHistoryRequest
*/
func (a *AccountingAPIService) CreateQuoteHistory(ctx context.Context, quoteID string) ApiCreateQuoteHistoryRequest {
	return ApiCreateQuoteHistoryRequest{
		ApiService: a,
		ctx: ctx,
		quoteID: quoteID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) CreateQuoteHistoryExecute(r ApiCreateQuoteHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateQuoteHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Quotes/{QuoteID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"QuoteID"+"}", url.PathEscape(parameterValueToString(r.quoteID, "quoteID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.historyRecords == nil {
		return localVarReturnValue, nil, reportError("historyRecords is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.historyRecords
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateQuotesRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	quotes *Quotes
	idempotencyKey *string
	summarizeErrors *bool
}

// Xero identifier for Tenant
func (r ApiCreateQuotesRequest) XeroTenantId(xeroTenantId string) ApiCreateQuotesRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Quotes with an array of Quote object in body of request
func (r ApiCreateQuotesRequest) Quotes(quotes Quotes) ApiCreateQuotesRequest {
	r.quotes = &quotes
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateQuotesRequest) IdempotencyKey(idempotencyKey string) ApiCreateQuotesRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// If false return 200 OK and mix of successfully created objects and any with validation errors
func (r ApiCreateQuotesRequest) SummarizeErrors(summarizeErrors bool) ApiCreateQuotesRequest {
	r.summarizeErrors = &summarizeErrors
	return r
}

func (r ApiCreateQuotesRequest) Execute() (*Quotes, *http.Response, error) {
	return r.ApiService.CreateQuotesExecute(r)
}

/*
CreateQuotes Create one or more quotes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateQuotesRequest
*/
func (a *AccountingAPIService) CreateQuotes(ctx context.Context) ApiCreateQuotesRequest {
	return ApiCreateQuotesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Quotes
func (a *AccountingAPIService) CreateQuotesExecute(r ApiCreateQuotesRequest) (*Quotes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Quotes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateQuotes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Quotes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.quotes == nil {
		return localVarReturnValue, nil, reportError("quotes is required and must be specified")
	}

	if r.summarizeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarizeErrors", r.summarizeErrors, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.quotes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateReceiptRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	receipts *Receipts
	idempotencyKey *string
	unitdp *int32
}

// Xero identifier for Tenant
func (r ApiCreateReceiptRequest) XeroTenantId(xeroTenantId string) ApiCreateReceiptRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Receipts with an array of Receipt object in body of request
func (r ApiCreateReceiptRequest) Receipts(receipts Receipts) ApiCreateReceiptRequest {
	r.receipts = &receipts
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateReceiptRequest) IdempotencyKey(idempotencyKey string) ApiCreateReceiptRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiCreateReceiptRequest) Unitdp(unitdp int32) ApiCreateReceiptRequest {
	r.unitdp = &unitdp
	return r
}

func (r ApiCreateReceiptRequest) Execute() (*Receipts, *http.Response, error) {
	return r.ApiService.CreateReceiptExecute(r)
}

/*
CreateReceipt Creates draft expense claim receipts for any user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateReceiptRequest
*/
func (a *AccountingAPIService) CreateReceipt(ctx context.Context) ApiCreateReceiptRequest {
	return ApiCreateReceiptRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Receipts
func (a *AccountingAPIService) CreateReceiptExecute(r ApiCreateReceiptRequest) (*Receipts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Receipts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateReceipt")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Receipts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.receipts == nil {
		return localVarReturnValue, nil, reportError("receipts is required and must be specified")
	}

	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.receipts
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateReceiptAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	receiptID string
	fileName string
	body *string
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateReceiptAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiCreateReceiptAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Byte array of file in body of request
func (r ApiCreateReceiptAttachmentByFileNameRequest) Body(body string) ApiCreateReceiptAttachmentByFileNameRequest {
	r.body = &body
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateReceiptAttachmentByFileNameRequest) IdempotencyKey(idempotencyKey string) ApiCreateReceiptAttachmentByFileNameRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateReceiptAttachmentByFileNameRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.CreateReceiptAttachmentByFileNameExecute(r)
}

/*
CreateReceiptAttachmentByFileName Creates an attachment on a specific expense claim receipts by file name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param receiptID Unique identifier for a Receipt
 @param fileName Name of the attachment
 @return ApiCreateReceiptAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) CreateReceiptAttachmentByFileName(ctx context.Context, receiptID string, fileName string) ApiCreateReceiptAttachmentByFileNameRequest {
	return ApiCreateReceiptAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		receiptID: receiptID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) CreateReceiptAttachmentByFileNameExecute(r ApiCreateReceiptAttachmentByFileNameRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateReceiptAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Receipts/{ReceiptID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"ReceiptID"+"}", url.PathEscape(parameterValueToString(r.receiptID, "receiptID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateReceiptHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	receiptID string
	historyRecords *HistoryRecords
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateReceiptHistoryRequest) XeroTenantId(xeroTenantId string) ApiCreateReceiptHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// HistoryRecords containing an array of HistoryRecord objects in body of request
func (r ApiCreateReceiptHistoryRequest) HistoryRecords(historyRecords HistoryRecords) ApiCreateReceiptHistoryRequest {
	r.historyRecords = &historyRecords
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateReceiptHistoryRequest) IdempotencyKey(idempotencyKey string) ApiCreateReceiptHistoryRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateReceiptHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.CreateReceiptHistoryExecute(r)
}

/*
CreateReceiptHistory Creates a history record for a specific receipt

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param receiptID Unique identifier for a Receipt
 @return ApiCreateReceiptHistoryRequest
*/
func (a *AccountingAPIService) CreateReceiptHistory(ctx context.Context, receiptID string) ApiCreateReceiptHistoryRequest {
	return ApiCreateReceiptHistoryRequest{
		ApiService: a,
		ctx: ctx,
		receiptID: receiptID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) CreateReceiptHistoryExecute(r ApiCreateReceiptHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateReceiptHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Receipts/{ReceiptID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"ReceiptID"+"}", url.PathEscape(parameterValueToString(r.receiptID, "receiptID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.historyRecords == nil {
		return localVarReturnValue, nil, reportError("historyRecords is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.historyRecords
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateRepeatingInvoiceAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	repeatingInvoiceID string
	fileName string
	body *string
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateRepeatingInvoiceAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiCreateRepeatingInvoiceAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Byte array of file in body of request
func (r ApiCreateRepeatingInvoiceAttachmentByFileNameRequest) Body(body string) ApiCreateRepeatingInvoiceAttachmentByFileNameRequest {
	r.body = &body
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateRepeatingInvoiceAttachmentByFileNameRequest) IdempotencyKey(idempotencyKey string) ApiCreateRepeatingInvoiceAttachmentByFileNameRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateRepeatingInvoiceAttachmentByFileNameRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.CreateRepeatingInvoiceAttachmentByFileNameExecute(r)
}

/*
CreateRepeatingInvoiceAttachmentByFileName Creates an attachment from a specific repeating invoices by file name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repeatingInvoiceID Unique identifier for a Repeating Invoice
 @param fileName Name of the attachment
 @return ApiCreateRepeatingInvoiceAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) CreateRepeatingInvoiceAttachmentByFileName(ctx context.Context, repeatingInvoiceID string, fileName string) ApiCreateRepeatingInvoiceAttachmentByFileNameRequest {
	return ApiCreateRepeatingInvoiceAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		repeatingInvoiceID: repeatingInvoiceID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) CreateRepeatingInvoiceAttachmentByFileNameExecute(r ApiCreateRepeatingInvoiceAttachmentByFileNameRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateRepeatingInvoiceAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"RepeatingInvoiceID"+"}", url.PathEscape(parameterValueToString(r.repeatingInvoiceID, "repeatingInvoiceID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateRepeatingInvoiceHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	repeatingInvoiceID string
	historyRecords *HistoryRecords
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateRepeatingInvoiceHistoryRequest) XeroTenantId(xeroTenantId string) ApiCreateRepeatingInvoiceHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// HistoryRecords containing an array of HistoryRecord objects in body of request
func (r ApiCreateRepeatingInvoiceHistoryRequest) HistoryRecords(historyRecords HistoryRecords) ApiCreateRepeatingInvoiceHistoryRequest {
	r.historyRecords = &historyRecords
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateRepeatingInvoiceHistoryRequest) IdempotencyKey(idempotencyKey string) ApiCreateRepeatingInvoiceHistoryRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateRepeatingInvoiceHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.CreateRepeatingInvoiceHistoryExecute(r)
}

/*
CreateRepeatingInvoiceHistory Creates a  history record for a specific repeating invoice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repeatingInvoiceID Unique identifier for a Repeating Invoice
 @return ApiCreateRepeatingInvoiceHistoryRequest
*/
func (a *AccountingAPIService) CreateRepeatingInvoiceHistory(ctx context.Context, repeatingInvoiceID string) ApiCreateRepeatingInvoiceHistoryRequest {
	return ApiCreateRepeatingInvoiceHistoryRequest{
		ApiService: a,
		ctx: ctx,
		repeatingInvoiceID: repeatingInvoiceID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) CreateRepeatingInvoiceHistoryExecute(r ApiCreateRepeatingInvoiceHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateRepeatingInvoiceHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/RepeatingInvoices/{RepeatingInvoiceID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"RepeatingInvoiceID"+"}", url.PathEscape(parameterValueToString(r.repeatingInvoiceID, "repeatingInvoiceID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.historyRecords == nil {
		return localVarReturnValue, nil, reportError("historyRecords is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.historyRecords
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateRepeatingInvoicesRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	repeatingInvoices *RepeatingInvoices
	idempotencyKey *string
	summarizeErrors *bool
}

// Xero identifier for Tenant
func (r ApiCreateRepeatingInvoicesRequest) XeroTenantId(xeroTenantId string) ApiCreateRepeatingInvoicesRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// RepeatingInvoices with an array of repeating invoice objects in body of request
func (r ApiCreateRepeatingInvoicesRequest) RepeatingInvoices(repeatingInvoices RepeatingInvoices) ApiCreateRepeatingInvoicesRequest {
	r.repeatingInvoices = &repeatingInvoices
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateRepeatingInvoicesRequest) IdempotencyKey(idempotencyKey string) ApiCreateRepeatingInvoicesRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// If false return 200 OK and mix of successfully created objects and any with validation errors
func (r ApiCreateRepeatingInvoicesRequest) SummarizeErrors(summarizeErrors bool) ApiCreateRepeatingInvoicesRequest {
	r.summarizeErrors = &summarizeErrors
	return r
}

func (r ApiCreateRepeatingInvoicesRequest) Execute() (*RepeatingInvoices, *http.Response, error) {
	return r.ApiService.CreateRepeatingInvoicesExecute(r)
}

/*
CreateRepeatingInvoices Creates one or more repeating invoice templates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateRepeatingInvoicesRequest
*/
func (a *AccountingAPIService) CreateRepeatingInvoices(ctx context.Context) ApiCreateRepeatingInvoicesRequest {
	return ApiCreateRepeatingInvoicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RepeatingInvoices
func (a *AccountingAPIService) CreateRepeatingInvoicesExecute(r ApiCreateRepeatingInvoicesRequest) (*RepeatingInvoices, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RepeatingInvoices
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateRepeatingInvoices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/RepeatingInvoices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.repeatingInvoices == nil {
		return localVarReturnValue, nil, reportError("repeatingInvoices is required and must be specified")
	}

	if r.summarizeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarizeErrors", r.summarizeErrors, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.repeatingInvoices
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTaxRatesRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	taxRates *TaxRates
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateTaxRatesRequest) XeroTenantId(xeroTenantId string) ApiCreateTaxRatesRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// TaxRates array with TaxRate object in body of request
func (r ApiCreateTaxRatesRequest) TaxRates(taxRates TaxRates) ApiCreateTaxRatesRequest {
	r.taxRates = &taxRates
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateTaxRatesRequest) IdempotencyKey(idempotencyKey string) ApiCreateTaxRatesRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateTaxRatesRequest) Execute() (*TaxRates, *http.Response, error) {
	return r.ApiService.CreateTaxRatesExecute(r)
}

/*
CreateTaxRates Creates one or more tax rates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTaxRatesRequest
*/
func (a *AccountingAPIService) CreateTaxRates(ctx context.Context) ApiCreateTaxRatesRequest {
	return ApiCreateTaxRatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TaxRates
func (a *AccountingAPIService) CreateTaxRatesExecute(r ApiCreateTaxRatesRequest) (*TaxRates, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaxRates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateTaxRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/TaxRates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.taxRates == nil {
		return localVarReturnValue, nil, reportError("taxRates is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.taxRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTrackingCategoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	trackingCategory *TrackingCategory
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateTrackingCategoryRequest) XeroTenantId(xeroTenantId string) ApiCreateTrackingCategoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// TrackingCategory object in body of request
func (r ApiCreateTrackingCategoryRequest) TrackingCategory(trackingCategory TrackingCategory) ApiCreateTrackingCategoryRequest {
	r.trackingCategory = &trackingCategory
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateTrackingCategoryRequest) IdempotencyKey(idempotencyKey string) ApiCreateTrackingCategoryRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateTrackingCategoryRequest) Execute() (*TrackingCategories, *http.Response, error) {
	return r.ApiService.CreateTrackingCategoryExecute(r)
}

/*
CreateTrackingCategory Create tracking categories

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTrackingCategoryRequest
*/
func (a *AccountingAPIService) CreateTrackingCategory(ctx context.Context) ApiCreateTrackingCategoryRequest {
	return ApiCreateTrackingCategoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TrackingCategories
func (a *AccountingAPIService) CreateTrackingCategoryExecute(r ApiCreateTrackingCategoryRequest) (*TrackingCategories, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrackingCategories
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateTrackingCategory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/TrackingCategories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.trackingCategory == nil {
		return localVarReturnValue, nil, reportError("trackingCategory is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.trackingCategory
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTrackingOptionsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	trackingCategoryID string
	trackingOption *TrackingOption
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiCreateTrackingOptionsRequest) XeroTenantId(xeroTenantId string) ApiCreateTrackingOptionsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// TrackingOption object in body of request
func (r ApiCreateTrackingOptionsRequest) TrackingOption(trackingOption TrackingOption) ApiCreateTrackingOptionsRequest {
	r.trackingOption = &trackingOption
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiCreateTrackingOptionsRequest) IdempotencyKey(idempotencyKey string) ApiCreateTrackingOptionsRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiCreateTrackingOptionsRequest) Execute() (*TrackingOptions, *http.Response, error) {
	return r.ApiService.CreateTrackingOptionsExecute(r)
}

/*
CreateTrackingOptions Creates options for a specific tracking category

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trackingCategoryID Unique identifier for a TrackingCategory
 @return ApiCreateTrackingOptionsRequest
*/
func (a *AccountingAPIService) CreateTrackingOptions(ctx context.Context, trackingCategoryID string) ApiCreateTrackingOptionsRequest {
	return ApiCreateTrackingOptionsRequest{
		ApiService: a,
		ctx: ctx,
		trackingCategoryID: trackingCategoryID,
	}
}

// Execute executes the request
//  @return TrackingOptions
func (a *AccountingAPIService) CreateTrackingOptionsExecute(r ApiCreateTrackingOptionsRequest) (*TrackingOptions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrackingOptions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.CreateTrackingOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/TrackingCategories/{TrackingCategoryID}/Options"
	localVarPath = strings.Replace(localVarPath, "{"+"TrackingCategoryID"+"}", url.PathEscape(parameterValueToString(r.trackingCategoryID, "trackingCategoryID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.trackingOption == nil {
		return localVarReturnValue, nil, reportError("trackingOption is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.trackingOption
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAccountRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	accountID string
}

// Xero identifier for Tenant
func (r ApiDeleteAccountRequest) XeroTenantId(xeroTenantId string) ApiDeleteAccountRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiDeleteAccountRequest) Execute() (*Accounts, *http.Response, error) {
	return r.ApiService.DeleteAccountExecute(r)
}

/*
DeleteAccount Deletes a chart of accounts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID Unique identifier for Account object
 @return ApiDeleteAccountRequest
*/
func (a *AccountingAPIService) DeleteAccount(ctx context.Context, accountID string) ApiDeleteAccountRequest {
	return ApiDeleteAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
	}
}

// Execute executes the request
//  @return Accounts
func (a *AccountingAPIService) DeleteAccountExecute(r ApiDeleteAccountRequest) (*Accounts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Accounts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.DeleteAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Accounts/{AccountID}"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountID"+"}", url.PathEscape(parameterValueToString(r.accountID, "accountID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBatchPaymentRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	batchPaymentDelete *BatchPaymentDelete
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiDeleteBatchPaymentRequest) XeroTenantId(xeroTenantId string) ApiDeleteBatchPaymentRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiDeleteBatchPaymentRequest) BatchPaymentDelete(batchPaymentDelete BatchPaymentDelete) ApiDeleteBatchPaymentRequest {
	r.batchPaymentDelete = &batchPaymentDelete
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiDeleteBatchPaymentRequest) IdempotencyKey(idempotencyKey string) ApiDeleteBatchPaymentRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiDeleteBatchPaymentRequest) Execute() (*BatchPayments, *http.Response, error) {
	return r.ApiService.DeleteBatchPaymentExecute(r)
}

/*
DeleteBatchPayment Updates a specific batch payment for invoices and credit notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteBatchPaymentRequest
*/
func (a *AccountingAPIService) DeleteBatchPayment(ctx context.Context) ApiDeleteBatchPaymentRequest {
	return ApiDeleteBatchPaymentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchPayments
func (a *AccountingAPIService) DeleteBatchPaymentExecute(r ApiDeleteBatchPaymentRequest) (*BatchPayments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchPayments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.DeleteBatchPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BatchPayments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.batchPaymentDelete == nil {
		return localVarReturnValue, nil, reportError("batchPaymentDelete is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.batchPaymentDelete
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBatchPaymentByUrlParamRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	batchPaymentID string
	batchPaymentDeleteByUrlParam *BatchPaymentDeleteByUrlParam
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiDeleteBatchPaymentByUrlParamRequest) XeroTenantId(xeroTenantId string) ApiDeleteBatchPaymentByUrlParamRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiDeleteBatchPaymentByUrlParamRequest) BatchPaymentDeleteByUrlParam(batchPaymentDeleteByUrlParam BatchPaymentDeleteByUrlParam) ApiDeleteBatchPaymentByUrlParamRequest {
	r.batchPaymentDeleteByUrlParam = &batchPaymentDeleteByUrlParam
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiDeleteBatchPaymentByUrlParamRequest) IdempotencyKey(idempotencyKey string) ApiDeleteBatchPaymentByUrlParamRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiDeleteBatchPaymentByUrlParamRequest) Execute() (*BatchPayments, *http.Response, error) {
	return r.ApiService.DeleteBatchPaymentByUrlParamExecute(r)
}

/*
DeleteBatchPaymentByUrlParam Updates a specific batch payment for invoices and credit notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchPaymentID Unique identifier for BatchPayment
 @return ApiDeleteBatchPaymentByUrlParamRequest
*/
func (a *AccountingAPIService) DeleteBatchPaymentByUrlParam(ctx context.Context, batchPaymentID string) ApiDeleteBatchPaymentByUrlParamRequest {
	return ApiDeleteBatchPaymentByUrlParamRequest{
		ApiService: a,
		ctx: ctx,
		batchPaymentID: batchPaymentID,
	}
}

// Execute executes the request
//  @return BatchPayments
func (a *AccountingAPIService) DeleteBatchPaymentByUrlParamExecute(r ApiDeleteBatchPaymentByUrlParamRequest) (*BatchPayments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchPayments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.DeleteBatchPaymentByUrlParam")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BatchPayments/{BatchPaymentID}"
	localVarPath = strings.Replace(localVarPath, "{"+"BatchPaymentID"+"}", url.PathEscape(parameterValueToString(r.batchPaymentID, "batchPaymentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.batchPaymentDeleteByUrlParam == nil {
		return localVarReturnValue, nil, reportError("batchPaymentDeleteByUrlParam is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.batchPaymentDeleteByUrlParam
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteContactGroupContactRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	contactGroupID string
	contactID string
}

// Xero identifier for Tenant
func (r ApiDeleteContactGroupContactRequest) XeroTenantId(xeroTenantId string) ApiDeleteContactGroupContactRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiDeleteContactGroupContactRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteContactGroupContactExecute(r)
}

/*
DeleteContactGroupContact Deletes a specific contact from a contact group using a unique contact Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactGroupID Unique identifier for a Contact Group
 @param contactID Unique identifier for a Contact
 @return ApiDeleteContactGroupContactRequest
*/
func (a *AccountingAPIService) DeleteContactGroupContact(ctx context.Context, contactGroupID string, contactID string) ApiDeleteContactGroupContactRequest {
	return ApiDeleteContactGroupContactRequest{
		ApiService: a,
		ctx: ctx,
		contactGroupID: contactGroupID,
		contactID: contactID,
	}
}

// Execute executes the request
func (a *AccountingAPIService) DeleteContactGroupContactExecute(r ApiDeleteContactGroupContactRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.DeleteContactGroupContact")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ContactGroups/{ContactGroupID}/Contacts/{ContactID}"
	localVarPath = strings.Replace(localVarPath, "{"+"ContactGroupID"+"}", url.PathEscape(parameterValueToString(r.contactGroupID, "contactGroupID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ContactID"+"}", url.PathEscape(parameterValueToString(r.contactID, "contactID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteContactGroupContactsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	contactGroupID string
}

// Xero identifier for Tenant
func (r ApiDeleteContactGroupContactsRequest) XeroTenantId(xeroTenantId string) ApiDeleteContactGroupContactsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiDeleteContactGroupContactsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteContactGroupContactsExecute(r)
}

/*
DeleteContactGroupContacts Deletes all contacts from a specific contact group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactGroupID Unique identifier for a Contact Group
 @return ApiDeleteContactGroupContactsRequest
*/
func (a *AccountingAPIService) DeleteContactGroupContacts(ctx context.Context, contactGroupID string) ApiDeleteContactGroupContactsRequest {
	return ApiDeleteContactGroupContactsRequest{
		ApiService: a,
		ctx: ctx,
		contactGroupID: contactGroupID,
	}
}

// Execute executes the request
func (a *AccountingAPIService) DeleteContactGroupContactsExecute(r ApiDeleteContactGroupContactsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.DeleteContactGroupContacts")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ContactGroups/{ContactGroupID}/Contacts"
	localVarPath = strings.Replace(localVarPath, "{"+"ContactGroupID"+"}", url.PathEscape(parameterValueToString(r.contactGroupID, "contactGroupID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteCreditNoteAllocationsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	creditNoteID string
	allocationID string
}

// Xero identifier for Tenant
func (r ApiDeleteCreditNoteAllocationsRequest) XeroTenantId(xeroTenantId string) ApiDeleteCreditNoteAllocationsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiDeleteCreditNoteAllocationsRequest) Execute() (*Allocation, *http.Response, error) {
	return r.ApiService.DeleteCreditNoteAllocationsExecute(r)
}

/*
DeleteCreditNoteAllocations Deletes an Allocation from a Credit Note

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param creditNoteID Unique identifier for a Credit Note
 @param allocationID Unique identifier for Allocation object
 @return ApiDeleteCreditNoteAllocationsRequest
*/
func (a *AccountingAPIService) DeleteCreditNoteAllocations(ctx context.Context, creditNoteID string, allocationID string) ApiDeleteCreditNoteAllocationsRequest {
	return ApiDeleteCreditNoteAllocationsRequest{
		ApiService: a,
		ctx: ctx,
		creditNoteID: creditNoteID,
		allocationID: allocationID,
	}
}

// Execute executes the request
//  @return Allocation
func (a *AccountingAPIService) DeleteCreditNoteAllocationsExecute(r ApiDeleteCreditNoteAllocationsRequest) (*Allocation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Allocation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.DeleteCreditNoteAllocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CreditNotes/{CreditNoteID}/Allocations/{AllocationID}"
	localVarPath = strings.Replace(localVarPath, "{"+"CreditNoteID"+"}", url.PathEscape(parameterValueToString(r.creditNoteID, "creditNoteID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"AllocationID"+"}", url.PathEscape(parameterValueToString(r.allocationID, "allocationID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteItemRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	itemID string
}

// Xero identifier for Tenant
func (r ApiDeleteItemRequest) XeroTenantId(xeroTenantId string) ApiDeleteItemRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiDeleteItemRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteItemExecute(r)
}

/*
DeleteItem Deletes a specific item

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemID Unique identifier for an Item
 @return ApiDeleteItemRequest
*/
func (a *AccountingAPIService) DeleteItem(ctx context.Context, itemID string) ApiDeleteItemRequest {
	return ApiDeleteItemRequest{
		ApiService: a,
		ctx: ctx,
		itemID: itemID,
	}
}

// Execute executes the request
func (a *AccountingAPIService) DeleteItemExecute(r ApiDeleteItemRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.DeleteItem")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{ItemID}"
	localVarPath = strings.Replace(localVarPath, "{"+"ItemID"+"}", url.PathEscape(parameterValueToString(r.itemID, "itemID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteLinkedTransactionRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	linkedTransactionID string
}

// Xero identifier for Tenant
func (r ApiDeleteLinkedTransactionRequest) XeroTenantId(xeroTenantId string) ApiDeleteLinkedTransactionRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiDeleteLinkedTransactionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLinkedTransactionExecute(r)
}

/*
DeleteLinkedTransaction Deletes a specific linked transactions (billable expenses)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param linkedTransactionID Unique identifier for a LinkedTransaction
 @return ApiDeleteLinkedTransactionRequest
*/
func (a *AccountingAPIService) DeleteLinkedTransaction(ctx context.Context, linkedTransactionID string) ApiDeleteLinkedTransactionRequest {
	return ApiDeleteLinkedTransactionRequest{
		ApiService: a,
		ctx: ctx,
		linkedTransactionID: linkedTransactionID,
	}
}

// Execute executes the request
func (a *AccountingAPIService) DeleteLinkedTransactionExecute(r ApiDeleteLinkedTransactionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.DeleteLinkedTransaction")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LinkedTransactions/{LinkedTransactionID}"
	localVarPath = strings.Replace(localVarPath, "{"+"LinkedTransactionID"+"}", url.PathEscape(parameterValueToString(r.linkedTransactionID, "linkedTransactionID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteOverpaymentAllocationsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	overpaymentID string
	allocationID string
}

// Xero identifier for Tenant
func (r ApiDeleteOverpaymentAllocationsRequest) XeroTenantId(xeroTenantId string) ApiDeleteOverpaymentAllocationsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiDeleteOverpaymentAllocationsRequest) Execute() (*Allocation, *http.Response, error) {
	return r.ApiService.DeleteOverpaymentAllocationsExecute(r)
}

/*
DeleteOverpaymentAllocations Deletes an Allocation from an overpayment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param overpaymentID Unique identifier for a Overpayment
 @param allocationID Unique identifier for Allocation object
 @return ApiDeleteOverpaymentAllocationsRequest
*/
func (a *AccountingAPIService) DeleteOverpaymentAllocations(ctx context.Context, overpaymentID string, allocationID string) ApiDeleteOverpaymentAllocationsRequest {
	return ApiDeleteOverpaymentAllocationsRequest{
		ApiService: a,
		ctx: ctx,
		overpaymentID: overpaymentID,
		allocationID: allocationID,
	}
}

// Execute executes the request
//  @return Allocation
func (a *AccountingAPIService) DeleteOverpaymentAllocationsExecute(r ApiDeleteOverpaymentAllocationsRequest) (*Allocation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Allocation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.DeleteOverpaymentAllocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Overpayments/{OverpaymentID}/Allocations/{AllocationID}"
	localVarPath = strings.Replace(localVarPath, "{"+"OverpaymentID"+"}", url.PathEscape(parameterValueToString(r.overpaymentID, "overpaymentID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"AllocationID"+"}", url.PathEscape(parameterValueToString(r.allocationID, "allocationID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePaymentRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	paymentID string
	paymentDelete *PaymentDelete
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiDeletePaymentRequest) XeroTenantId(xeroTenantId string) ApiDeletePaymentRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiDeletePaymentRequest) PaymentDelete(paymentDelete PaymentDelete) ApiDeletePaymentRequest {
	r.paymentDelete = &paymentDelete
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiDeletePaymentRequest) IdempotencyKey(idempotencyKey string) ApiDeletePaymentRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiDeletePaymentRequest) Execute() (*Payments, *http.Response, error) {
	return r.ApiService.DeletePaymentExecute(r)
}

/*
DeletePayment Updates a specific payment for invoices and credit notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param paymentID Unique identifier for a Payment
 @return ApiDeletePaymentRequest
*/
func (a *AccountingAPIService) DeletePayment(ctx context.Context, paymentID string) ApiDeletePaymentRequest {
	return ApiDeletePaymentRequest{
		ApiService: a,
		ctx: ctx,
		paymentID: paymentID,
	}
}

// Execute executes the request
//  @return Payments
func (a *AccountingAPIService) DeletePaymentExecute(r ApiDeletePaymentRequest) (*Payments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Payments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.DeletePayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Payments/{PaymentID}"
	localVarPath = strings.Replace(localVarPath, "{"+"PaymentID"+"}", url.PathEscape(parameterValueToString(r.paymentID, "paymentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.paymentDelete == nil {
		return localVarReturnValue, nil, reportError("paymentDelete is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.paymentDelete
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePrepaymentAllocationsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	prepaymentID string
	allocationID string
}

// Xero identifier for Tenant
func (r ApiDeletePrepaymentAllocationsRequest) XeroTenantId(xeroTenantId string) ApiDeletePrepaymentAllocationsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiDeletePrepaymentAllocationsRequest) Execute() (*Allocation, *http.Response, error) {
	return r.ApiService.DeletePrepaymentAllocationsExecute(r)
}

/*
DeletePrepaymentAllocations Deletes an Allocation from a Prepayment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param prepaymentID Unique identifier for a PrePayment
 @param allocationID Unique identifier for Allocation object
 @return ApiDeletePrepaymentAllocationsRequest
*/
func (a *AccountingAPIService) DeletePrepaymentAllocations(ctx context.Context, prepaymentID string, allocationID string) ApiDeletePrepaymentAllocationsRequest {
	return ApiDeletePrepaymentAllocationsRequest{
		ApiService: a,
		ctx: ctx,
		prepaymentID: prepaymentID,
		allocationID: allocationID,
	}
}

// Execute executes the request
//  @return Allocation
func (a *AccountingAPIService) DeletePrepaymentAllocationsExecute(r ApiDeletePrepaymentAllocationsRequest) (*Allocation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Allocation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.DeletePrepaymentAllocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Prepayments/{PrepaymentID}/Allocations/{AllocationID}"
	localVarPath = strings.Replace(localVarPath, "{"+"PrepaymentID"+"}", url.PathEscape(parameterValueToString(r.prepaymentID, "prepaymentID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"AllocationID"+"}", url.PathEscape(parameterValueToString(r.allocationID, "allocationID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteTrackingCategoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	trackingCategoryID string
}

// Xero identifier for Tenant
func (r ApiDeleteTrackingCategoryRequest) XeroTenantId(xeroTenantId string) ApiDeleteTrackingCategoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiDeleteTrackingCategoryRequest) Execute() (*TrackingCategories, *http.Response, error) {
	return r.ApiService.DeleteTrackingCategoryExecute(r)
}

/*
DeleteTrackingCategory Deletes a specific tracking category

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trackingCategoryID Unique identifier for a TrackingCategory
 @return ApiDeleteTrackingCategoryRequest
*/
func (a *AccountingAPIService) DeleteTrackingCategory(ctx context.Context, trackingCategoryID string) ApiDeleteTrackingCategoryRequest {
	return ApiDeleteTrackingCategoryRequest{
		ApiService: a,
		ctx: ctx,
		trackingCategoryID: trackingCategoryID,
	}
}

// Execute executes the request
//  @return TrackingCategories
func (a *AccountingAPIService) DeleteTrackingCategoryExecute(r ApiDeleteTrackingCategoryRequest) (*TrackingCategories, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrackingCategories
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.DeleteTrackingCategory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/TrackingCategories/{TrackingCategoryID}"
	localVarPath = strings.Replace(localVarPath, "{"+"TrackingCategoryID"+"}", url.PathEscape(parameterValueToString(r.trackingCategoryID, "trackingCategoryID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteTrackingOptionsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	trackingCategoryID string
	trackingOptionID string
}

// Xero identifier for Tenant
func (r ApiDeleteTrackingOptionsRequest) XeroTenantId(xeroTenantId string) ApiDeleteTrackingOptionsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiDeleteTrackingOptionsRequest) Execute() (*TrackingOptions, *http.Response, error) {
	return r.ApiService.DeleteTrackingOptionsExecute(r)
}

/*
DeleteTrackingOptions Deletes a specific option for a specific tracking category

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trackingCategoryID Unique identifier for a TrackingCategory
 @param trackingOptionID Unique identifier for a Tracking Option
 @return ApiDeleteTrackingOptionsRequest
*/
func (a *AccountingAPIService) DeleteTrackingOptions(ctx context.Context, trackingCategoryID string, trackingOptionID string) ApiDeleteTrackingOptionsRequest {
	return ApiDeleteTrackingOptionsRequest{
		ApiService: a,
		ctx: ctx,
		trackingCategoryID: trackingCategoryID,
		trackingOptionID: trackingOptionID,
	}
}

// Execute executes the request
//  @return TrackingOptions
func (a *AccountingAPIService) DeleteTrackingOptionsExecute(r ApiDeleteTrackingOptionsRequest) (*TrackingOptions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrackingOptions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.DeleteTrackingOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/TrackingCategories/{TrackingCategoryID}/Options/{TrackingOptionID}"
	localVarPath = strings.Replace(localVarPath, "{"+"TrackingCategoryID"+"}", url.PathEscape(parameterValueToString(r.trackingCategoryID, "trackingCategoryID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"TrackingOptionID"+"}", url.PathEscape(parameterValueToString(r.trackingOptionID, "trackingOptionID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEmailInvoiceRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	invoiceID string
	requestEmpty *RequestEmpty
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiEmailInvoiceRequest) XeroTenantId(xeroTenantId string) ApiEmailInvoiceRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiEmailInvoiceRequest) RequestEmpty(requestEmpty RequestEmpty) ApiEmailInvoiceRequest {
	r.requestEmpty = &requestEmpty
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiEmailInvoiceRequest) IdempotencyKey(idempotencyKey string) ApiEmailInvoiceRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiEmailInvoiceRequest) Execute() (*http.Response, error) {
	return r.ApiService.EmailInvoiceExecute(r)
}

/*
EmailInvoice Sends a copy of a specific invoice to related contact via email

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceID Unique identifier for an Invoice
 @return ApiEmailInvoiceRequest
*/
func (a *AccountingAPIService) EmailInvoice(ctx context.Context, invoiceID string) ApiEmailInvoiceRequest {
	return ApiEmailInvoiceRequest{
		ApiService: a,
		ctx: ctx,
		invoiceID: invoiceID,
	}
}

// Execute executes the request
func (a *AccountingAPIService) EmailInvoiceExecute(r ApiEmailInvoiceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.EmailInvoice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Invoices/{InvoiceID}/Email"
	localVarPath = strings.Replace(localVarPath, "{"+"InvoiceID"+"}", url.PathEscape(parameterValueToString(r.invoiceID, "invoiceID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.requestEmpty == nil {
		return nil, reportError("requestEmpty is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.requestEmpty
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAccountRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	accountID string
}

// Xero identifier for Tenant
func (r ApiGetAccountRequest) XeroTenantId(xeroTenantId string) ApiGetAccountRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetAccountRequest) Execute() (*Accounts, *http.Response, error) {
	return r.ApiService.GetAccountExecute(r)
}

/*
GetAccount Retrieves a single chart of accounts by using a unique account Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID Unique identifier for Account object
 @return ApiGetAccountRequest
*/
func (a *AccountingAPIService) GetAccount(ctx context.Context, accountID string) ApiGetAccountRequest {
	return ApiGetAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
	}
}

// Execute executes the request
//  @return Accounts
func (a *AccountingAPIService) GetAccountExecute(r ApiGetAccountRequest) (*Accounts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Accounts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Accounts/{AccountID}"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountID"+"}", url.PathEscape(parameterValueToString(r.accountID, "accountID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	accountID string
	fileName string
	contentType *string
}

// Xero identifier for Tenant
func (r ApiGetAccountAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiGetAccountAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
func (r ApiGetAccountAttachmentByFileNameRequest) ContentType(contentType string) ApiGetAccountAttachmentByFileNameRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetAccountAttachmentByFileNameRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetAccountAttachmentByFileNameExecute(r)
}

/*
GetAccountAttachmentByFileName Retrieves an attachment for a specific account by filename

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID Unique identifier for Account object
 @param fileName Name of the attachment
 @return ApiGetAccountAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) GetAccountAttachmentByFileName(ctx context.Context, accountID string, fileName string) ApiGetAccountAttachmentByFileNameRequest {
	return ApiGetAccountAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetAccountAttachmentByFileNameExecute(r ApiGetAccountAttachmentByFileNameRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetAccountAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Accounts/{AccountID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountID"+"}", url.PathEscape(parameterValueToString(r.accountID, "accountID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "contentType", r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountAttachmentByIdRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	accountID string
	attachmentID string
	contentType *string
}

// Xero identifier for Tenant
func (r ApiGetAccountAttachmentByIdRequest) XeroTenantId(xeroTenantId string) ApiGetAccountAttachmentByIdRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
func (r ApiGetAccountAttachmentByIdRequest) ContentType(contentType string) ApiGetAccountAttachmentByIdRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetAccountAttachmentByIdRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetAccountAttachmentByIdExecute(r)
}

/*
GetAccountAttachmentById Retrieves a specific attachment from a specific account using a unique attachment Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID Unique identifier for Account object
 @param attachmentID Unique identifier for Attachment object
 @return ApiGetAccountAttachmentByIdRequest
*/
func (a *AccountingAPIService) GetAccountAttachmentById(ctx context.Context, accountID string, attachmentID string) ApiGetAccountAttachmentByIdRequest {
	return ApiGetAccountAttachmentByIdRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
		attachmentID: attachmentID,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetAccountAttachmentByIdExecute(r ApiGetAccountAttachmentByIdRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetAccountAttachmentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Accounts/{AccountID}/Attachments/{AttachmentID}"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountID"+"}", url.PathEscape(parameterValueToString(r.accountID, "accountID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"AttachmentID"+"}", url.PathEscape(parameterValueToString(r.attachmentID, "attachmentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "contentType", r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountAttachmentsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	accountID string
}

// Xero identifier for Tenant
func (r ApiGetAccountAttachmentsRequest) XeroTenantId(xeroTenantId string) ApiGetAccountAttachmentsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetAccountAttachmentsRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.GetAccountAttachmentsExecute(r)
}

/*
GetAccountAttachments Retrieves attachments for a specific accounts by using a unique account Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID Unique identifier for Account object
 @return ApiGetAccountAttachmentsRequest
*/
func (a *AccountingAPIService) GetAccountAttachments(ctx context.Context, accountID string) ApiGetAccountAttachmentsRequest {
	return ApiGetAccountAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) GetAccountAttachmentsExecute(r ApiGetAccountAttachmentsRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetAccountAttachments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Accounts/{AccountID}/Attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountID"+"}", url.PathEscape(parameterValueToString(r.accountID, "accountID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	ifModifiedSince *time.Time
	where *string
	order *string
}

// Xero identifier for Tenant
func (r ApiGetAccountsRequest) XeroTenantId(xeroTenantId string) ApiGetAccountsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Only records created or modified since this timestamp will be returned
func (r ApiGetAccountsRequest) IfModifiedSince(ifModifiedSince time.Time) ApiGetAccountsRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

// Filter by an any element
func (r ApiGetAccountsRequest) Where(where string) ApiGetAccountsRequest {
	r.where = &where
	return r
}

// Order by an any element
func (r ApiGetAccountsRequest) Order(order string) ApiGetAccountsRequest {
	r.order = &order
	return r
}

func (r ApiGetAccountsRequest) Execute() (*Accounts, *http.Response, error) {
	return r.ApiService.GetAccountsExecute(r)
}

/*
GetAccounts Retrieves the full chart of accounts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountsRequest
*/
func (a *AccountingAPIService) GetAccounts(ctx context.Context) ApiGetAccountsRequest {
	return ApiGetAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Accounts
func (a *AccountingAPIService) GetAccountsExecute(r ApiGetAccountsRequest) (*Accounts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Accounts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBankTransactionRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	bankTransactionID string
	unitdp *int32
}

// Xero identifier for Tenant
func (r ApiGetBankTransactionRequest) XeroTenantId(xeroTenantId string) ApiGetBankTransactionRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiGetBankTransactionRequest) Unitdp(unitdp int32) ApiGetBankTransactionRequest {
	r.unitdp = &unitdp
	return r
}

func (r ApiGetBankTransactionRequest) Execute() (*BankTransactions, *http.Response, error) {
	return r.ApiService.GetBankTransactionExecute(r)
}

/*
GetBankTransaction Retrieves a single spent or received money transaction by using a unique bank transaction Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bankTransactionID Xero generated unique identifier for a bank transaction
 @return ApiGetBankTransactionRequest
*/
func (a *AccountingAPIService) GetBankTransaction(ctx context.Context, bankTransactionID string) ApiGetBankTransactionRequest {
	return ApiGetBankTransactionRequest{
		ApiService: a,
		ctx: ctx,
		bankTransactionID: bankTransactionID,
	}
}

// Execute executes the request
//  @return BankTransactions
func (a *AccountingAPIService) GetBankTransactionExecute(r ApiGetBankTransactionRequest) (*BankTransactions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BankTransactions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetBankTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BankTransactions/{BankTransactionID}"
	localVarPath = strings.Replace(localVarPath, "{"+"BankTransactionID"+"}", url.PathEscape(parameterValueToString(r.bankTransactionID, "bankTransactionID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBankTransactionAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	bankTransactionID string
	fileName string
	contentType *string
}

// Xero identifier for Tenant
func (r ApiGetBankTransactionAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiGetBankTransactionAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
func (r ApiGetBankTransactionAttachmentByFileNameRequest) ContentType(contentType string) ApiGetBankTransactionAttachmentByFileNameRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetBankTransactionAttachmentByFileNameRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetBankTransactionAttachmentByFileNameExecute(r)
}

/*
GetBankTransactionAttachmentByFileName Retrieves a specific attachment from a specific bank transaction by filename

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bankTransactionID Xero generated unique identifier for a bank transaction
 @param fileName Name of the attachment
 @return ApiGetBankTransactionAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) GetBankTransactionAttachmentByFileName(ctx context.Context, bankTransactionID string, fileName string) ApiGetBankTransactionAttachmentByFileNameRequest {
	return ApiGetBankTransactionAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		bankTransactionID: bankTransactionID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetBankTransactionAttachmentByFileNameExecute(r ApiGetBankTransactionAttachmentByFileNameRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetBankTransactionAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BankTransactions/{BankTransactionID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"BankTransactionID"+"}", url.PathEscape(parameterValueToString(r.bankTransactionID, "bankTransactionID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "contentType", r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBankTransactionAttachmentByIdRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	bankTransactionID string
	attachmentID string
	contentType *string
}

// Xero identifier for Tenant
func (r ApiGetBankTransactionAttachmentByIdRequest) XeroTenantId(xeroTenantId string) ApiGetBankTransactionAttachmentByIdRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
func (r ApiGetBankTransactionAttachmentByIdRequest) ContentType(contentType string) ApiGetBankTransactionAttachmentByIdRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetBankTransactionAttachmentByIdRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetBankTransactionAttachmentByIdExecute(r)
}

/*
GetBankTransactionAttachmentById Retrieves specific attachments from a specific BankTransaction using a unique attachment Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bankTransactionID Xero generated unique identifier for a bank transaction
 @param attachmentID Unique identifier for Attachment object
 @return ApiGetBankTransactionAttachmentByIdRequest
*/
func (a *AccountingAPIService) GetBankTransactionAttachmentById(ctx context.Context, bankTransactionID string, attachmentID string) ApiGetBankTransactionAttachmentByIdRequest {
	return ApiGetBankTransactionAttachmentByIdRequest{
		ApiService: a,
		ctx: ctx,
		bankTransactionID: bankTransactionID,
		attachmentID: attachmentID,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetBankTransactionAttachmentByIdExecute(r ApiGetBankTransactionAttachmentByIdRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetBankTransactionAttachmentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BankTransactions/{BankTransactionID}/Attachments/{AttachmentID}"
	localVarPath = strings.Replace(localVarPath, "{"+"BankTransactionID"+"}", url.PathEscape(parameterValueToString(r.bankTransactionID, "bankTransactionID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"AttachmentID"+"}", url.PathEscape(parameterValueToString(r.attachmentID, "attachmentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "contentType", r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBankTransactionAttachmentsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	bankTransactionID string
}

// Xero identifier for Tenant
func (r ApiGetBankTransactionAttachmentsRequest) XeroTenantId(xeroTenantId string) ApiGetBankTransactionAttachmentsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetBankTransactionAttachmentsRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.GetBankTransactionAttachmentsExecute(r)
}

/*
GetBankTransactionAttachments Retrieves any attachments from a specific bank transactions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bankTransactionID Xero generated unique identifier for a bank transaction
 @return ApiGetBankTransactionAttachmentsRequest
*/
func (a *AccountingAPIService) GetBankTransactionAttachments(ctx context.Context, bankTransactionID string) ApiGetBankTransactionAttachmentsRequest {
	return ApiGetBankTransactionAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		bankTransactionID: bankTransactionID,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) GetBankTransactionAttachmentsExecute(r ApiGetBankTransactionAttachmentsRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetBankTransactionAttachments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BankTransactions/{BankTransactionID}/Attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"BankTransactionID"+"}", url.PathEscape(parameterValueToString(r.bankTransactionID, "bankTransactionID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBankTransactionsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	ifModifiedSince *time.Time
	where *string
	order *string
	page *int32
	unitdp *int32
}

// Xero identifier for Tenant
func (r ApiGetBankTransactionsRequest) XeroTenantId(xeroTenantId string) ApiGetBankTransactionsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Only records created or modified since this timestamp will be returned
func (r ApiGetBankTransactionsRequest) IfModifiedSince(ifModifiedSince time.Time) ApiGetBankTransactionsRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

// Filter by an any element
func (r ApiGetBankTransactionsRequest) Where(where string) ApiGetBankTransactionsRequest {
	r.where = &where
	return r
}

// Order by an any element
func (r ApiGetBankTransactionsRequest) Order(order string) ApiGetBankTransactionsRequest {
	r.order = &order
	return r
}

// Up to 100 bank transactions will be returned in a single API call with line items details
func (r ApiGetBankTransactionsRequest) Page(page int32) ApiGetBankTransactionsRequest {
	r.page = &page
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiGetBankTransactionsRequest) Unitdp(unitdp int32) ApiGetBankTransactionsRequest {
	r.unitdp = &unitdp
	return r
}

func (r ApiGetBankTransactionsRequest) Execute() (*BankTransactions, *http.Response, error) {
	return r.ApiService.GetBankTransactionsExecute(r)
}

/*
GetBankTransactions Retrieves any spent or received money transactions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBankTransactionsRequest
*/
func (a *AccountingAPIService) GetBankTransactions(ctx context.Context) ApiGetBankTransactionsRequest {
	return ApiGetBankTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BankTransactions
func (a *AccountingAPIService) GetBankTransactionsExecute(r ApiGetBankTransactionsRequest) (*BankTransactions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BankTransactions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetBankTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BankTransactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBankTransactionsHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	bankTransactionID string
}

// Xero identifier for Tenant
func (r ApiGetBankTransactionsHistoryRequest) XeroTenantId(xeroTenantId string) ApiGetBankTransactionsHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetBankTransactionsHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.GetBankTransactionsHistoryExecute(r)
}

/*
GetBankTransactionsHistory Retrieves history from a specific bank transaction using a unique bank transaction Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bankTransactionID Xero generated unique identifier for a bank transaction
 @return ApiGetBankTransactionsHistoryRequest
*/
func (a *AccountingAPIService) GetBankTransactionsHistory(ctx context.Context, bankTransactionID string) ApiGetBankTransactionsHistoryRequest {
	return ApiGetBankTransactionsHistoryRequest{
		ApiService: a,
		ctx: ctx,
		bankTransactionID: bankTransactionID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) GetBankTransactionsHistoryExecute(r ApiGetBankTransactionsHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetBankTransactionsHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BankTransactions/{BankTransactionID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"BankTransactionID"+"}", url.PathEscape(parameterValueToString(r.bankTransactionID, "bankTransactionID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBankTransferRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	bankTransferID string
}

// Xero identifier for Tenant
func (r ApiGetBankTransferRequest) XeroTenantId(xeroTenantId string) ApiGetBankTransferRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetBankTransferRequest) Execute() (*BankTransfers, *http.Response, error) {
	return r.ApiService.GetBankTransferExecute(r)
}

/*
GetBankTransfer Retrieves specific bank transfers by using a unique bank transfer Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bankTransferID Xero generated unique identifier for a bank transfer
 @return ApiGetBankTransferRequest
*/
func (a *AccountingAPIService) GetBankTransfer(ctx context.Context, bankTransferID string) ApiGetBankTransferRequest {
	return ApiGetBankTransferRequest{
		ApiService: a,
		ctx: ctx,
		bankTransferID: bankTransferID,
	}
}

// Execute executes the request
//  @return BankTransfers
func (a *AccountingAPIService) GetBankTransferExecute(r ApiGetBankTransferRequest) (*BankTransfers, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BankTransfers
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetBankTransfer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BankTransfers/{BankTransferID}"
	localVarPath = strings.Replace(localVarPath, "{"+"BankTransferID"+"}", url.PathEscape(parameterValueToString(r.bankTransferID, "bankTransferID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBankTransferAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	bankTransferID string
	fileName string
	contentType *string
}

// Xero identifier for Tenant
func (r ApiGetBankTransferAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiGetBankTransferAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
func (r ApiGetBankTransferAttachmentByFileNameRequest) ContentType(contentType string) ApiGetBankTransferAttachmentByFileNameRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetBankTransferAttachmentByFileNameRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetBankTransferAttachmentByFileNameExecute(r)
}

/*
GetBankTransferAttachmentByFileName Retrieves a specific attachment on a specific bank transfer by file name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bankTransferID Xero generated unique identifier for a bank transfer
 @param fileName Name of the attachment
 @return ApiGetBankTransferAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) GetBankTransferAttachmentByFileName(ctx context.Context, bankTransferID string, fileName string) ApiGetBankTransferAttachmentByFileNameRequest {
	return ApiGetBankTransferAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		bankTransferID: bankTransferID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetBankTransferAttachmentByFileNameExecute(r ApiGetBankTransferAttachmentByFileNameRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetBankTransferAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BankTransfers/{BankTransferID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"BankTransferID"+"}", url.PathEscape(parameterValueToString(r.bankTransferID, "bankTransferID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "contentType", r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBankTransferAttachmentByIdRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	bankTransferID string
	attachmentID string
	contentType *string
}

// Xero identifier for Tenant
func (r ApiGetBankTransferAttachmentByIdRequest) XeroTenantId(xeroTenantId string) ApiGetBankTransferAttachmentByIdRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
func (r ApiGetBankTransferAttachmentByIdRequest) ContentType(contentType string) ApiGetBankTransferAttachmentByIdRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetBankTransferAttachmentByIdRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetBankTransferAttachmentByIdExecute(r)
}

/*
GetBankTransferAttachmentById Retrieves a specific attachment from a specific bank transfer using a unique attachment ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bankTransferID Xero generated unique identifier for a bank transfer
 @param attachmentID Unique identifier for Attachment object
 @return ApiGetBankTransferAttachmentByIdRequest
*/
func (a *AccountingAPIService) GetBankTransferAttachmentById(ctx context.Context, bankTransferID string, attachmentID string) ApiGetBankTransferAttachmentByIdRequest {
	return ApiGetBankTransferAttachmentByIdRequest{
		ApiService: a,
		ctx: ctx,
		bankTransferID: bankTransferID,
		attachmentID: attachmentID,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetBankTransferAttachmentByIdExecute(r ApiGetBankTransferAttachmentByIdRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetBankTransferAttachmentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BankTransfers/{BankTransferID}/Attachments/{AttachmentID}"
	localVarPath = strings.Replace(localVarPath, "{"+"BankTransferID"+"}", url.PathEscape(parameterValueToString(r.bankTransferID, "bankTransferID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"AttachmentID"+"}", url.PathEscape(parameterValueToString(r.attachmentID, "attachmentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "contentType", r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBankTransferAttachmentsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	bankTransferID string
}

// Xero identifier for Tenant
func (r ApiGetBankTransferAttachmentsRequest) XeroTenantId(xeroTenantId string) ApiGetBankTransferAttachmentsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetBankTransferAttachmentsRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.GetBankTransferAttachmentsExecute(r)
}

/*
GetBankTransferAttachments Retrieves attachments from a specific bank transfer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bankTransferID Xero generated unique identifier for a bank transfer
 @return ApiGetBankTransferAttachmentsRequest
*/
func (a *AccountingAPIService) GetBankTransferAttachments(ctx context.Context, bankTransferID string) ApiGetBankTransferAttachmentsRequest {
	return ApiGetBankTransferAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		bankTransferID: bankTransferID,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) GetBankTransferAttachmentsExecute(r ApiGetBankTransferAttachmentsRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetBankTransferAttachments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BankTransfers/{BankTransferID}/Attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"BankTransferID"+"}", url.PathEscape(parameterValueToString(r.bankTransferID, "bankTransferID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBankTransferHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	bankTransferID string
}

// Xero identifier for Tenant
func (r ApiGetBankTransferHistoryRequest) XeroTenantId(xeroTenantId string) ApiGetBankTransferHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetBankTransferHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.GetBankTransferHistoryExecute(r)
}

/*
GetBankTransferHistory Retrieves history from a specific bank transfer using a unique bank transfer Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bankTransferID Xero generated unique identifier for a bank transfer
 @return ApiGetBankTransferHistoryRequest
*/
func (a *AccountingAPIService) GetBankTransferHistory(ctx context.Context, bankTransferID string) ApiGetBankTransferHistoryRequest {
	return ApiGetBankTransferHistoryRequest{
		ApiService: a,
		ctx: ctx,
		bankTransferID: bankTransferID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) GetBankTransferHistoryExecute(r ApiGetBankTransferHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetBankTransferHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BankTransfers/{BankTransferID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"BankTransferID"+"}", url.PathEscape(parameterValueToString(r.bankTransferID, "bankTransferID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBankTransfersRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	ifModifiedSince *time.Time
	where *string
	order *string
}

// Xero identifier for Tenant
func (r ApiGetBankTransfersRequest) XeroTenantId(xeroTenantId string) ApiGetBankTransfersRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Only records created or modified since this timestamp will be returned
func (r ApiGetBankTransfersRequest) IfModifiedSince(ifModifiedSince time.Time) ApiGetBankTransfersRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

// Filter by an any element
func (r ApiGetBankTransfersRequest) Where(where string) ApiGetBankTransfersRequest {
	r.where = &where
	return r
}

// Order by an any element
func (r ApiGetBankTransfersRequest) Order(order string) ApiGetBankTransfersRequest {
	r.order = &order
	return r
}

func (r ApiGetBankTransfersRequest) Execute() (*BankTransfers, *http.Response, error) {
	return r.ApiService.GetBankTransfersExecute(r)
}

/*
GetBankTransfers Retrieves all bank transfers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBankTransfersRequest
*/
func (a *AccountingAPIService) GetBankTransfers(ctx context.Context) ApiGetBankTransfersRequest {
	return ApiGetBankTransfersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BankTransfers
func (a *AccountingAPIService) GetBankTransfersExecute(r ApiGetBankTransfersRequest) (*BankTransfers, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BankTransfers
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetBankTransfers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BankTransfers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBatchPaymentRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	batchPaymentID string
}

// Xero identifier for Tenant
func (r ApiGetBatchPaymentRequest) XeroTenantId(xeroTenantId string) ApiGetBatchPaymentRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetBatchPaymentRequest) Execute() (*BatchPayments, *http.Response, error) {
	return r.ApiService.GetBatchPaymentExecute(r)
}

/*
GetBatchPayment Retrieves a specific batch payment using a unique batch payment Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchPaymentID Unique identifier for BatchPayment
 @return ApiGetBatchPaymentRequest
*/
func (a *AccountingAPIService) GetBatchPayment(ctx context.Context, batchPaymentID string) ApiGetBatchPaymentRequest {
	return ApiGetBatchPaymentRequest{
		ApiService: a,
		ctx: ctx,
		batchPaymentID: batchPaymentID,
	}
}

// Execute executes the request
//  @return BatchPayments
func (a *AccountingAPIService) GetBatchPaymentExecute(r ApiGetBatchPaymentRequest) (*BatchPayments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchPayments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetBatchPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BatchPayments/{BatchPaymentID}"
	localVarPath = strings.Replace(localVarPath, "{"+"BatchPaymentID"+"}", url.PathEscape(parameterValueToString(r.batchPaymentID, "batchPaymentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBatchPaymentHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	batchPaymentID string
}

// Xero identifier for Tenant
func (r ApiGetBatchPaymentHistoryRequest) XeroTenantId(xeroTenantId string) ApiGetBatchPaymentHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetBatchPaymentHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.GetBatchPaymentHistoryExecute(r)
}

/*
GetBatchPaymentHistory Retrieves history from a specific batch payment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchPaymentID Unique identifier for BatchPayment
 @return ApiGetBatchPaymentHistoryRequest
*/
func (a *AccountingAPIService) GetBatchPaymentHistory(ctx context.Context, batchPaymentID string) ApiGetBatchPaymentHistoryRequest {
	return ApiGetBatchPaymentHistoryRequest{
		ApiService: a,
		ctx: ctx,
		batchPaymentID: batchPaymentID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) GetBatchPaymentHistoryExecute(r ApiGetBatchPaymentHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetBatchPaymentHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BatchPayments/{BatchPaymentID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"BatchPaymentID"+"}", url.PathEscape(parameterValueToString(r.batchPaymentID, "batchPaymentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBatchPaymentsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	ifModifiedSince *time.Time
	where *string
	order *string
}

// Xero identifier for Tenant
func (r ApiGetBatchPaymentsRequest) XeroTenantId(xeroTenantId string) ApiGetBatchPaymentsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Only records created or modified since this timestamp will be returned
func (r ApiGetBatchPaymentsRequest) IfModifiedSince(ifModifiedSince time.Time) ApiGetBatchPaymentsRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

// Filter by an any element
func (r ApiGetBatchPaymentsRequest) Where(where string) ApiGetBatchPaymentsRequest {
	r.where = &where
	return r
}

// Order by an any element
func (r ApiGetBatchPaymentsRequest) Order(order string) ApiGetBatchPaymentsRequest {
	r.order = &order
	return r
}

func (r ApiGetBatchPaymentsRequest) Execute() (*BatchPayments, *http.Response, error) {
	return r.ApiService.GetBatchPaymentsExecute(r)
}

/*
GetBatchPayments Retrieves either one or many batch payments for invoices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBatchPaymentsRequest
*/
func (a *AccountingAPIService) GetBatchPayments(ctx context.Context) ApiGetBatchPaymentsRequest {
	return ApiGetBatchPaymentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchPayments
func (a *AccountingAPIService) GetBatchPaymentsExecute(r ApiGetBatchPaymentsRequest) (*BatchPayments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchPayments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetBatchPayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BatchPayments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBrandingThemeRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	brandingThemeID string
}

// Xero identifier for Tenant
func (r ApiGetBrandingThemeRequest) XeroTenantId(xeroTenantId string) ApiGetBrandingThemeRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetBrandingThemeRequest) Execute() (*BrandingThemes, *http.Response, error) {
	return r.ApiService.GetBrandingThemeExecute(r)
}

/*
GetBrandingTheme Retrieves a specific branding theme using a unique branding theme Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param brandingThemeID Unique identifier for a Branding Theme
 @return ApiGetBrandingThemeRequest
*/
func (a *AccountingAPIService) GetBrandingTheme(ctx context.Context, brandingThemeID string) ApiGetBrandingThemeRequest {
	return ApiGetBrandingThemeRequest{
		ApiService: a,
		ctx: ctx,
		brandingThemeID: brandingThemeID,
	}
}

// Execute executes the request
//  @return BrandingThemes
func (a *AccountingAPIService) GetBrandingThemeExecute(r ApiGetBrandingThemeRequest) (*BrandingThemes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BrandingThemes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetBrandingTheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BrandingThemes/{BrandingThemeID}"
	localVarPath = strings.Replace(localVarPath, "{"+"BrandingThemeID"+"}", url.PathEscape(parameterValueToString(r.brandingThemeID, "brandingThemeID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBrandingThemePaymentServicesRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	brandingThemeID string
}

// Xero identifier for Tenant
func (r ApiGetBrandingThemePaymentServicesRequest) XeroTenantId(xeroTenantId string) ApiGetBrandingThemePaymentServicesRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetBrandingThemePaymentServicesRequest) Execute() (*PaymentServices, *http.Response, error) {
	return r.ApiService.GetBrandingThemePaymentServicesExecute(r)
}

/*
GetBrandingThemePaymentServices Retrieves the payment services for a specific branding theme

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param brandingThemeID Unique identifier for a Branding Theme
 @return ApiGetBrandingThemePaymentServicesRequest
*/
func (a *AccountingAPIService) GetBrandingThemePaymentServices(ctx context.Context, brandingThemeID string) ApiGetBrandingThemePaymentServicesRequest {
	return ApiGetBrandingThemePaymentServicesRequest{
		ApiService: a,
		ctx: ctx,
		brandingThemeID: brandingThemeID,
	}
}

// Execute executes the request
//  @return PaymentServices
func (a *AccountingAPIService) GetBrandingThemePaymentServicesExecute(r ApiGetBrandingThemePaymentServicesRequest) (*PaymentServices, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentServices
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetBrandingThemePaymentServices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BrandingThemes/{BrandingThemeID}/PaymentServices"
	localVarPath = strings.Replace(localVarPath, "{"+"BrandingThemeID"+"}", url.PathEscape(parameterValueToString(r.brandingThemeID, "brandingThemeID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBrandingThemesRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
}

// Xero identifier for Tenant
func (r ApiGetBrandingThemesRequest) XeroTenantId(xeroTenantId string) ApiGetBrandingThemesRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetBrandingThemesRequest) Execute() (*BrandingThemes, *http.Response, error) {
	return r.ApiService.GetBrandingThemesExecute(r)
}

/*
GetBrandingThemes Retrieves all the branding themes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBrandingThemesRequest
*/
func (a *AccountingAPIService) GetBrandingThemes(ctx context.Context) ApiGetBrandingThemesRequest {
	return ApiGetBrandingThemesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BrandingThemes
func (a *AccountingAPIService) GetBrandingThemesExecute(r ApiGetBrandingThemesRequest) (*BrandingThemes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BrandingThemes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetBrandingThemes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BrandingThemes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBudgetRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	budgetID string
	dateTo *string
	dateFrom *string
}

// Xero identifier for Tenant
func (r ApiGetBudgetRequest) XeroTenantId(xeroTenantId string) ApiGetBudgetRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Filter by start date
func (r ApiGetBudgetRequest) DateTo(dateTo string) ApiGetBudgetRequest {
	r.dateTo = &dateTo
	return r
}

// Filter by end date
func (r ApiGetBudgetRequest) DateFrom(dateFrom string) ApiGetBudgetRequest {
	r.dateFrom = &dateFrom
	return r
}

func (r ApiGetBudgetRequest) Execute() (*Budgets, *http.Response, error) {
	return r.ApiService.GetBudgetExecute(r)
}

/*
GetBudget Retrieves a specific budget, which includes budget lines

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param budgetID Unique identifier for Budgets
 @return ApiGetBudgetRequest
*/
func (a *AccountingAPIService) GetBudget(ctx context.Context, budgetID string) ApiGetBudgetRequest {
	return ApiGetBudgetRequest{
		ApiService: a,
		ctx: ctx,
		budgetID: budgetID,
	}
}

// Execute executes the request
//  @return Budgets
func (a *AccountingAPIService) GetBudgetExecute(r ApiGetBudgetRequest) (*Budgets, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Budgets
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetBudget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Budgets/{BudgetID}"
	localVarPath = strings.Replace(localVarPath, "{"+"BudgetID"+"}", url.PathEscape(parameterValueToString(r.budgetID, "budgetID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "DateTo", r.dateTo, "")
	}
	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "DateFrom", r.dateFrom, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBudgetsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	iDs *[]string
	dateTo *string
	dateFrom *string
}

// Xero identifier for Tenant
func (r ApiGetBudgetsRequest) XeroTenantId(xeroTenantId string) ApiGetBudgetsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Filter by BudgetID. Allows you to retrieve a specific individual budget.
func (r ApiGetBudgetsRequest) IDs(iDs []string) ApiGetBudgetsRequest {
	r.iDs = &iDs
	return r
}

// Filter by start date
func (r ApiGetBudgetsRequest) DateTo(dateTo string) ApiGetBudgetsRequest {
	r.dateTo = &dateTo
	return r
}

// Filter by end date
func (r ApiGetBudgetsRequest) DateFrom(dateFrom string) ApiGetBudgetsRequest {
	r.dateFrom = &dateFrom
	return r
}

func (r ApiGetBudgetsRequest) Execute() (*Budgets, *http.Response, error) {
	return r.ApiService.GetBudgetsExecute(r)
}

/*
GetBudgets Retrieve a list of budgets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBudgetsRequest
*/
func (a *AccountingAPIService) GetBudgets(ctx context.Context) ApiGetBudgetsRequest {
	return ApiGetBudgetsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Budgets
func (a *AccountingAPIService) GetBudgetsExecute(r ApiGetBudgetsRequest) (*Budgets, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Budgets
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetBudgets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Budgets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.iDs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IDs", r.iDs, "csv")
	}
	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "DateTo", r.dateTo, "")
	}
	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "DateFrom", r.dateFrom, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContactRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	contactID string
}

// Xero identifier for Tenant
func (r ApiGetContactRequest) XeroTenantId(xeroTenantId string) ApiGetContactRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetContactRequest) Execute() (*Contacts, *http.Response, error) {
	return r.ApiService.GetContactExecute(r)
}

/*
GetContact Retrieves a specific contacts in a Xero organisation using a unique contact Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactID Unique identifier for a Contact
 @return ApiGetContactRequest
*/
func (a *AccountingAPIService) GetContact(ctx context.Context, contactID string) ApiGetContactRequest {
	return ApiGetContactRequest{
		ApiService: a,
		ctx: ctx,
		contactID: contactID,
	}
}

// Execute executes the request
//  @return Contacts
func (a *AccountingAPIService) GetContactExecute(r ApiGetContactRequest) (*Contacts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Contacts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetContact")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Contacts/{ContactID}"
	localVarPath = strings.Replace(localVarPath, "{"+"ContactID"+"}", url.PathEscape(parameterValueToString(r.contactID, "contactID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContactAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	contactID string
	fileName string
	contentType *string
}

// Xero identifier for Tenant
func (r ApiGetContactAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiGetContactAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
func (r ApiGetContactAttachmentByFileNameRequest) ContentType(contentType string) ApiGetContactAttachmentByFileNameRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetContactAttachmentByFileNameRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetContactAttachmentByFileNameExecute(r)
}

/*
GetContactAttachmentByFileName Retrieves a specific attachment from a specific contact by file name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactID Unique identifier for a Contact
 @param fileName Name of the attachment
 @return ApiGetContactAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) GetContactAttachmentByFileName(ctx context.Context, contactID string, fileName string) ApiGetContactAttachmentByFileNameRequest {
	return ApiGetContactAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		contactID: contactID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetContactAttachmentByFileNameExecute(r ApiGetContactAttachmentByFileNameRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetContactAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Contacts/{ContactID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"ContactID"+"}", url.PathEscape(parameterValueToString(r.contactID, "contactID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "contentType", r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContactAttachmentByIdRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	contactID string
	attachmentID string
	contentType *string
}

// Xero identifier for Tenant
func (r ApiGetContactAttachmentByIdRequest) XeroTenantId(xeroTenantId string) ApiGetContactAttachmentByIdRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
func (r ApiGetContactAttachmentByIdRequest) ContentType(contentType string) ApiGetContactAttachmentByIdRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetContactAttachmentByIdRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetContactAttachmentByIdExecute(r)
}

/*
GetContactAttachmentById Retrieves a specific attachment from a specific contact using a unique attachment Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactID Unique identifier for a Contact
 @param attachmentID Unique identifier for Attachment object
 @return ApiGetContactAttachmentByIdRequest
*/
func (a *AccountingAPIService) GetContactAttachmentById(ctx context.Context, contactID string, attachmentID string) ApiGetContactAttachmentByIdRequest {
	return ApiGetContactAttachmentByIdRequest{
		ApiService: a,
		ctx: ctx,
		contactID: contactID,
		attachmentID: attachmentID,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetContactAttachmentByIdExecute(r ApiGetContactAttachmentByIdRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetContactAttachmentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Contacts/{ContactID}/Attachments/{AttachmentID}"
	localVarPath = strings.Replace(localVarPath, "{"+"ContactID"+"}", url.PathEscape(parameterValueToString(r.contactID, "contactID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"AttachmentID"+"}", url.PathEscape(parameterValueToString(r.attachmentID, "attachmentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "contentType", r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContactAttachmentsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	contactID string
}

// Xero identifier for Tenant
func (r ApiGetContactAttachmentsRequest) XeroTenantId(xeroTenantId string) ApiGetContactAttachmentsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetContactAttachmentsRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.GetContactAttachmentsExecute(r)
}

/*
GetContactAttachments Retrieves attachments for a specific contact in a Xero organisation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactID Unique identifier for a Contact
 @return ApiGetContactAttachmentsRequest
*/
func (a *AccountingAPIService) GetContactAttachments(ctx context.Context, contactID string) ApiGetContactAttachmentsRequest {
	return ApiGetContactAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		contactID: contactID,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) GetContactAttachmentsExecute(r ApiGetContactAttachmentsRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetContactAttachments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Contacts/{ContactID}/Attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"ContactID"+"}", url.PathEscape(parameterValueToString(r.contactID, "contactID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContactByContactNumberRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	contactNumber string
}

// Xero identifier for Tenant
func (r ApiGetContactByContactNumberRequest) XeroTenantId(xeroTenantId string) ApiGetContactByContactNumberRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetContactByContactNumberRequest) Execute() (*Contacts, *http.Response, error) {
	return r.ApiService.GetContactByContactNumberExecute(r)
}

/*
GetContactByContactNumber Retrieves a specific contact by contact number in a Xero organisation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactNumber This field is read only on the Xero contact screen, used to identify contacts in external systems (max length = 50).
 @return ApiGetContactByContactNumberRequest
*/
func (a *AccountingAPIService) GetContactByContactNumber(ctx context.Context, contactNumber string) ApiGetContactByContactNumberRequest {
	return ApiGetContactByContactNumberRequest{
		ApiService: a,
		ctx: ctx,
		contactNumber: contactNumber,
	}
}

// Execute executes the request
//  @return Contacts
func (a *AccountingAPIService) GetContactByContactNumberExecute(r ApiGetContactByContactNumberRequest) (*Contacts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Contacts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetContactByContactNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Contacts/{ContactNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"ContactNumber"+"}", url.PathEscape(parameterValueToString(r.contactNumber, "contactNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContactCISSettingsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	contactID string
}

// Xero identifier for Tenant
func (r ApiGetContactCISSettingsRequest) XeroTenantId(xeroTenantId string) ApiGetContactCISSettingsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetContactCISSettingsRequest) Execute() (*CISSettings, *http.Response, error) {
	return r.ApiService.GetContactCISSettingsExecute(r)
}

/*
GetContactCISSettings Retrieves CIS settings for a specific contact in a Xero organisation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactID Unique identifier for a Contact
 @return ApiGetContactCISSettingsRequest
*/
func (a *AccountingAPIService) GetContactCISSettings(ctx context.Context, contactID string) ApiGetContactCISSettingsRequest {
	return ApiGetContactCISSettingsRequest{
		ApiService: a,
		ctx: ctx,
		contactID: contactID,
	}
}

// Execute executes the request
//  @return CISSettings
func (a *AccountingAPIService) GetContactCISSettingsExecute(r ApiGetContactCISSettingsRequest) (*CISSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CISSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetContactCISSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Contacts/{ContactID}/CISSettings"
	localVarPath = strings.Replace(localVarPath, "{"+"ContactID"+"}", url.PathEscape(parameterValueToString(r.contactID, "contactID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContactGroupRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	contactGroupID string
}

// Xero identifier for Tenant
func (r ApiGetContactGroupRequest) XeroTenantId(xeroTenantId string) ApiGetContactGroupRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetContactGroupRequest) Execute() (*ContactGroups, *http.Response, error) {
	return r.ApiService.GetContactGroupExecute(r)
}

/*
GetContactGroup Retrieves a specific contact group by using a unique contact group Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactGroupID Unique identifier for a Contact Group
 @return ApiGetContactGroupRequest
*/
func (a *AccountingAPIService) GetContactGroup(ctx context.Context, contactGroupID string) ApiGetContactGroupRequest {
	return ApiGetContactGroupRequest{
		ApiService: a,
		ctx: ctx,
		contactGroupID: contactGroupID,
	}
}

// Execute executes the request
//  @return ContactGroups
func (a *AccountingAPIService) GetContactGroupExecute(r ApiGetContactGroupRequest) (*ContactGroups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContactGroups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetContactGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ContactGroups/{ContactGroupID}"
	localVarPath = strings.Replace(localVarPath, "{"+"ContactGroupID"+"}", url.PathEscape(parameterValueToString(r.contactGroupID, "contactGroupID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContactGroupsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	where *string
	order *string
}

// Xero identifier for Tenant
func (r ApiGetContactGroupsRequest) XeroTenantId(xeroTenantId string) ApiGetContactGroupsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Filter by an any element
func (r ApiGetContactGroupsRequest) Where(where string) ApiGetContactGroupsRequest {
	r.where = &where
	return r
}

// Order by an any element
func (r ApiGetContactGroupsRequest) Order(order string) ApiGetContactGroupsRequest {
	r.order = &order
	return r
}

func (r ApiGetContactGroupsRequest) Execute() (*ContactGroups, *http.Response, error) {
	return r.ApiService.GetContactGroupsExecute(r)
}

/*
GetContactGroups Retrieves the contact Id and name of each contact group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetContactGroupsRequest
*/
func (a *AccountingAPIService) GetContactGroups(ctx context.Context) ApiGetContactGroupsRequest {
	return ApiGetContactGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ContactGroups
func (a *AccountingAPIService) GetContactGroupsExecute(r ApiGetContactGroupsRequest) (*ContactGroups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContactGroups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetContactGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ContactGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContactHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	contactID string
}

// Xero identifier for Tenant
func (r ApiGetContactHistoryRequest) XeroTenantId(xeroTenantId string) ApiGetContactHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetContactHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.GetContactHistoryExecute(r)
}

/*
GetContactHistory Retrieves history records for a specific contact

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactID Unique identifier for a Contact
 @return ApiGetContactHistoryRequest
*/
func (a *AccountingAPIService) GetContactHistory(ctx context.Context, contactID string) ApiGetContactHistoryRequest {
	return ApiGetContactHistoryRequest{
		ApiService: a,
		ctx: ctx,
		contactID: contactID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) GetContactHistoryExecute(r ApiGetContactHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetContactHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Contacts/{ContactID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"ContactID"+"}", url.PathEscape(parameterValueToString(r.contactID, "contactID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContactsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	ifModifiedSince *time.Time
	where *string
	order *string
	iDs *[]string
	page *int32
	includeArchived *bool
	summaryOnly *bool
	searchTerm *string
}

// Xero identifier for Tenant
func (r ApiGetContactsRequest) XeroTenantId(xeroTenantId string) ApiGetContactsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Only records created or modified since this timestamp will be returned
func (r ApiGetContactsRequest) IfModifiedSince(ifModifiedSince time.Time) ApiGetContactsRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

// Filter by an any element
func (r ApiGetContactsRequest) Where(where string) ApiGetContactsRequest {
	r.where = &where
	return r
}

// Order by an any element
func (r ApiGetContactsRequest) Order(order string) ApiGetContactsRequest {
	r.order = &order
	return r
}

// Filter by a comma separated list of ContactIDs. Allows you to retrieve a specific set of contacts in a single call.
func (r ApiGetContactsRequest) IDs(iDs []string) ApiGetContactsRequest {
	r.iDs = &iDs
	return r
}

// e.g. page&#x3D;1 - Up to 100 contacts will be returned in a single API call.
func (r ApiGetContactsRequest) Page(page int32) ApiGetContactsRequest {
	r.page = &page
	return r
}

// e.g. includeArchived&#x3D;true - Contacts with a status of ARCHIVED will be included in the response
func (r ApiGetContactsRequest) IncludeArchived(includeArchived bool) ApiGetContactsRequest {
	r.includeArchived = &includeArchived
	return r
}

// Use summaryOnly&#x3D;true in GET Contacts and Invoices endpoint to retrieve a smaller version of the response object. This returns only lightweight fields, excluding computation-heavy fields from the response, making the API calls quick and efficient.
func (r ApiGetContactsRequest) SummaryOnly(summaryOnly bool) ApiGetContactsRequest {
	r.summaryOnly = &summaryOnly
	return r
}

// Search parameter that performs a case-insensitive text search across the Name, FirstName, LastName, ContactNumber and EmailAddress fields.
func (r ApiGetContactsRequest) SearchTerm(searchTerm string) ApiGetContactsRequest {
	r.searchTerm = &searchTerm
	return r
}

func (r ApiGetContactsRequest) Execute() (*Contacts, *http.Response, error) {
	return r.ApiService.GetContactsExecute(r)
}

/*
GetContacts Retrieves all contacts in a Xero organisation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetContactsRequest
*/
func (a *AccountingAPIService) GetContacts(ctx context.Context) ApiGetContactsRequest {
	return ApiGetContactsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Contacts
func (a *AccountingAPIService) GetContactsExecute(r ApiGetContactsRequest) (*Contacts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Contacts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetContacts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Contacts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.iDs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IDs", r.iDs, "csv")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.includeArchived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeArchived", r.includeArchived, "")
	}
	if r.summaryOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summaryOnly", r.summaryOnly, "")
	}
	if r.searchTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchTerm", r.searchTerm, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCreditNoteRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	creditNoteID string
	unitdp *int32
}

// Xero identifier for Tenant
func (r ApiGetCreditNoteRequest) XeroTenantId(xeroTenantId string) ApiGetCreditNoteRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiGetCreditNoteRequest) Unitdp(unitdp int32) ApiGetCreditNoteRequest {
	r.unitdp = &unitdp
	return r
}

func (r ApiGetCreditNoteRequest) Execute() (*CreditNotes, *http.Response, error) {
	return r.ApiService.GetCreditNoteExecute(r)
}

/*
GetCreditNote Retrieves a specific credit note using a unique credit note Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param creditNoteID Unique identifier for a Credit Note
 @return ApiGetCreditNoteRequest
*/
func (a *AccountingAPIService) GetCreditNote(ctx context.Context, creditNoteID string) ApiGetCreditNoteRequest {
	return ApiGetCreditNoteRequest{
		ApiService: a,
		ctx: ctx,
		creditNoteID: creditNoteID,
	}
}

// Execute executes the request
//  @return CreditNotes
func (a *AccountingAPIService) GetCreditNoteExecute(r ApiGetCreditNoteRequest) (*CreditNotes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreditNotes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetCreditNote")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CreditNotes/{CreditNoteID}"
	localVarPath = strings.Replace(localVarPath, "{"+"CreditNoteID"+"}", url.PathEscape(parameterValueToString(r.creditNoteID, "creditNoteID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCreditNoteAsPdfRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	creditNoteID string
}

// Xero identifier for Tenant
func (r ApiGetCreditNoteAsPdfRequest) XeroTenantId(xeroTenantId string) ApiGetCreditNoteAsPdfRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetCreditNoteAsPdfRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetCreditNoteAsPdfExecute(r)
}

/*
GetCreditNoteAsPdf Retrieves credit notes as PDF files

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param creditNoteID Unique identifier for a Credit Note
 @return ApiGetCreditNoteAsPdfRequest
*/
func (a *AccountingAPIService) GetCreditNoteAsPdf(ctx context.Context, creditNoteID string) ApiGetCreditNoteAsPdfRequest {
	return ApiGetCreditNoteAsPdfRequest{
		ApiService: a,
		ctx: ctx,
		creditNoteID: creditNoteID,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetCreditNoteAsPdfExecute(r ApiGetCreditNoteAsPdfRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetCreditNoteAsPdf")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CreditNotes/{CreditNoteID}/pdf"
	localVarPath = strings.Replace(localVarPath, "{"+"CreditNoteID"+"}", url.PathEscape(parameterValueToString(r.creditNoteID, "creditNoteID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/pdf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCreditNoteAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	creditNoteID string
	fileName string
	contentType *string
}

// Xero identifier for Tenant
func (r ApiGetCreditNoteAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiGetCreditNoteAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
func (r ApiGetCreditNoteAttachmentByFileNameRequest) ContentType(contentType string) ApiGetCreditNoteAttachmentByFileNameRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetCreditNoteAttachmentByFileNameRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetCreditNoteAttachmentByFileNameExecute(r)
}

/*
GetCreditNoteAttachmentByFileName Retrieves a specific attachment on a specific credit note by file name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param creditNoteID Unique identifier for a Credit Note
 @param fileName Name of the attachment
 @return ApiGetCreditNoteAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) GetCreditNoteAttachmentByFileName(ctx context.Context, creditNoteID string, fileName string) ApiGetCreditNoteAttachmentByFileNameRequest {
	return ApiGetCreditNoteAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		creditNoteID: creditNoteID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetCreditNoteAttachmentByFileNameExecute(r ApiGetCreditNoteAttachmentByFileNameRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetCreditNoteAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CreditNotes/{CreditNoteID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"CreditNoteID"+"}", url.PathEscape(parameterValueToString(r.creditNoteID, "creditNoteID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "contentType", r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCreditNoteAttachmentByIdRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	creditNoteID string
	attachmentID string
	contentType *string
}

// Xero identifier for Tenant
func (r ApiGetCreditNoteAttachmentByIdRequest) XeroTenantId(xeroTenantId string) ApiGetCreditNoteAttachmentByIdRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
func (r ApiGetCreditNoteAttachmentByIdRequest) ContentType(contentType string) ApiGetCreditNoteAttachmentByIdRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetCreditNoteAttachmentByIdRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetCreditNoteAttachmentByIdExecute(r)
}

/*
GetCreditNoteAttachmentById Retrieves a specific attachment from a specific credit note using a unique attachment Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param creditNoteID Unique identifier for a Credit Note
 @param attachmentID Unique identifier for Attachment object
 @return ApiGetCreditNoteAttachmentByIdRequest
*/
func (a *AccountingAPIService) GetCreditNoteAttachmentById(ctx context.Context, creditNoteID string, attachmentID string) ApiGetCreditNoteAttachmentByIdRequest {
	return ApiGetCreditNoteAttachmentByIdRequest{
		ApiService: a,
		ctx: ctx,
		creditNoteID: creditNoteID,
		attachmentID: attachmentID,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetCreditNoteAttachmentByIdExecute(r ApiGetCreditNoteAttachmentByIdRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetCreditNoteAttachmentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CreditNotes/{CreditNoteID}/Attachments/{AttachmentID}"
	localVarPath = strings.Replace(localVarPath, "{"+"CreditNoteID"+"}", url.PathEscape(parameterValueToString(r.creditNoteID, "creditNoteID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"AttachmentID"+"}", url.PathEscape(parameterValueToString(r.attachmentID, "attachmentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "contentType", r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCreditNoteAttachmentsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	creditNoteID string
}

// Xero identifier for Tenant
func (r ApiGetCreditNoteAttachmentsRequest) XeroTenantId(xeroTenantId string) ApiGetCreditNoteAttachmentsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetCreditNoteAttachmentsRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.GetCreditNoteAttachmentsExecute(r)
}

/*
GetCreditNoteAttachments Retrieves attachments for a specific credit notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param creditNoteID Unique identifier for a Credit Note
 @return ApiGetCreditNoteAttachmentsRequest
*/
func (a *AccountingAPIService) GetCreditNoteAttachments(ctx context.Context, creditNoteID string) ApiGetCreditNoteAttachmentsRequest {
	return ApiGetCreditNoteAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		creditNoteID: creditNoteID,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) GetCreditNoteAttachmentsExecute(r ApiGetCreditNoteAttachmentsRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetCreditNoteAttachments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CreditNotes/{CreditNoteID}/Attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"CreditNoteID"+"}", url.PathEscape(parameterValueToString(r.creditNoteID, "creditNoteID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCreditNoteHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	creditNoteID string
}

// Xero identifier for Tenant
func (r ApiGetCreditNoteHistoryRequest) XeroTenantId(xeroTenantId string) ApiGetCreditNoteHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetCreditNoteHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.GetCreditNoteHistoryExecute(r)
}

/*
GetCreditNoteHistory Retrieves history records of a specific credit note

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param creditNoteID Unique identifier for a Credit Note
 @return ApiGetCreditNoteHistoryRequest
*/
func (a *AccountingAPIService) GetCreditNoteHistory(ctx context.Context, creditNoteID string) ApiGetCreditNoteHistoryRequest {
	return ApiGetCreditNoteHistoryRequest{
		ApiService: a,
		ctx: ctx,
		creditNoteID: creditNoteID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) GetCreditNoteHistoryExecute(r ApiGetCreditNoteHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetCreditNoteHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CreditNotes/{CreditNoteID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"CreditNoteID"+"}", url.PathEscape(parameterValueToString(r.creditNoteID, "creditNoteID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCreditNotesRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	ifModifiedSince *time.Time
	where *string
	order *string
	page *int32
	unitdp *int32
}

// Xero identifier for Tenant
func (r ApiGetCreditNotesRequest) XeroTenantId(xeroTenantId string) ApiGetCreditNotesRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Only records created or modified since this timestamp will be returned
func (r ApiGetCreditNotesRequest) IfModifiedSince(ifModifiedSince time.Time) ApiGetCreditNotesRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

// Filter by an any element
func (r ApiGetCreditNotesRequest) Where(where string) ApiGetCreditNotesRequest {
	r.where = &where
	return r
}

// Order by an any element
func (r ApiGetCreditNotesRequest) Order(order string) ApiGetCreditNotesRequest {
	r.order = &order
	return r
}

// e.g. page&#x3D;1 â€“ Up to 100 credit notes will be returned in a single API call with line items shown for each credit note
func (r ApiGetCreditNotesRequest) Page(page int32) ApiGetCreditNotesRequest {
	r.page = &page
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiGetCreditNotesRequest) Unitdp(unitdp int32) ApiGetCreditNotesRequest {
	r.unitdp = &unitdp
	return r
}

func (r ApiGetCreditNotesRequest) Execute() (*CreditNotes, *http.Response, error) {
	return r.ApiService.GetCreditNotesExecute(r)
}

/*
GetCreditNotes Retrieves any credit notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCreditNotesRequest
*/
func (a *AccountingAPIService) GetCreditNotes(ctx context.Context) ApiGetCreditNotesRequest {
	return ApiGetCreditNotesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreditNotes
func (a *AccountingAPIService) GetCreditNotesExecute(r ApiGetCreditNotesRequest) (*CreditNotes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreditNotes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetCreditNotes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CreditNotes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrenciesRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	where *string
	order *string
}

// Xero identifier for Tenant
func (r ApiGetCurrenciesRequest) XeroTenantId(xeroTenantId string) ApiGetCurrenciesRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Filter by an any element
func (r ApiGetCurrenciesRequest) Where(where string) ApiGetCurrenciesRequest {
	r.where = &where
	return r
}

// Order by an any element
func (r ApiGetCurrenciesRequest) Order(order string) ApiGetCurrenciesRequest {
	r.order = &order
	return r
}

func (r ApiGetCurrenciesRequest) Execute() (*Currencies, *http.Response, error) {
	return r.ApiService.GetCurrenciesExecute(r)
}

/*
GetCurrencies Retrieves currencies for your Xero organisation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCurrenciesRequest
*/
func (a *AccountingAPIService) GetCurrencies(ctx context.Context) ApiGetCurrenciesRequest {
	return ApiGetCurrenciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Currencies
func (a *AccountingAPIService) GetCurrenciesExecute(r ApiGetCurrenciesRequest) (*Currencies, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Currencies
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetCurrencies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Currencies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEmployeeRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	employeeID string
}

// Xero identifier for Tenant
func (r ApiGetEmployeeRequest) XeroTenantId(xeroTenantId string) ApiGetEmployeeRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetEmployeeRequest) Execute() (*Employees, *http.Response, error) {
	return r.ApiService.GetEmployeeExecute(r)
}

/*
GetEmployee Retrieves a specific employee used in Xero payrun using a unique employee Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employeeID Unique identifier for a Employee
 @return ApiGetEmployeeRequest
*/
func (a *AccountingAPIService) GetEmployee(ctx context.Context, employeeID string) ApiGetEmployeeRequest {
	return ApiGetEmployeeRequest{
		ApiService: a,
		ctx: ctx,
		employeeID: employeeID,
	}
}

// Execute executes the request
//  @return Employees
func (a *AccountingAPIService) GetEmployeeExecute(r ApiGetEmployeeRequest) (*Employees, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Employees
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetEmployee")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Employees/{EmployeeID}"
	localVarPath = strings.Replace(localVarPath, "{"+"EmployeeID"+"}", url.PathEscape(parameterValueToString(r.employeeID, "employeeID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEmployeesRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	ifModifiedSince *time.Time
	where *string
	order *string
}

// Xero identifier for Tenant
func (r ApiGetEmployeesRequest) XeroTenantId(xeroTenantId string) ApiGetEmployeesRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Only records created or modified since this timestamp will be returned
func (r ApiGetEmployeesRequest) IfModifiedSince(ifModifiedSince time.Time) ApiGetEmployeesRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

// Filter by an any element
func (r ApiGetEmployeesRequest) Where(where string) ApiGetEmployeesRequest {
	r.where = &where
	return r
}

// Order by an any element
func (r ApiGetEmployeesRequest) Order(order string) ApiGetEmployeesRequest {
	r.order = &order
	return r
}

func (r ApiGetEmployeesRequest) Execute() (*Employees, *http.Response, error) {
	return r.ApiService.GetEmployeesExecute(r)
}

/*
GetEmployees Retrieves employees used in Xero payrun

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEmployeesRequest
*/
func (a *AccountingAPIService) GetEmployees(ctx context.Context) ApiGetEmployeesRequest {
	return ApiGetEmployeesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Employees
func (a *AccountingAPIService) GetEmployeesExecute(r ApiGetEmployeesRequest) (*Employees, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Employees
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetEmployees")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Employees"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExpenseClaimRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	expenseClaimID string
}

// Xero identifier for Tenant
func (r ApiGetExpenseClaimRequest) XeroTenantId(xeroTenantId string) ApiGetExpenseClaimRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetExpenseClaimRequest) Execute() (*ExpenseClaims, *http.Response, error) {
	return r.ApiService.GetExpenseClaimExecute(r)
}

/*
GetExpenseClaim Retrieves a specific expense claim using a unique expense claim Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param expenseClaimID Unique identifier for a ExpenseClaim
 @return ApiGetExpenseClaimRequest
*/
func (a *AccountingAPIService) GetExpenseClaim(ctx context.Context, expenseClaimID string) ApiGetExpenseClaimRequest {
	return ApiGetExpenseClaimRequest{
		ApiService: a,
		ctx: ctx,
		expenseClaimID: expenseClaimID,
	}
}

// Execute executes the request
//  @return ExpenseClaims
func (a *AccountingAPIService) GetExpenseClaimExecute(r ApiGetExpenseClaimRequest) (*ExpenseClaims, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExpenseClaims
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetExpenseClaim")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ExpenseClaims/{ExpenseClaimID}"
	localVarPath = strings.Replace(localVarPath, "{"+"ExpenseClaimID"+"}", url.PathEscape(parameterValueToString(r.expenseClaimID, "expenseClaimID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExpenseClaimHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	expenseClaimID string
}

// Xero identifier for Tenant
func (r ApiGetExpenseClaimHistoryRequest) XeroTenantId(xeroTenantId string) ApiGetExpenseClaimHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetExpenseClaimHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.GetExpenseClaimHistoryExecute(r)
}

/*
GetExpenseClaimHistory Retrieves history records of a specific expense claim

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param expenseClaimID Unique identifier for a ExpenseClaim
 @return ApiGetExpenseClaimHistoryRequest
*/
func (a *AccountingAPIService) GetExpenseClaimHistory(ctx context.Context, expenseClaimID string) ApiGetExpenseClaimHistoryRequest {
	return ApiGetExpenseClaimHistoryRequest{
		ApiService: a,
		ctx: ctx,
		expenseClaimID: expenseClaimID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) GetExpenseClaimHistoryExecute(r ApiGetExpenseClaimHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetExpenseClaimHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ExpenseClaims/{ExpenseClaimID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"ExpenseClaimID"+"}", url.PathEscape(parameterValueToString(r.expenseClaimID, "expenseClaimID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExpenseClaimsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	ifModifiedSince *time.Time
	where *string
	order *string
}

// Xero identifier for Tenant
func (r ApiGetExpenseClaimsRequest) XeroTenantId(xeroTenantId string) ApiGetExpenseClaimsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Only records created or modified since this timestamp will be returned
func (r ApiGetExpenseClaimsRequest) IfModifiedSince(ifModifiedSince time.Time) ApiGetExpenseClaimsRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

// Filter by an any element
func (r ApiGetExpenseClaimsRequest) Where(where string) ApiGetExpenseClaimsRequest {
	r.where = &where
	return r
}

// Order by an any element
func (r ApiGetExpenseClaimsRequest) Order(order string) ApiGetExpenseClaimsRequest {
	r.order = &order
	return r
}

func (r ApiGetExpenseClaimsRequest) Execute() (*ExpenseClaims, *http.Response, error) {
	return r.ApiService.GetExpenseClaimsExecute(r)
}

/*
GetExpenseClaims Retrieves expense claims

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetExpenseClaimsRequest
*/
func (a *AccountingAPIService) GetExpenseClaims(ctx context.Context) ApiGetExpenseClaimsRequest {
	return ApiGetExpenseClaimsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExpenseClaims
func (a *AccountingAPIService) GetExpenseClaimsExecute(r ApiGetExpenseClaimsRequest) (*ExpenseClaims, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExpenseClaims
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetExpenseClaims")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ExpenseClaims"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInvoiceRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	invoiceID string
	unitdp *int32
}

// Xero identifier for Tenant
func (r ApiGetInvoiceRequest) XeroTenantId(xeroTenantId string) ApiGetInvoiceRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiGetInvoiceRequest) Unitdp(unitdp int32) ApiGetInvoiceRequest {
	r.unitdp = &unitdp
	return r
}

func (r ApiGetInvoiceRequest) Execute() (*Invoices, *http.Response, error) {
	return r.ApiService.GetInvoiceExecute(r)
}

/*
GetInvoice Retrieves a specific sales invoice or purchase bill using a unique invoice Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceID Unique identifier for an Invoice
 @return ApiGetInvoiceRequest
*/
func (a *AccountingAPIService) GetInvoice(ctx context.Context, invoiceID string) ApiGetInvoiceRequest {
	return ApiGetInvoiceRequest{
		ApiService: a,
		ctx: ctx,
		invoiceID: invoiceID,
	}
}

// Execute executes the request
//  @return Invoices
func (a *AccountingAPIService) GetInvoiceExecute(r ApiGetInvoiceRequest) (*Invoices, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Invoices
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Invoices/{InvoiceID}"
	localVarPath = strings.Replace(localVarPath, "{"+"InvoiceID"+"}", url.PathEscape(parameterValueToString(r.invoiceID, "invoiceID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInvoiceAsPdfRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	invoiceID string
}

// Xero identifier for Tenant
func (r ApiGetInvoiceAsPdfRequest) XeroTenantId(xeroTenantId string) ApiGetInvoiceAsPdfRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetInvoiceAsPdfRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetInvoiceAsPdfExecute(r)
}

/*
GetInvoiceAsPdf Retrieves invoices or purchase bills as PDF files

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceID Unique identifier for an Invoice
 @return ApiGetInvoiceAsPdfRequest
*/
func (a *AccountingAPIService) GetInvoiceAsPdf(ctx context.Context, invoiceID string) ApiGetInvoiceAsPdfRequest {
	return ApiGetInvoiceAsPdfRequest{
		ApiService: a,
		ctx: ctx,
		invoiceID: invoiceID,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetInvoiceAsPdfExecute(r ApiGetInvoiceAsPdfRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetInvoiceAsPdf")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Invoices/{InvoiceID}/pdf"
	localVarPath = strings.Replace(localVarPath, "{"+"InvoiceID"+"}", url.PathEscape(parameterValueToString(r.invoiceID, "invoiceID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/pdf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInvoiceAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	invoiceID string
	fileName string
	contentType *string
}

// Xero identifier for Tenant
func (r ApiGetInvoiceAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiGetInvoiceAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
func (r ApiGetInvoiceAttachmentByFileNameRequest) ContentType(contentType string) ApiGetInvoiceAttachmentByFileNameRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetInvoiceAttachmentByFileNameRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetInvoiceAttachmentByFileNameExecute(r)
}

/*
GetInvoiceAttachmentByFileName Retrieves an attachment from a specific invoice or purchase bill by filename

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceID Unique identifier for an Invoice
 @param fileName Name of the attachment
 @return ApiGetInvoiceAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) GetInvoiceAttachmentByFileName(ctx context.Context, invoiceID string, fileName string) ApiGetInvoiceAttachmentByFileNameRequest {
	return ApiGetInvoiceAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		invoiceID: invoiceID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetInvoiceAttachmentByFileNameExecute(r ApiGetInvoiceAttachmentByFileNameRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetInvoiceAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Invoices/{InvoiceID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"InvoiceID"+"}", url.PathEscape(parameterValueToString(r.invoiceID, "invoiceID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "contentType", r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInvoiceAttachmentByIdRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	invoiceID string
	attachmentID string
	contentType *string
}

// Xero identifier for Tenant
func (r ApiGetInvoiceAttachmentByIdRequest) XeroTenantId(xeroTenantId string) ApiGetInvoiceAttachmentByIdRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
func (r ApiGetInvoiceAttachmentByIdRequest) ContentType(contentType string) ApiGetInvoiceAttachmentByIdRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetInvoiceAttachmentByIdRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetInvoiceAttachmentByIdExecute(r)
}

/*
GetInvoiceAttachmentById Retrieves a specific attachment from a specific invoices or purchase bills by using a unique attachment Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceID Unique identifier for an Invoice
 @param attachmentID Unique identifier for Attachment object
 @return ApiGetInvoiceAttachmentByIdRequest
*/
func (a *AccountingAPIService) GetInvoiceAttachmentById(ctx context.Context, invoiceID string, attachmentID string) ApiGetInvoiceAttachmentByIdRequest {
	return ApiGetInvoiceAttachmentByIdRequest{
		ApiService: a,
		ctx: ctx,
		invoiceID: invoiceID,
		attachmentID: attachmentID,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetInvoiceAttachmentByIdExecute(r ApiGetInvoiceAttachmentByIdRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetInvoiceAttachmentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Invoices/{InvoiceID}/Attachments/{AttachmentID}"
	localVarPath = strings.Replace(localVarPath, "{"+"InvoiceID"+"}", url.PathEscape(parameterValueToString(r.invoiceID, "invoiceID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"AttachmentID"+"}", url.PathEscape(parameterValueToString(r.attachmentID, "attachmentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "contentType", r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInvoiceAttachmentsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	invoiceID string
}

// Xero identifier for Tenant
func (r ApiGetInvoiceAttachmentsRequest) XeroTenantId(xeroTenantId string) ApiGetInvoiceAttachmentsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetInvoiceAttachmentsRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.GetInvoiceAttachmentsExecute(r)
}

/*
GetInvoiceAttachments Retrieves attachments for a specific invoice or purchase bill

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceID Unique identifier for an Invoice
 @return ApiGetInvoiceAttachmentsRequest
*/
func (a *AccountingAPIService) GetInvoiceAttachments(ctx context.Context, invoiceID string) ApiGetInvoiceAttachmentsRequest {
	return ApiGetInvoiceAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		invoiceID: invoiceID,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) GetInvoiceAttachmentsExecute(r ApiGetInvoiceAttachmentsRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetInvoiceAttachments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Invoices/{InvoiceID}/Attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"InvoiceID"+"}", url.PathEscape(parameterValueToString(r.invoiceID, "invoiceID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInvoiceHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	invoiceID string
}

// Xero identifier for Tenant
func (r ApiGetInvoiceHistoryRequest) XeroTenantId(xeroTenantId string) ApiGetInvoiceHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetInvoiceHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.GetInvoiceHistoryExecute(r)
}

/*
GetInvoiceHistory Retrieves history records for a specific invoice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceID Unique identifier for an Invoice
 @return ApiGetInvoiceHistoryRequest
*/
func (a *AccountingAPIService) GetInvoiceHistory(ctx context.Context, invoiceID string) ApiGetInvoiceHistoryRequest {
	return ApiGetInvoiceHistoryRequest{
		ApiService: a,
		ctx: ctx,
		invoiceID: invoiceID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) GetInvoiceHistoryExecute(r ApiGetInvoiceHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetInvoiceHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Invoices/{InvoiceID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"InvoiceID"+"}", url.PathEscape(parameterValueToString(r.invoiceID, "invoiceID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInvoiceRemindersRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
}

// Xero identifier for Tenant
func (r ApiGetInvoiceRemindersRequest) XeroTenantId(xeroTenantId string) ApiGetInvoiceRemindersRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetInvoiceRemindersRequest) Execute() (*InvoiceReminders, *http.Response, error) {
	return r.ApiService.GetInvoiceRemindersExecute(r)
}

/*
GetInvoiceReminders Retrieves invoice reminder settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetInvoiceRemindersRequest
*/
func (a *AccountingAPIService) GetInvoiceReminders(ctx context.Context) ApiGetInvoiceRemindersRequest {
	return ApiGetInvoiceRemindersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InvoiceReminders
func (a *AccountingAPIService) GetInvoiceRemindersExecute(r ApiGetInvoiceRemindersRequest) (*InvoiceReminders, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoiceReminders
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetInvoiceReminders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/InvoiceReminders/Settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInvoicesRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	ifModifiedSince *time.Time
	where *string
	order *string
	iDs *[]string
	invoiceNumbers *[]string
	contactIDs *[]string
	statuses *[]string
	page *int32
	includeArchived *bool
	createdByMyApp *bool
	unitdp *int32
	summaryOnly *bool
}

// Xero identifier for Tenant
func (r ApiGetInvoicesRequest) XeroTenantId(xeroTenantId string) ApiGetInvoicesRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Only records created or modified since this timestamp will be returned
func (r ApiGetInvoicesRequest) IfModifiedSince(ifModifiedSince time.Time) ApiGetInvoicesRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

// Filter by an any element
func (r ApiGetInvoicesRequest) Where(where string) ApiGetInvoicesRequest {
	r.where = &where
	return r
}

// Order by an any element
func (r ApiGetInvoicesRequest) Order(order string) ApiGetInvoicesRequest {
	r.order = &order
	return r
}

// Filter by a comma-separated list of InvoicesIDs.
func (r ApiGetInvoicesRequest) IDs(iDs []string) ApiGetInvoicesRequest {
	r.iDs = &iDs
	return r
}

// Filter by a comma-separated list of InvoiceNumbers.
func (r ApiGetInvoicesRequest) InvoiceNumbers(invoiceNumbers []string) ApiGetInvoicesRequest {
	r.invoiceNumbers = &invoiceNumbers
	return r
}

// Filter by a comma-separated list of ContactIDs.
func (r ApiGetInvoicesRequest) ContactIDs(contactIDs []string) ApiGetInvoicesRequest {
	r.contactIDs = &contactIDs
	return r
}

// Filter by a comma-separated list Statuses. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter.
func (r ApiGetInvoicesRequest) Statuses(statuses []string) ApiGetInvoicesRequest {
	r.statuses = &statuses
	return r
}

// e.g. page&#x3D;1 â€“ Up to 100 invoices will be returned in a single API call with line items shown for each invoice
func (r ApiGetInvoicesRequest) Page(page int32) ApiGetInvoicesRequest {
	r.page = &page
	return r
}

// e.g. includeArchived&#x3D;true - Invoices with a status of ARCHIVED will be included in the response
func (r ApiGetInvoicesRequest) IncludeArchived(includeArchived bool) ApiGetInvoicesRequest {
	r.includeArchived = &includeArchived
	return r
}

// When set to true you&#39;ll only retrieve Invoices created by your app
func (r ApiGetInvoicesRequest) CreatedByMyApp(createdByMyApp bool) ApiGetInvoicesRequest {
	r.createdByMyApp = &createdByMyApp
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiGetInvoicesRequest) Unitdp(unitdp int32) ApiGetInvoicesRequest {
	r.unitdp = &unitdp
	return r
}

// Use summaryOnly&#x3D;true in GET Contacts and Invoices endpoint to retrieve a smaller version of the response object. This returns only lightweight fields, excluding computation-heavy fields from the response, making the API calls quick and efficient.
func (r ApiGetInvoicesRequest) SummaryOnly(summaryOnly bool) ApiGetInvoicesRequest {
	r.summaryOnly = &summaryOnly
	return r
}

func (r ApiGetInvoicesRequest) Execute() (*Invoices, *http.Response, error) {
	return r.ApiService.GetInvoicesExecute(r)
}

/*
GetInvoices Retrieves sales invoices or purchase bills

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetInvoicesRequest
*/
func (a *AccountingAPIService) GetInvoices(ctx context.Context) ApiGetInvoicesRequest {
	return ApiGetInvoicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Invoices
func (a *AccountingAPIService) GetInvoicesExecute(r ApiGetInvoicesRequest) (*Invoices, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Invoices
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetInvoices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Invoices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.iDs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IDs", r.iDs, "csv")
	}
	if r.invoiceNumbers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "InvoiceNumbers", r.invoiceNumbers, "csv")
	}
	if r.contactIDs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ContactIDs", r.contactIDs, "csv")
	}
	if r.statuses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Statuses", r.statuses, "csv")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.includeArchived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeArchived", r.includeArchived, "")
	}
	if r.createdByMyApp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdByMyApp", r.createdByMyApp, "")
	}
	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	if r.summaryOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summaryOnly", r.summaryOnly, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	itemID string
	unitdp *int32
}

// Xero identifier for Tenant
func (r ApiGetItemRequest) XeroTenantId(xeroTenantId string) ApiGetItemRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiGetItemRequest) Unitdp(unitdp int32) ApiGetItemRequest {
	r.unitdp = &unitdp
	return r
}

func (r ApiGetItemRequest) Execute() (*Items, *http.Response, error) {
	return r.ApiService.GetItemExecute(r)
}

/*
GetItem Retrieves a specific item using a unique item Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemID Unique identifier for an Item
 @return ApiGetItemRequest
*/
func (a *AccountingAPIService) GetItem(ctx context.Context, itemID string) ApiGetItemRequest {
	return ApiGetItemRequest{
		ApiService: a,
		ctx: ctx,
		itemID: itemID,
	}
}

// Execute executes the request
//  @return Items
func (a *AccountingAPIService) GetItemExecute(r ApiGetItemRequest) (*Items, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Items
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{ItemID}"
	localVarPath = strings.Replace(localVarPath, "{"+"ItemID"+"}", url.PathEscape(parameterValueToString(r.itemID, "itemID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	itemID string
}

// Xero identifier for Tenant
func (r ApiGetItemHistoryRequest) XeroTenantId(xeroTenantId string) ApiGetItemHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetItemHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.GetItemHistoryExecute(r)
}

/*
GetItemHistory Retrieves history for a specific item

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemID Unique identifier for an Item
 @return ApiGetItemHistoryRequest
*/
func (a *AccountingAPIService) GetItemHistory(ctx context.Context, itemID string) ApiGetItemHistoryRequest {
	return ApiGetItemHistoryRequest{
		ApiService: a,
		ctx: ctx,
		itemID: itemID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) GetItemHistoryExecute(r ApiGetItemHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetItemHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{ItemID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"ItemID"+"}", url.PathEscape(parameterValueToString(r.itemID, "itemID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	ifModifiedSince *time.Time
	where *string
	order *string
	unitdp *int32
}

// Xero identifier for Tenant
func (r ApiGetItemsRequest) XeroTenantId(xeroTenantId string) ApiGetItemsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Only records created or modified since this timestamp will be returned
func (r ApiGetItemsRequest) IfModifiedSince(ifModifiedSince time.Time) ApiGetItemsRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

// Filter by an any element
func (r ApiGetItemsRequest) Where(where string) ApiGetItemsRequest {
	r.where = &where
	return r
}

// Order by an any element
func (r ApiGetItemsRequest) Order(order string) ApiGetItemsRequest {
	r.order = &order
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiGetItemsRequest) Unitdp(unitdp int32) ApiGetItemsRequest {
	r.unitdp = &unitdp
	return r
}

func (r ApiGetItemsRequest) Execute() (*Items, *http.Response, error) {
	return r.ApiService.GetItemsExecute(r)
}

/*
GetItems Retrieves items

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetItemsRequest
*/
func (a *AccountingAPIService) GetItems(ctx context.Context) ApiGetItemsRequest {
	return ApiGetItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Items
func (a *AccountingAPIService) GetItemsExecute(r ApiGetItemsRequest) (*Items, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Items
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJournalRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	journalID string
}

// Xero identifier for Tenant
func (r ApiGetJournalRequest) XeroTenantId(xeroTenantId string) ApiGetJournalRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetJournalRequest) Execute() (*Journals, *http.Response, error) {
	return r.ApiService.GetJournalExecute(r)
}

/*
GetJournal Retrieves a specific journal using a unique journal Id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param journalID Unique identifier for a Journal
 @return ApiGetJournalRequest
*/
func (a *AccountingAPIService) GetJournal(ctx context.Context, journalID string) ApiGetJournalRequest {
	return ApiGetJournalRequest{
		ApiService: a,
		ctx: ctx,
		journalID: journalID,
	}
}

// Execute executes the request
//  @return Journals
func (a *AccountingAPIService) GetJournalExecute(r ApiGetJournalRequest) (*Journals, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Journals
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetJournal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Journals/{JournalID}"
	localVarPath = strings.Replace(localVarPath, "{"+"JournalID"+"}", url.PathEscape(parameterValueToString(r.journalID, "journalID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJournalByNumberRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	journalNumber int32
}

// Xero identifier for Tenant
func (r ApiGetJournalByNumberRequest) XeroTenantId(xeroTenantId string) ApiGetJournalByNumberRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetJournalByNumberRequest) Execute() (*Journals, *http.Response, error) {
	return r.ApiService.GetJournalByNumberExecute(r)
}

/*
GetJournalByNumber Retrieves a specific journal using a unique journal number.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param journalNumber Number of a Journal
 @return ApiGetJournalByNumberRequest
*/
func (a *AccountingAPIService) GetJournalByNumber(ctx context.Context, journalNumber int32) ApiGetJournalByNumberRequest {
	return ApiGetJournalByNumberRequest{
		ApiService: a,
		ctx: ctx,
		journalNumber: journalNumber,
	}
}

// Execute executes the request
//  @return Journals
func (a *AccountingAPIService) GetJournalByNumberExecute(r ApiGetJournalByNumberRequest) (*Journals, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Journals
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetJournalByNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Journals/{JournalNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"JournalNumber"+"}", url.PathEscape(parameterValueToString(r.journalNumber, "journalNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJournalsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	ifModifiedSince *time.Time
	offset *int32
	paymentsOnly *bool
}

// Xero identifier for Tenant
func (r ApiGetJournalsRequest) XeroTenantId(xeroTenantId string) ApiGetJournalsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Only records created or modified since this timestamp will be returned
func (r ApiGetJournalsRequest) IfModifiedSince(ifModifiedSince time.Time) ApiGetJournalsRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

// Offset by a specified journal number. e.g. journals with a JournalNumber greater than the offset will be returned
func (r ApiGetJournalsRequest) Offset(offset int32) ApiGetJournalsRequest {
	r.offset = &offset
	return r
}

// Filter to retrieve journals on a cash basis. Journals are returned on an accrual basis by default.
func (r ApiGetJournalsRequest) PaymentsOnly(paymentsOnly bool) ApiGetJournalsRequest {
	r.paymentsOnly = &paymentsOnly
	return r
}

func (r ApiGetJournalsRequest) Execute() (*Journals, *http.Response, error) {
	return r.ApiService.GetJournalsExecute(r)
}

/*
GetJournals Retrieves journals

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetJournalsRequest
*/
func (a *AccountingAPIService) GetJournals(ctx context.Context) ApiGetJournalsRequest {
	return ApiGetJournalsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Journals
func (a *AccountingAPIService) GetJournalsExecute(r ApiGetJournalsRequest) (*Journals, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Journals
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetJournals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Journals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.paymentsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentsOnly", r.paymentsOnly, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLinkedTransactionRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	linkedTransactionID string
}

// Xero identifier for Tenant
func (r ApiGetLinkedTransactionRequest) XeroTenantId(xeroTenantId string) ApiGetLinkedTransactionRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetLinkedTransactionRequest) Execute() (*LinkedTransactions, *http.Response, error) {
	return r.ApiService.GetLinkedTransactionExecute(r)
}

/*
GetLinkedTransaction Retrieves a specific linked transaction (billable expenses) using a unique linked transaction Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param linkedTransactionID Unique identifier for a LinkedTransaction
 @return ApiGetLinkedTransactionRequest
*/
func (a *AccountingAPIService) GetLinkedTransaction(ctx context.Context, linkedTransactionID string) ApiGetLinkedTransactionRequest {
	return ApiGetLinkedTransactionRequest{
		ApiService: a,
		ctx: ctx,
		linkedTransactionID: linkedTransactionID,
	}
}

// Execute executes the request
//  @return LinkedTransactions
func (a *AccountingAPIService) GetLinkedTransactionExecute(r ApiGetLinkedTransactionRequest) (*LinkedTransactions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LinkedTransactions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetLinkedTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LinkedTransactions/{LinkedTransactionID}"
	localVarPath = strings.Replace(localVarPath, "{"+"LinkedTransactionID"+"}", url.PathEscape(parameterValueToString(r.linkedTransactionID, "linkedTransactionID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLinkedTransactionsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	page *int32
	linkedTransactionID *string
	sourceTransactionID *string
	contactID *string
	status *string
	targetTransactionID *string
}

// Xero identifier for Tenant
func (r ApiGetLinkedTransactionsRequest) XeroTenantId(xeroTenantId string) ApiGetLinkedTransactionsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Up to 100 linked transactions will be returned in a single API call. Use the page parameter to specify the page to be returned e.g. page&#x3D;1.
func (r ApiGetLinkedTransactionsRequest) Page(page int32) ApiGetLinkedTransactionsRequest {
	r.page = &page
	return r
}

// The Xero identifier for an Linked Transaction
func (r ApiGetLinkedTransactionsRequest) LinkedTransactionID(linkedTransactionID string) ApiGetLinkedTransactionsRequest {
	r.linkedTransactionID = &linkedTransactionID
	return r
}

// Filter by the SourceTransactionID. Get the linked transactions created from a particular ACCPAY invoice
func (r ApiGetLinkedTransactionsRequest) SourceTransactionID(sourceTransactionID string) ApiGetLinkedTransactionsRequest {
	r.sourceTransactionID = &sourceTransactionID
	return r
}

// Filter by the ContactID. Get all the linked transactions that have been assigned to a particular customer.
func (r ApiGetLinkedTransactionsRequest) ContactID(contactID string) ApiGetLinkedTransactionsRequest {
	r.contactID = &contactID
	return r
}

// Filter by the combination of ContactID and Status. Get  the linked transactions associated to a  customer and with a status
func (r ApiGetLinkedTransactionsRequest) Status(status string) ApiGetLinkedTransactionsRequest {
	r.status = &status
	return r
}

// Filter by the TargetTransactionID. Get all the linked transactions allocated to a particular ACCREC invoice
func (r ApiGetLinkedTransactionsRequest) TargetTransactionID(targetTransactionID string) ApiGetLinkedTransactionsRequest {
	r.targetTransactionID = &targetTransactionID
	return r
}

func (r ApiGetLinkedTransactionsRequest) Execute() (*LinkedTransactions, *http.Response, error) {
	return r.ApiService.GetLinkedTransactionsExecute(r)
}

/*
GetLinkedTransactions Retrieves linked transactions (billable expenses)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLinkedTransactionsRequest
*/
func (a *AccountingAPIService) GetLinkedTransactions(ctx context.Context) ApiGetLinkedTransactionsRequest {
	return ApiGetLinkedTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LinkedTransactions
func (a *AccountingAPIService) GetLinkedTransactionsExecute(r ApiGetLinkedTransactionsRequest) (*LinkedTransactions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LinkedTransactions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetLinkedTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LinkedTransactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.linkedTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "LinkedTransactionID", r.linkedTransactionID, "")
	}
	if r.sourceTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SourceTransactionID", r.sourceTransactionID, "")
	}
	if r.contactID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ContactID", r.contactID, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Status", r.status, "")
	}
	if r.targetTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "TargetTransactionID", r.targetTransactionID, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManualJournalRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	manualJournalID string
}

// Xero identifier for Tenant
func (r ApiGetManualJournalRequest) XeroTenantId(xeroTenantId string) ApiGetManualJournalRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetManualJournalRequest) Execute() (*ManualJournals, *http.Response, error) {
	return r.ApiService.GetManualJournalExecute(r)
}

/*
GetManualJournal Retrieves a specific manual journal

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param manualJournalID Unique identifier for a ManualJournal
 @return ApiGetManualJournalRequest
*/
func (a *AccountingAPIService) GetManualJournal(ctx context.Context, manualJournalID string) ApiGetManualJournalRequest {
	return ApiGetManualJournalRequest{
		ApiService: a,
		ctx: ctx,
		manualJournalID: manualJournalID,
	}
}

// Execute executes the request
//  @return ManualJournals
func (a *AccountingAPIService) GetManualJournalExecute(r ApiGetManualJournalRequest) (*ManualJournals, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManualJournals
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetManualJournal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ManualJournals/{ManualJournalID}"
	localVarPath = strings.Replace(localVarPath, "{"+"ManualJournalID"+"}", url.PathEscape(parameterValueToString(r.manualJournalID, "manualJournalID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManualJournalAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	manualJournalID string
	fileName string
	contentType *string
}

// Xero identifier for Tenant
func (r ApiGetManualJournalAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiGetManualJournalAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
func (r ApiGetManualJournalAttachmentByFileNameRequest) ContentType(contentType string) ApiGetManualJournalAttachmentByFileNameRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetManualJournalAttachmentByFileNameRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetManualJournalAttachmentByFileNameExecute(r)
}

/*
GetManualJournalAttachmentByFileName Retrieves a specific attachment from a specific manual journal by file name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param manualJournalID Unique identifier for a ManualJournal
 @param fileName Name of the attachment
 @return ApiGetManualJournalAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) GetManualJournalAttachmentByFileName(ctx context.Context, manualJournalID string, fileName string) ApiGetManualJournalAttachmentByFileNameRequest {
	return ApiGetManualJournalAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		manualJournalID: manualJournalID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetManualJournalAttachmentByFileNameExecute(r ApiGetManualJournalAttachmentByFileNameRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetManualJournalAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ManualJournals/{ManualJournalID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"ManualJournalID"+"}", url.PathEscape(parameterValueToString(r.manualJournalID, "manualJournalID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "contentType", r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManualJournalAttachmentByIdRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	manualJournalID string
	attachmentID string
	contentType *string
}

// Xero identifier for Tenant
func (r ApiGetManualJournalAttachmentByIdRequest) XeroTenantId(xeroTenantId string) ApiGetManualJournalAttachmentByIdRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
func (r ApiGetManualJournalAttachmentByIdRequest) ContentType(contentType string) ApiGetManualJournalAttachmentByIdRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetManualJournalAttachmentByIdRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetManualJournalAttachmentByIdExecute(r)
}

/*
GetManualJournalAttachmentById Allows you to retrieve a specific attachment from a specific manual journal using a unique attachment Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param manualJournalID Unique identifier for a ManualJournal
 @param attachmentID Unique identifier for Attachment object
 @return ApiGetManualJournalAttachmentByIdRequest
*/
func (a *AccountingAPIService) GetManualJournalAttachmentById(ctx context.Context, manualJournalID string, attachmentID string) ApiGetManualJournalAttachmentByIdRequest {
	return ApiGetManualJournalAttachmentByIdRequest{
		ApiService: a,
		ctx: ctx,
		manualJournalID: manualJournalID,
		attachmentID: attachmentID,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetManualJournalAttachmentByIdExecute(r ApiGetManualJournalAttachmentByIdRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetManualJournalAttachmentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ManualJournals/{ManualJournalID}/Attachments/{AttachmentID}"
	localVarPath = strings.Replace(localVarPath, "{"+"ManualJournalID"+"}", url.PathEscape(parameterValueToString(r.manualJournalID, "manualJournalID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"AttachmentID"+"}", url.PathEscape(parameterValueToString(r.attachmentID, "attachmentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "contentType", r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManualJournalAttachmentsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	manualJournalID string
}

// Xero identifier for Tenant
func (r ApiGetManualJournalAttachmentsRequest) XeroTenantId(xeroTenantId string) ApiGetManualJournalAttachmentsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetManualJournalAttachmentsRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.GetManualJournalAttachmentsExecute(r)
}

/*
GetManualJournalAttachments Retrieves attachment for a specific manual journal

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param manualJournalID Unique identifier for a ManualJournal
 @return ApiGetManualJournalAttachmentsRequest
*/
func (a *AccountingAPIService) GetManualJournalAttachments(ctx context.Context, manualJournalID string) ApiGetManualJournalAttachmentsRequest {
	return ApiGetManualJournalAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		manualJournalID: manualJournalID,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) GetManualJournalAttachmentsExecute(r ApiGetManualJournalAttachmentsRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetManualJournalAttachments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ManualJournals/{ManualJournalID}/Attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"ManualJournalID"+"}", url.PathEscape(parameterValueToString(r.manualJournalID, "manualJournalID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManualJournalsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	ifModifiedSince *time.Time
	where *string
	order *string
	page *int32
}

// Xero identifier for Tenant
func (r ApiGetManualJournalsRequest) XeroTenantId(xeroTenantId string) ApiGetManualJournalsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Only records created or modified since this timestamp will be returned
func (r ApiGetManualJournalsRequest) IfModifiedSince(ifModifiedSince time.Time) ApiGetManualJournalsRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

// Filter by an any element
func (r ApiGetManualJournalsRequest) Where(where string) ApiGetManualJournalsRequest {
	r.where = &where
	return r
}

// Order by an any element
func (r ApiGetManualJournalsRequest) Order(order string) ApiGetManualJournalsRequest {
	r.order = &order
	return r
}

// e.g. page&#x3D;1 â€“ Up to 100 manual journals will be returned in a single API call with line items shown for each overpayment
func (r ApiGetManualJournalsRequest) Page(page int32) ApiGetManualJournalsRequest {
	r.page = &page
	return r
}

func (r ApiGetManualJournalsRequest) Execute() (*ManualJournals, *http.Response, error) {
	return r.ApiService.GetManualJournalsExecute(r)
}

/*
GetManualJournals Retrieves manual journals

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetManualJournalsRequest
*/
func (a *AccountingAPIService) GetManualJournals(ctx context.Context) ApiGetManualJournalsRequest {
	return ApiGetManualJournalsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ManualJournals
func (a *AccountingAPIService) GetManualJournalsExecute(r ApiGetManualJournalsRequest) (*ManualJournals, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManualJournals
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetManualJournals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ManualJournals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManualJournalsHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	manualJournalID string
}

// Xero identifier for Tenant
func (r ApiGetManualJournalsHistoryRequest) XeroTenantId(xeroTenantId string) ApiGetManualJournalsHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetManualJournalsHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.GetManualJournalsHistoryExecute(r)
}

/*
GetManualJournalsHistory Retrieves history for a specific manual journal

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param manualJournalID Unique identifier for a ManualJournal
 @return ApiGetManualJournalsHistoryRequest
*/
func (a *AccountingAPIService) GetManualJournalsHistory(ctx context.Context, manualJournalID string) ApiGetManualJournalsHistoryRequest {
	return ApiGetManualJournalsHistoryRequest{
		ApiService: a,
		ctx: ctx,
		manualJournalID: manualJournalID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) GetManualJournalsHistoryExecute(r ApiGetManualJournalsHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetManualJournalsHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ManualJournals/{ManualJournalID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"ManualJournalID"+"}", url.PathEscape(parameterValueToString(r.manualJournalID, "manualJournalID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOnlineInvoiceRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	invoiceID string
}

// Xero identifier for Tenant
func (r ApiGetOnlineInvoiceRequest) XeroTenantId(xeroTenantId string) ApiGetOnlineInvoiceRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetOnlineInvoiceRequest) Execute() (*OnlineInvoices, *http.Response, error) {
	return r.ApiService.GetOnlineInvoiceExecute(r)
}

/*
GetOnlineInvoice Retrieves a URL to an online invoice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceID Unique identifier for an Invoice
 @return ApiGetOnlineInvoiceRequest
*/
func (a *AccountingAPIService) GetOnlineInvoice(ctx context.Context, invoiceID string) ApiGetOnlineInvoiceRequest {
	return ApiGetOnlineInvoiceRequest{
		ApiService: a,
		ctx: ctx,
		invoiceID: invoiceID,
	}
}

// Execute executes the request
//  @return OnlineInvoices
func (a *AccountingAPIService) GetOnlineInvoiceExecute(r ApiGetOnlineInvoiceRequest) (*OnlineInvoices, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OnlineInvoices
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetOnlineInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Invoices/{InvoiceID}/OnlineInvoice"
	localVarPath = strings.Replace(localVarPath, "{"+"InvoiceID"+"}", url.PathEscape(parameterValueToString(r.invoiceID, "invoiceID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrganisationActionsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
}

// Xero identifier for Tenant
func (r ApiGetOrganisationActionsRequest) XeroTenantId(xeroTenantId string) ApiGetOrganisationActionsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetOrganisationActionsRequest) Execute() (*Actions, *http.Response, error) {
	return r.ApiService.GetOrganisationActionsExecute(r)
}

/*
GetOrganisationActions Retrieves a list of the key actions your app has permission to perform in the connected Xero organisation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOrganisationActionsRequest
*/
func (a *AccountingAPIService) GetOrganisationActions(ctx context.Context) ApiGetOrganisationActionsRequest {
	return ApiGetOrganisationActionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Actions
func (a *AccountingAPIService) GetOrganisationActionsExecute(r ApiGetOrganisationActionsRequest) (*Actions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Actions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetOrganisationActions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Organisation/Actions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrganisationCISSettingsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	organisationID string
}

// Xero identifier for Tenant
func (r ApiGetOrganisationCISSettingsRequest) XeroTenantId(xeroTenantId string) ApiGetOrganisationCISSettingsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetOrganisationCISSettingsRequest) Execute() (*CISOrgSettings, *http.Response, error) {
	return r.ApiService.GetOrganisationCISSettingsExecute(r)
}

/*
GetOrganisationCISSettings Retrieves the CIS settings for the Xero organistaion.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationID The unique Xero identifier for an organisation
 @return ApiGetOrganisationCISSettingsRequest
*/
func (a *AccountingAPIService) GetOrganisationCISSettings(ctx context.Context, organisationID string) ApiGetOrganisationCISSettingsRequest {
	return ApiGetOrganisationCISSettingsRequest{
		ApiService: a,
		ctx: ctx,
		organisationID: organisationID,
	}
}

// Execute executes the request
//  @return CISOrgSettings
func (a *AccountingAPIService) GetOrganisationCISSettingsExecute(r ApiGetOrganisationCISSettingsRequest) (*CISOrgSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CISOrgSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetOrganisationCISSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Organisation/{OrganisationID}/CISSettings"
	localVarPath = strings.Replace(localVarPath, "{"+"OrganisationID"+"}", url.PathEscape(parameterValueToString(r.organisationID, "organisationID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrganisationsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
}

// Xero identifier for Tenant
func (r ApiGetOrganisationsRequest) XeroTenantId(xeroTenantId string) ApiGetOrganisationsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetOrganisationsRequest) Execute() (*Organisations, *http.Response, error) {
	return r.ApiService.GetOrganisationsExecute(r)
}

/*
GetOrganisations Retrieves Xero organisation details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOrganisationsRequest
*/
func (a *AccountingAPIService) GetOrganisations(ctx context.Context) ApiGetOrganisationsRequest {
	return ApiGetOrganisationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Organisations
func (a *AccountingAPIService) GetOrganisationsExecute(r ApiGetOrganisationsRequest) (*Organisations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Organisations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetOrganisations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Organisation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOverpaymentRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	overpaymentID string
}

// Xero identifier for Tenant
func (r ApiGetOverpaymentRequest) XeroTenantId(xeroTenantId string) ApiGetOverpaymentRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetOverpaymentRequest) Execute() (*Overpayments, *http.Response, error) {
	return r.ApiService.GetOverpaymentExecute(r)
}

/*
GetOverpayment Retrieves a specific overpayment using a unique overpayment Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param overpaymentID Unique identifier for a Overpayment
 @return ApiGetOverpaymentRequest
*/
func (a *AccountingAPIService) GetOverpayment(ctx context.Context, overpaymentID string) ApiGetOverpaymentRequest {
	return ApiGetOverpaymentRequest{
		ApiService: a,
		ctx: ctx,
		overpaymentID: overpaymentID,
	}
}

// Execute executes the request
//  @return Overpayments
func (a *AccountingAPIService) GetOverpaymentExecute(r ApiGetOverpaymentRequest) (*Overpayments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Overpayments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetOverpayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Overpayments/{OverpaymentID}"
	localVarPath = strings.Replace(localVarPath, "{"+"OverpaymentID"+"}", url.PathEscape(parameterValueToString(r.overpaymentID, "overpaymentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOverpaymentHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	overpaymentID string
}

// Xero identifier for Tenant
func (r ApiGetOverpaymentHistoryRequest) XeroTenantId(xeroTenantId string) ApiGetOverpaymentHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetOverpaymentHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.GetOverpaymentHistoryExecute(r)
}

/*
GetOverpaymentHistory Retrieves history records of a specific overpayment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param overpaymentID Unique identifier for a Overpayment
 @return ApiGetOverpaymentHistoryRequest
*/
func (a *AccountingAPIService) GetOverpaymentHistory(ctx context.Context, overpaymentID string) ApiGetOverpaymentHistoryRequest {
	return ApiGetOverpaymentHistoryRequest{
		ApiService: a,
		ctx: ctx,
		overpaymentID: overpaymentID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) GetOverpaymentHistoryExecute(r ApiGetOverpaymentHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetOverpaymentHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Overpayments/{OverpaymentID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"OverpaymentID"+"}", url.PathEscape(parameterValueToString(r.overpaymentID, "overpaymentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOverpaymentsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	ifModifiedSince *time.Time
	where *string
	order *string
	page *int32
	unitdp *int32
}

// Xero identifier for Tenant
func (r ApiGetOverpaymentsRequest) XeroTenantId(xeroTenantId string) ApiGetOverpaymentsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Only records created or modified since this timestamp will be returned
func (r ApiGetOverpaymentsRequest) IfModifiedSince(ifModifiedSince time.Time) ApiGetOverpaymentsRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

// Filter by an any element
func (r ApiGetOverpaymentsRequest) Where(where string) ApiGetOverpaymentsRequest {
	r.where = &where
	return r
}

// Order by an any element
func (r ApiGetOverpaymentsRequest) Order(order string) ApiGetOverpaymentsRequest {
	r.order = &order
	return r
}

// e.g. page&#x3D;1 â€“ Up to 100 overpayments will be returned in a single API call with line items shown for each overpayment
func (r ApiGetOverpaymentsRequest) Page(page int32) ApiGetOverpaymentsRequest {
	r.page = &page
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiGetOverpaymentsRequest) Unitdp(unitdp int32) ApiGetOverpaymentsRequest {
	r.unitdp = &unitdp
	return r
}

func (r ApiGetOverpaymentsRequest) Execute() (*Overpayments, *http.Response, error) {
	return r.ApiService.GetOverpaymentsExecute(r)
}

/*
GetOverpayments Retrieves overpayments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOverpaymentsRequest
*/
func (a *AccountingAPIService) GetOverpayments(ctx context.Context) ApiGetOverpaymentsRequest {
	return ApiGetOverpaymentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Overpayments
func (a *AccountingAPIService) GetOverpaymentsExecute(r ApiGetOverpaymentsRequest) (*Overpayments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Overpayments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetOverpayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Overpayments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPaymentRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	paymentID string
}

// Xero identifier for Tenant
func (r ApiGetPaymentRequest) XeroTenantId(xeroTenantId string) ApiGetPaymentRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetPaymentRequest) Execute() (*Payments, *http.Response, error) {
	return r.ApiService.GetPaymentExecute(r)
}

/*
GetPayment Retrieves a specific payment for invoices and credit notes using a unique payment Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param paymentID Unique identifier for a Payment
 @return ApiGetPaymentRequest
*/
func (a *AccountingAPIService) GetPayment(ctx context.Context, paymentID string) ApiGetPaymentRequest {
	return ApiGetPaymentRequest{
		ApiService: a,
		ctx: ctx,
		paymentID: paymentID,
	}
}

// Execute executes the request
//  @return Payments
func (a *AccountingAPIService) GetPaymentExecute(r ApiGetPaymentRequest) (*Payments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Payments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Payments/{PaymentID}"
	localVarPath = strings.Replace(localVarPath, "{"+"PaymentID"+"}", url.PathEscape(parameterValueToString(r.paymentID, "paymentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPaymentHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	paymentID string
}

// Xero identifier for Tenant
func (r ApiGetPaymentHistoryRequest) XeroTenantId(xeroTenantId string) ApiGetPaymentHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetPaymentHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.GetPaymentHistoryExecute(r)
}

/*
GetPaymentHistory Retrieves history records of a specific payment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param paymentID Unique identifier for a Payment
 @return ApiGetPaymentHistoryRequest
*/
func (a *AccountingAPIService) GetPaymentHistory(ctx context.Context, paymentID string) ApiGetPaymentHistoryRequest {
	return ApiGetPaymentHistoryRequest{
		ApiService: a,
		ctx: ctx,
		paymentID: paymentID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) GetPaymentHistoryExecute(r ApiGetPaymentHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetPaymentHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Payments/{PaymentID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"PaymentID"+"}", url.PathEscape(parameterValueToString(r.paymentID, "paymentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPaymentServicesRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
}

// Xero identifier for Tenant
func (r ApiGetPaymentServicesRequest) XeroTenantId(xeroTenantId string) ApiGetPaymentServicesRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetPaymentServicesRequest) Execute() (*PaymentServices, *http.Response, error) {
	return r.ApiService.GetPaymentServicesExecute(r)
}

/*
GetPaymentServices Retrieves payment services

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPaymentServicesRequest
*/
func (a *AccountingAPIService) GetPaymentServices(ctx context.Context) ApiGetPaymentServicesRequest {
	return ApiGetPaymentServicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentServices
func (a *AccountingAPIService) GetPaymentServicesExecute(r ApiGetPaymentServicesRequest) (*PaymentServices, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentServices
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetPaymentServices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PaymentServices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPaymentsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	ifModifiedSince *time.Time
	where *string
	order *string
	page *int32
}

// Xero identifier for Tenant
func (r ApiGetPaymentsRequest) XeroTenantId(xeroTenantId string) ApiGetPaymentsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Only records created or modified since this timestamp will be returned
func (r ApiGetPaymentsRequest) IfModifiedSince(ifModifiedSince time.Time) ApiGetPaymentsRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

// Filter by an any element
func (r ApiGetPaymentsRequest) Where(where string) ApiGetPaymentsRequest {
	r.where = &where
	return r
}

// Order by an any element
func (r ApiGetPaymentsRequest) Order(order string) ApiGetPaymentsRequest {
	r.order = &order
	return r
}

// Up to 100 payments will be returned in a single API call
func (r ApiGetPaymentsRequest) Page(page int32) ApiGetPaymentsRequest {
	r.page = &page
	return r
}

func (r ApiGetPaymentsRequest) Execute() (*Payments, *http.Response, error) {
	return r.ApiService.GetPaymentsExecute(r)
}

/*
GetPayments Retrieves payments for invoices and credit notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPaymentsRequest
*/
func (a *AccountingAPIService) GetPayments(ctx context.Context) ApiGetPaymentsRequest {
	return ApiGetPaymentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Payments
func (a *AccountingAPIService) GetPaymentsExecute(r ApiGetPaymentsRequest) (*Payments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Payments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetPayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Payments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPrepaymentRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	prepaymentID string
}

// Xero identifier for Tenant
func (r ApiGetPrepaymentRequest) XeroTenantId(xeroTenantId string) ApiGetPrepaymentRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetPrepaymentRequest) Execute() (*Prepayments, *http.Response, error) {
	return r.ApiService.GetPrepaymentExecute(r)
}

/*
GetPrepayment Allows you to retrieve a specified prepayments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param prepaymentID Unique identifier for a PrePayment
 @return ApiGetPrepaymentRequest
*/
func (a *AccountingAPIService) GetPrepayment(ctx context.Context, prepaymentID string) ApiGetPrepaymentRequest {
	return ApiGetPrepaymentRequest{
		ApiService: a,
		ctx: ctx,
		prepaymentID: prepaymentID,
	}
}

// Execute executes the request
//  @return Prepayments
func (a *AccountingAPIService) GetPrepaymentExecute(r ApiGetPrepaymentRequest) (*Prepayments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Prepayments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetPrepayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Prepayments/{PrepaymentID}"
	localVarPath = strings.Replace(localVarPath, "{"+"PrepaymentID"+"}", url.PathEscape(parameterValueToString(r.prepaymentID, "prepaymentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPrepaymentHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	prepaymentID string
}

// Xero identifier for Tenant
func (r ApiGetPrepaymentHistoryRequest) XeroTenantId(xeroTenantId string) ApiGetPrepaymentHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetPrepaymentHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.GetPrepaymentHistoryExecute(r)
}

/*
GetPrepaymentHistory Retrieves history record for a specific prepayment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param prepaymentID Unique identifier for a PrePayment
 @return ApiGetPrepaymentHistoryRequest
*/
func (a *AccountingAPIService) GetPrepaymentHistory(ctx context.Context, prepaymentID string) ApiGetPrepaymentHistoryRequest {
	return ApiGetPrepaymentHistoryRequest{
		ApiService: a,
		ctx: ctx,
		prepaymentID: prepaymentID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) GetPrepaymentHistoryExecute(r ApiGetPrepaymentHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetPrepaymentHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Prepayments/{PrepaymentID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"PrepaymentID"+"}", url.PathEscape(parameterValueToString(r.prepaymentID, "prepaymentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPrepaymentsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	ifModifiedSince *time.Time
	where *string
	order *string
	page *int32
	unitdp *int32
}

// Xero identifier for Tenant
func (r ApiGetPrepaymentsRequest) XeroTenantId(xeroTenantId string) ApiGetPrepaymentsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Only records created or modified since this timestamp will be returned
func (r ApiGetPrepaymentsRequest) IfModifiedSince(ifModifiedSince time.Time) ApiGetPrepaymentsRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

// Filter by an any element
func (r ApiGetPrepaymentsRequest) Where(where string) ApiGetPrepaymentsRequest {
	r.where = &where
	return r
}

// Order by an any element
func (r ApiGetPrepaymentsRequest) Order(order string) ApiGetPrepaymentsRequest {
	r.order = &order
	return r
}

// e.g. page&#x3D;1 â€“ Up to 100 prepayments will be returned in a single API call with line items shown for each overpayment
func (r ApiGetPrepaymentsRequest) Page(page int32) ApiGetPrepaymentsRequest {
	r.page = &page
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiGetPrepaymentsRequest) Unitdp(unitdp int32) ApiGetPrepaymentsRequest {
	r.unitdp = &unitdp
	return r
}

func (r ApiGetPrepaymentsRequest) Execute() (*Prepayments, *http.Response, error) {
	return r.ApiService.GetPrepaymentsExecute(r)
}

/*
GetPrepayments Retrieves prepayments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPrepaymentsRequest
*/
func (a *AccountingAPIService) GetPrepayments(ctx context.Context) ApiGetPrepaymentsRequest {
	return ApiGetPrepaymentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Prepayments
func (a *AccountingAPIService) GetPrepaymentsExecute(r ApiGetPrepaymentsRequest) (*Prepayments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Prepayments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetPrepayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Prepayments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPurchaseOrderRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	purchaseOrderID string
}

// Xero identifier for Tenant
func (r ApiGetPurchaseOrderRequest) XeroTenantId(xeroTenantId string) ApiGetPurchaseOrderRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetPurchaseOrderRequest) Execute() (*PurchaseOrders, *http.Response, error) {
	return r.ApiService.GetPurchaseOrderExecute(r)
}

/*
GetPurchaseOrder Retrieves a specific purchase order using a unique purchase order Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param purchaseOrderID Unique identifier for an Purchase Order
 @return ApiGetPurchaseOrderRequest
*/
func (a *AccountingAPIService) GetPurchaseOrder(ctx context.Context, purchaseOrderID string) ApiGetPurchaseOrderRequest {
	return ApiGetPurchaseOrderRequest{
		ApiService: a,
		ctx: ctx,
		purchaseOrderID: purchaseOrderID,
	}
}

// Execute executes the request
//  @return PurchaseOrders
func (a *AccountingAPIService) GetPurchaseOrderExecute(r ApiGetPurchaseOrderRequest) (*PurchaseOrders, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PurchaseOrders
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetPurchaseOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PurchaseOrders/{PurchaseOrderID}"
	localVarPath = strings.Replace(localVarPath, "{"+"PurchaseOrderID"+"}", url.PathEscape(parameterValueToString(r.purchaseOrderID, "purchaseOrderID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPurchaseOrderAsPdfRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	purchaseOrderID string
}

// Xero identifier for Tenant
func (r ApiGetPurchaseOrderAsPdfRequest) XeroTenantId(xeroTenantId string) ApiGetPurchaseOrderAsPdfRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetPurchaseOrderAsPdfRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetPurchaseOrderAsPdfExecute(r)
}

/*
GetPurchaseOrderAsPdf Retrieves specific purchase order as PDF files using a unique purchase order Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param purchaseOrderID Unique identifier for an Purchase Order
 @return ApiGetPurchaseOrderAsPdfRequest
*/
func (a *AccountingAPIService) GetPurchaseOrderAsPdf(ctx context.Context, purchaseOrderID string) ApiGetPurchaseOrderAsPdfRequest {
	return ApiGetPurchaseOrderAsPdfRequest{
		ApiService: a,
		ctx: ctx,
		purchaseOrderID: purchaseOrderID,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetPurchaseOrderAsPdfExecute(r ApiGetPurchaseOrderAsPdfRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetPurchaseOrderAsPdf")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PurchaseOrders/{PurchaseOrderID}/pdf"
	localVarPath = strings.Replace(localVarPath, "{"+"PurchaseOrderID"+"}", url.PathEscape(parameterValueToString(r.purchaseOrderID, "purchaseOrderID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/pdf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPurchaseOrderAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	purchaseOrderID string
	fileName string
	contentType *string
}

// Xero identifier for Tenant
func (r ApiGetPurchaseOrderAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiGetPurchaseOrderAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
func (r ApiGetPurchaseOrderAttachmentByFileNameRequest) ContentType(contentType string) ApiGetPurchaseOrderAttachmentByFileNameRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetPurchaseOrderAttachmentByFileNameRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetPurchaseOrderAttachmentByFileNameExecute(r)
}

/*
GetPurchaseOrderAttachmentByFileName Retrieves a specific attachment for a specific purchase order by filename

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param purchaseOrderID Unique identifier for an Purchase Order
 @param fileName Name of the attachment
 @return ApiGetPurchaseOrderAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) GetPurchaseOrderAttachmentByFileName(ctx context.Context, purchaseOrderID string, fileName string) ApiGetPurchaseOrderAttachmentByFileNameRequest {
	return ApiGetPurchaseOrderAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		purchaseOrderID: purchaseOrderID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetPurchaseOrderAttachmentByFileNameExecute(r ApiGetPurchaseOrderAttachmentByFileNameRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetPurchaseOrderAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PurchaseOrders/{PurchaseOrderID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"PurchaseOrderID"+"}", url.PathEscape(parameterValueToString(r.purchaseOrderID, "purchaseOrderID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "contentType", r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPurchaseOrderAttachmentByIdRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	purchaseOrderID string
	attachmentID string
	contentType *string
}

// Xero identifier for Tenant
func (r ApiGetPurchaseOrderAttachmentByIdRequest) XeroTenantId(xeroTenantId string) ApiGetPurchaseOrderAttachmentByIdRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
func (r ApiGetPurchaseOrderAttachmentByIdRequest) ContentType(contentType string) ApiGetPurchaseOrderAttachmentByIdRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetPurchaseOrderAttachmentByIdRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetPurchaseOrderAttachmentByIdExecute(r)
}

/*
GetPurchaseOrderAttachmentById Retrieves specific attachment for a specific purchase order using a unique attachment Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param purchaseOrderID Unique identifier for an Purchase Order
 @param attachmentID Unique identifier for Attachment object
 @return ApiGetPurchaseOrderAttachmentByIdRequest
*/
func (a *AccountingAPIService) GetPurchaseOrderAttachmentById(ctx context.Context, purchaseOrderID string, attachmentID string) ApiGetPurchaseOrderAttachmentByIdRequest {
	return ApiGetPurchaseOrderAttachmentByIdRequest{
		ApiService: a,
		ctx: ctx,
		purchaseOrderID: purchaseOrderID,
		attachmentID: attachmentID,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetPurchaseOrderAttachmentByIdExecute(r ApiGetPurchaseOrderAttachmentByIdRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetPurchaseOrderAttachmentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PurchaseOrders/{PurchaseOrderID}/Attachments/{AttachmentID}"
	localVarPath = strings.Replace(localVarPath, "{"+"PurchaseOrderID"+"}", url.PathEscape(parameterValueToString(r.purchaseOrderID, "purchaseOrderID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"AttachmentID"+"}", url.PathEscape(parameterValueToString(r.attachmentID, "attachmentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "contentType", r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPurchaseOrderAttachmentsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	purchaseOrderID string
}

// Xero identifier for Tenant
func (r ApiGetPurchaseOrderAttachmentsRequest) XeroTenantId(xeroTenantId string) ApiGetPurchaseOrderAttachmentsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetPurchaseOrderAttachmentsRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.GetPurchaseOrderAttachmentsExecute(r)
}

/*
GetPurchaseOrderAttachments Retrieves attachments for a specific purchase order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param purchaseOrderID Unique identifier for an Purchase Order
 @return ApiGetPurchaseOrderAttachmentsRequest
*/
func (a *AccountingAPIService) GetPurchaseOrderAttachments(ctx context.Context, purchaseOrderID string) ApiGetPurchaseOrderAttachmentsRequest {
	return ApiGetPurchaseOrderAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		purchaseOrderID: purchaseOrderID,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) GetPurchaseOrderAttachmentsExecute(r ApiGetPurchaseOrderAttachmentsRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetPurchaseOrderAttachments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PurchaseOrders/{PurchaseOrderID}/Attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"PurchaseOrderID"+"}", url.PathEscape(parameterValueToString(r.purchaseOrderID, "purchaseOrderID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPurchaseOrderByNumberRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	purchaseOrderNumber string
}

// Xero identifier for Tenant
func (r ApiGetPurchaseOrderByNumberRequest) XeroTenantId(xeroTenantId string) ApiGetPurchaseOrderByNumberRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetPurchaseOrderByNumberRequest) Execute() (*PurchaseOrders, *http.Response, error) {
	return r.ApiService.GetPurchaseOrderByNumberExecute(r)
}

/*
GetPurchaseOrderByNumber Retrieves a specific purchase order using purchase order number

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param purchaseOrderNumber Unique identifier for a PurchaseOrder
 @return ApiGetPurchaseOrderByNumberRequest
*/
func (a *AccountingAPIService) GetPurchaseOrderByNumber(ctx context.Context, purchaseOrderNumber string) ApiGetPurchaseOrderByNumberRequest {
	return ApiGetPurchaseOrderByNumberRequest{
		ApiService: a,
		ctx: ctx,
		purchaseOrderNumber: purchaseOrderNumber,
	}
}

// Execute executes the request
//  @return PurchaseOrders
func (a *AccountingAPIService) GetPurchaseOrderByNumberExecute(r ApiGetPurchaseOrderByNumberRequest) (*PurchaseOrders, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PurchaseOrders
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetPurchaseOrderByNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PurchaseOrders/{PurchaseOrderNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"PurchaseOrderNumber"+"}", url.PathEscape(parameterValueToString(r.purchaseOrderNumber, "purchaseOrderNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPurchaseOrderHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	purchaseOrderID string
}

// Xero identifier for Tenant
func (r ApiGetPurchaseOrderHistoryRequest) XeroTenantId(xeroTenantId string) ApiGetPurchaseOrderHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetPurchaseOrderHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.GetPurchaseOrderHistoryExecute(r)
}

/*
GetPurchaseOrderHistory Retrieves history for a specific purchase order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param purchaseOrderID Unique identifier for an Purchase Order
 @return ApiGetPurchaseOrderHistoryRequest
*/
func (a *AccountingAPIService) GetPurchaseOrderHistory(ctx context.Context, purchaseOrderID string) ApiGetPurchaseOrderHistoryRequest {
	return ApiGetPurchaseOrderHistoryRequest{
		ApiService: a,
		ctx: ctx,
		purchaseOrderID: purchaseOrderID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) GetPurchaseOrderHistoryExecute(r ApiGetPurchaseOrderHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetPurchaseOrderHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PurchaseOrders/{PurchaseOrderID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"PurchaseOrderID"+"}", url.PathEscape(parameterValueToString(r.purchaseOrderID, "purchaseOrderID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPurchaseOrdersRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	ifModifiedSince *time.Time
	status *string
	dateFrom *string
	dateTo *string
	order *string
	page *int32
}

// Xero identifier for Tenant
func (r ApiGetPurchaseOrdersRequest) XeroTenantId(xeroTenantId string) ApiGetPurchaseOrdersRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Only records created or modified since this timestamp will be returned
func (r ApiGetPurchaseOrdersRequest) IfModifiedSince(ifModifiedSince time.Time) ApiGetPurchaseOrdersRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

// Filter by purchase order status
func (r ApiGetPurchaseOrdersRequest) Status(status string) ApiGetPurchaseOrdersRequest {
	r.status = &status
	return r
}

// Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom&#x3D;2015-12-01&amp;DateTo&#x3D;2015-12-31
func (r ApiGetPurchaseOrdersRequest) DateFrom(dateFrom string) ApiGetPurchaseOrdersRequest {
	r.dateFrom = &dateFrom
	return r
}

// Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom&#x3D;2015-12-01&amp;DateTo&#x3D;2015-12-31
func (r ApiGetPurchaseOrdersRequest) DateTo(dateTo string) ApiGetPurchaseOrdersRequest {
	r.dateTo = &dateTo
	return r
}

// Order by an any element
func (r ApiGetPurchaseOrdersRequest) Order(order string) ApiGetPurchaseOrdersRequest {
	r.order = &order
	return r
}

// To specify a page, append the page parameter to the URL e.g. ?page&#x3D;1. If there are 100 records in the response you will need to check if there is any more data by fetching the next page e.g ?page&#x3D;2 and continuing this process until no more results are returned.
func (r ApiGetPurchaseOrdersRequest) Page(page int32) ApiGetPurchaseOrdersRequest {
	r.page = &page
	return r
}

func (r ApiGetPurchaseOrdersRequest) Execute() (*PurchaseOrders, *http.Response, error) {
	return r.ApiService.GetPurchaseOrdersExecute(r)
}

/*
GetPurchaseOrders Retrieves purchase orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPurchaseOrdersRequest
*/
func (a *AccountingAPIService) GetPurchaseOrders(ctx context.Context) ApiGetPurchaseOrdersRequest {
	return ApiGetPurchaseOrdersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PurchaseOrders
func (a *AccountingAPIService) GetPurchaseOrdersExecute(r ApiGetPurchaseOrdersRequest) (*PurchaseOrders, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PurchaseOrders
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetPurchaseOrders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PurchaseOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Status", r.status, "")
	}
	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "DateFrom", r.dateFrom, "")
	}
	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "DateTo", r.dateTo, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetQuoteRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	quoteID string
}

// Xero identifier for Tenant
func (r ApiGetQuoteRequest) XeroTenantId(xeroTenantId string) ApiGetQuoteRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetQuoteRequest) Execute() (*Quotes, *http.Response, error) {
	return r.ApiService.GetQuoteExecute(r)
}

/*
GetQuote Retrieves a specific quote using a unique quote Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param quoteID Unique identifier for an Quote
 @return ApiGetQuoteRequest
*/
func (a *AccountingAPIService) GetQuote(ctx context.Context, quoteID string) ApiGetQuoteRequest {
	return ApiGetQuoteRequest{
		ApiService: a,
		ctx: ctx,
		quoteID: quoteID,
	}
}

// Execute executes the request
//  @return Quotes
func (a *AccountingAPIService) GetQuoteExecute(r ApiGetQuoteRequest) (*Quotes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Quotes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetQuote")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Quotes/{QuoteID}"
	localVarPath = strings.Replace(localVarPath, "{"+"QuoteID"+"}", url.PathEscape(parameterValueToString(r.quoteID, "quoteID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetQuoteAsPdfRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	quoteID string
}

// Xero identifier for Tenant
func (r ApiGetQuoteAsPdfRequest) XeroTenantId(xeroTenantId string) ApiGetQuoteAsPdfRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetQuoteAsPdfRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetQuoteAsPdfExecute(r)
}

/*
GetQuoteAsPdf Retrieves a specific quote as a PDF file using a unique quote Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param quoteID Unique identifier for an Quote
 @return ApiGetQuoteAsPdfRequest
*/
func (a *AccountingAPIService) GetQuoteAsPdf(ctx context.Context, quoteID string) ApiGetQuoteAsPdfRequest {
	return ApiGetQuoteAsPdfRequest{
		ApiService: a,
		ctx: ctx,
		quoteID: quoteID,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetQuoteAsPdfExecute(r ApiGetQuoteAsPdfRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetQuoteAsPdf")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Quotes/{QuoteID}/pdf"
	localVarPath = strings.Replace(localVarPath, "{"+"QuoteID"+"}", url.PathEscape(parameterValueToString(r.quoteID, "quoteID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/pdf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetQuoteAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	quoteID string
	fileName string
	contentType *string
}

// Xero identifier for Tenant
func (r ApiGetQuoteAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiGetQuoteAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
func (r ApiGetQuoteAttachmentByFileNameRequest) ContentType(contentType string) ApiGetQuoteAttachmentByFileNameRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetQuoteAttachmentByFileNameRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetQuoteAttachmentByFileNameExecute(r)
}

/*
GetQuoteAttachmentByFileName Retrieves a specific attachment from a specific quote by filename

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param quoteID Unique identifier for an Quote
 @param fileName Name of the attachment
 @return ApiGetQuoteAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) GetQuoteAttachmentByFileName(ctx context.Context, quoteID string, fileName string) ApiGetQuoteAttachmentByFileNameRequest {
	return ApiGetQuoteAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		quoteID: quoteID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetQuoteAttachmentByFileNameExecute(r ApiGetQuoteAttachmentByFileNameRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetQuoteAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Quotes/{QuoteID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"QuoteID"+"}", url.PathEscape(parameterValueToString(r.quoteID, "quoteID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "contentType", r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetQuoteAttachmentByIdRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	quoteID string
	attachmentID string
	contentType *string
}

// Xero identifier for Tenant
func (r ApiGetQuoteAttachmentByIdRequest) XeroTenantId(xeroTenantId string) ApiGetQuoteAttachmentByIdRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
func (r ApiGetQuoteAttachmentByIdRequest) ContentType(contentType string) ApiGetQuoteAttachmentByIdRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetQuoteAttachmentByIdRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetQuoteAttachmentByIdExecute(r)
}

/*
GetQuoteAttachmentById Retrieves a specific attachment from a specific quote using a unique attachment Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param quoteID Unique identifier for an Quote
 @param attachmentID Unique identifier for Attachment object
 @return ApiGetQuoteAttachmentByIdRequest
*/
func (a *AccountingAPIService) GetQuoteAttachmentById(ctx context.Context, quoteID string, attachmentID string) ApiGetQuoteAttachmentByIdRequest {
	return ApiGetQuoteAttachmentByIdRequest{
		ApiService: a,
		ctx: ctx,
		quoteID: quoteID,
		attachmentID: attachmentID,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetQuoteAttachmentByIdExecute(r ApiGetQuoteAttachmentByIdRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetQuoteAttachmentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Quotes/{QuoteID}/Attachments/{AttachmentID}"
	localVarPath = strings.Replace(localVarPath, "{"+"QuoteID"+"}", url.PathEscape(parameterValueToString(r.quoteID, "quoteID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"AttachmentID"+"}", url.PathEscape(parameterValueToString(r.attachmentID, "attachmentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "contentType", r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetQuoteAttachmentsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	quoteID string
}

// Xero identifier for Tenant
func (r ApiGetQuoteAttachmentsRequest) XeroTenantId(xeroTenantId string) ApiGetQuoteAttachmentsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetQuoteAttachmentsRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.GetQuoteAttachmentsExecute(r)
}

/*
GetQuoteAttachments Retrieves attachments for a specific quote

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param quoteID Unique identifier for an Quote
 @return ApiGetQuoteAttachmentsRequest
*/
func (a *AccountingAPIService) GetQuoteAttachments(ctx context.Context, quoteID string) ApiGetQuoteAttachmentsRequest {
	return ApiGetQuoteAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		quoteID: quoteID,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) GetQuoteAttachmentsExecute(r ApiGetQuoteAttachmentsRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetQuoteAttachments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Quotes/{QuoteID}/Attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"QuoteID"+"}", url.PathEscape(parameterValueToString(r.quoteID, "quoteID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetQuoteHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	quoteID string
}

// Xero identifier for Tenant
func (r ApiGetQuoteHistoryRequest) XeroTenantId(xeroTenantId string) ApiGetQuoteHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetQuoteHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.GetQuoteHistoryExecute(r)
}

/*
GetQuoteHistory Retrieves history records of a specific quote

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param quoteID Unique identifier for an Quote
 @return ApiGetQuoteHistoryRequest
*/
func (a *AccountingAPIService) GetQuoteHistory(ctx context.Context, quoteID string) ApiGetQuoteHistoryRequest {
	return ApiGetQuoteHistoryRequest{
		ApiService: a,
		ctx: ctx,
		quoteID: quoteID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) GetQuoteHistoryExecute(r ApiGetQuoteHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetQuoteHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Quotes/{QuoteID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"QuoteID"+"}", url.PathEscape(parameterValueToString(r.quoteID, "quoteID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetQuotesRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	ifModifiedSince *time.Time
	dateFrom *string
	dateTo *string
	expiryDateFrom *string
	expiryDateTo *string
	contactID *string
	status *string
	page *int32
	order *string
	quoteNumber *string
}

// Xero identifier for Tenant
func (r ApiGetQuotesRequest) XeroTenantId(xeroTenantId string) ApiGetQuotesRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Only records created or modified since this timestamp will be returned
func (r ApiGetQuotesRequest) IfModifiedSince(ifModifiedSince time.Time) ApiGetQuotesRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

// Filter for quotes after a particular date
func (r ApiGetQuotesRequest) DateFrom(dateFrom string) ApiGetQuotesRequest {
	r.dateFrom = &dateFrom
	return r
}

// Filter for quotes before a particular date
func (r ApiGetQuotesRequest) DateTo(dateTo string) ApiGetQuotesRequest {
	r.dateTo = &dateTo
	return r
}

// Filter for quotes expiring after a particular date
func (r ApiGetQuotesRequest) ExpiryDateFrom(expiryDateFrom string) ApiGetQuotesRequest {
	r.expiryDateFrom = &expiryDateFrom
	return r
}

// Filter for quotes before a particular date
func (r ApiGetQuotesRequest) ExpiryDateTo(expiryDateTo string) ApiGetQuotesRequest {
	r.expiryDateTo = &expiryDateTo
	return r
}

// Filter for quotes belonging to a particular contact
func (r ApiGetQuotesRequest) ContactID(contactID string) ApiGetQuotesRequest {
	r.contactID = &contactID
	return r
}

// Filter for quotes of a particular Status
func (r ApiGetQuotesRequest) Status(status string) ApiGetQuotesRequest {
	r.status = &status
	return r
}

// e.g. page&#x3D;1 â€“ Up to 100 Quotes will be returned in a single API call with line items shown for each quote
func (r ApiGetQuotesRequest) Page(page int32) ApiGetQuotesRequest {
	r.page = &page
	return r
}

// Order by an any element
func (r ApiGetQuotesRequest) Order(order string) ApiGetQuotesRequest {
	r.order = &order
	return r
}

// Filter by quote number (e.g. GET https://.../Quotes?QuoteNumber&#x3D;QU-0001)
func (r ApiGetQuotesRequest) QuoteNumber(quoteNumber string) ApiGetQuotesRequest {
	r.quoteNumber = &quoteNumber
	return r
}

func (r ApiGetQuotesRequest) Execute() (*Quotes, *http.Response, error) {
	return r.ApiService.GetQuotesExecute(r)
}

/*
GetQuotes Retrieves sales quotes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetQuotesRequest
*/
func (a *AccountingAPIService) GetQuotes(ctx context.Context) ApiGetQuotesRequest {
	return ApiGetQuotesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Quotes
func (a *AccountingAPIService) GetQuotesExecute(r ApiGetQuotesRequest) (*Quotes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Quotes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetQuotes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Quotes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "DateFrom", r.dateFrom, "")
	}
	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "DateTo", r.dateTo, "")
	}
	if r.expiryDateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExpiryDateFrom", r.expiryDateFrom, "")
	}
	if r.expiryDateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExpiryDateTo", r.expiryDateTo, "")
	}
	if r.contactID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ContactID", r.contactID, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Status", r.status, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.quoteNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "QuoteNumber", r.quoteNumber, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReceiptRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	receiptID string
	unitdp *int32
}

// Xero identifier for Tenant
func (r ApiGetReceiptRequest) XeroTenantId(xeroTenantId string) ApiGetReceiptRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiGetReceiptRequest) Unitdp(unitdp int32) ApiGetReceiptRequest {
	r.unitdp = &unitdp
	return r
}

func (r ApiGetReceiptRequest) Execute() (*Receipts, *http.Response, error) {
	return r.ApiService.GetReceiptExecute(r)
}

/*
GetReceipt Retrieves a specific draft expense claim receipt by using a unique receipt Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param receiptID Unique identifier for a Receipt
 @return ApiGetReceiptRequest
*/
func (a *AccountingAPIService) GetReceipt(ctx context.Context, receiptID string) ApiGetReceiptRequest {
	return ApiGetReceiptRequest{
		ApiService: a,
		ctx: ctx,
		receiptID: receiptID,
	}
}

// Execute executes the request
//  @return Receipts
func (a *AccountingAPIService) GetReceiptExecute(r ApiGetReceiptRequest) (*Receipts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Receipts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetReceipt")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Receipts/{ReceiptID}"
	localVarPath = strings.Replace(localVarPath, "{"+"ReceiptID"+"}", url.PathEscape(parameterValueToString(r.receiptID, "receiptID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReceiptAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	receiptID string
	fileName string
	contentType *string
}

// Xero identifier for Tenant
func (r ApiGetReceiptAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiGetReceiptAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
func (r ApiGetReceiptAttachmentByFileNameRequest) ContentType(contentType string) ApiGetReceiptAttachmentByFileNameRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetReceiptAttachmentByFileNameRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetReceiptAttachmentByFileNameExecute(r)
}

/*
GetReceiptAttachmentByFileName Retrieves a specific attachment from a specific expense claim receipts by file name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param receiptID Unique identifier for a Receipt
 @param fileName Name of the attachment
 @return ApiGetReceiptAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) GetReceiptAttachmentByFileName(ctx context.Context, receiptID string, fileName string) ApiGetReceiptAttachmentByFileNameRequest {
	return ApiGetReceiptAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		receiptID: receiptID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetReceiptAttachmentByFileNameExecute(r ApiGetReceiptAttachmentByFileNameRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetReceiptAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Receipts/{ReceiptID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"ReceiptID"+"}", url.PathEscape(parameterValueToString(r.receiptID, "receiptID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "contentType", r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReceiptAttachmentByIdRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	receiptID string
	attachmentID string
	contentType *string
}

// Xero identifier for Tenant
func (r ApiGetReceiptAttachmentByIdRequest) XeroTenantId(xeroTenantId string) ApiGetReceiptAttachmentByIdRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
func (r ApiGetReceiptAttachmentByIdRequest) ContentType(contentType string) ApiGetReceiptAttachmentByIdRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetReceiptAttachmentByIdRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetReceiptAttachmentByIdExecute(r)
}

/*
GetReceiptAttachmentById Retrieves a specific attachments from a specific expense claim receipts by using a unique attachment Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param receiptID Unique identifier for a Receipt
 @param attachmentID Unique identifier for Attachment object
 @return ApiGetReceiptAttachmentByIdRequest
*/
func (a *AccountingAPIService) GetReceiptAttachmentById(ctx context.Context, receiptID string, attachmentID string) ApiGetReceiptAttachmentByIdRequest {
	return ApiGetReceiptAttachmentByIdRequest{
		ApiService: a,
		ctx: ctx,
		receiptID: receiptID,
		attachmentID: attachmentID,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetReceiptAttachmentByIdExecute(r ApiGetReceiptAttachmentByIdRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetReceiptAttachmentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Receipts/{ReceiptID}/Attachments/{AttachmentID}"
	localVarPath = strings.Replace(localVarPath, "{"+"ReceiptID"+"}", url.PathEscape(parameterValueToString(r.receiptID, "receiptID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"AttachmentID"+"}", url.PathEscape(parameterValueToString(r.attachmentID, "attachmentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "contentType", r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReceiptAttachmentsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	receiptID string
}

// Xero identifier for Tenant
func (r ApiGetReceiptAttachmentsRequest) XeroTenantId(xeroTenantId string) ApiGetReceiptAttachmentsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetReceiptAttachmentsRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.GetReceiptAttachmentsExecute(r)
}

/*
GetReceiptAttachments Retrieves attachments for a specific expense claim receipt

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param receiptID Unique identifier for a Receipt
 @return ApiGetReceiptAttachmentsRequest
*/
func (a *AccountingAPIService) GetReceiptAttachments(ctx context.Context, receiptID string) ApiGetReceiptAttachmentsRequest {
	return ApiGetReceiptAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		receiptID: receiptID,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) GetReceiptAttachmentsExecute(r ApiGetReceiptAttachmentsRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetReceiptAttachments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Receipts/{ReceiptID}/Attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"ReceiptID"+"}", url.PathEscape(parameterValueToString(r.receiptID, "receiptID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReceiptHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	receiptID string
}

// Xero identifier for Tenant
func (r ApiGetReceiptHistoryRequest) XeroTenantId(xeroTenantId string) ApiGetReceiptHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetReceiptHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.GetReceiptHistoryExecute(r)
}

/*
GetReceiptHistory Retrieves a history record for a specific receipt

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param receiptID Unique identifier for a Receipt
 @return ApiGetReceiptHistoryRequest
*/
func (a *AccountingAPIService) GetReceiptHistory(ctx context.Context, receiptID string) ApiGetReceiptHistoryRequest {
	return ApiGetReceiptHistoryRequest{
		ApiService: a,
		ctx: ctx,
		receiptID: receiptID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) GetReceiptHistoryExecute(r ApiGetReceiptHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetReceiptHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Receipts/{ReceiptID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"ReceiptID"+"}", url.PathEscape(parameterValueToString(r.receiptID, "receiptID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReceiptsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	ifModifiedSince *time.Time
	where *string
	order *string
	unitdp *int32
}

// Xero identifier for Tenant
func (r ApiGetReceiptsRequest) XeroTenantId(xeroTenantId string) ApiGetReceiptsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Only records created or modified since this timestamp will be returned
func (r ApiGetReceiptsRequest) IfModifiedSince(ifModifiedSince time.Time) ApiGetReceiptsRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

// Filter by an any element
func (r ApiGetReceiptsRequest) Where(where string) ApiGetReceiptsRequest {
	r.where = &where
	return r
}

// Order by an any element
func (r ApiGetReceiptsRequest) Order(order string) ApiGetReceiptsRequest {
	r.order = &order
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiGetReceiptsRequest) Unitdp(unitdp int32) ApiGetReceiptsRequest {
	r.unitdp = &unitdp
	return r
}

func (r ApiGetReceiptsRequest) Execute() (*Receipts, *http.Response, error) {
	return r.ApiService.GetReceiptsExecute(r)
}

/*
GetReceipts Retrieves draft expense claim receipts for any user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetReceiptsRequest
*/
func (a *AccountingAPIService) GetReceipts(ctx context.Context) ApiGetReceiptsRequest {
	return ApiGetReceiptsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Receipts
func (a *AccountingAPIService) GetReceiptsExecute(r ApiGetReceiptsRequest) (*Receipts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Receipts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetReceipts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Receipts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepeatingInvoiceRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	repeatingInvoiceID string
}

// Xero identifier for Tenant
func (r ApiGetRepeatingInvoiceRequest) XeroTenantId(xeroTenantId string) ApiGetRepeatingInvoiceRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetRepeatingInvoiceRequest) Execute() (*RepeatingInvoices, *http.Response, error) {
	return r.ApiService.GetRepeatingInvoiceExecute(r)
}

/*
GetRepeatingInvoice Retrieves a specific repeating invoice by using a unique repeating invoice Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repeatingInvoiceID Unique identifier for a Repeating Invoice
 @return ApiGetRepeatingInvoiceRequest
*/
func (a *AccountingAPIService) GetRepeatingInvoice(ctx context.Context, repeatingInvoiceID string) ApiGetRepeatingInvoiceRequest {
	return ApiGetRepeatingInvoiceRequest{
		ApiService: a,
		ctx: ctx,
		repeatingInvoiceID: repeatingInvoiceID,
	}
}

// Execute executes the request
//  @return RepeatingInvoices
func (a *AccountingAPIService) GetRepeatingInvoiceExecute(r ApiGetRepeatingInvoiceRequest) (*RepeatingInvoices, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RepeatingInvoices
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetRepeatingInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/RepeatingInvoices/{RepeatingInvoiceID}"
	localVarPath = strings.Replace(localVarPath, "{"+"RepeatingInvoiceID"+"}", url.PathEscape(parameterValueToString(r.repeatingInvoiceID, "repeatingInvoiceID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepeatingInvoiceAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	repeatingInvoiceID string
	fileName string
	contentType *string
}

// Xero identifier for Tenant
func (r ApiGetRepeatingInvoiceAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiGetRepeatingInvoiceAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
func (r ApiGetRepeatingInvoiceAttachmentByFileNameRequest) ContentType(contentType string) ApiGetRepeatingInvoiceAttachmentByFileNameRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetRepeatingInvoiceAttachmentByFileNameRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetRepeatingInvoiceAttachmentByFileNameExecute(r)
}

/*
GetRepeatingInvoiceAttachmentByFileName Retrieves a specific attachment from a specific repeating invoices by file name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repeatingInvoiceID Unique identifier for a Repeating Invoice
 @param fileName Name of the attachment
 @return ApiGetRepeatingInvoiceAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) GetRepeatingInvoiceAttachmentByFileName(ctx context.Context, repeatingInvoiceID string, fileName string) ApiGetRepeatingInvoiceAttachmentByFileNameRequest {
	return ApiGetRepeatingInvoiceAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		repeatingInvoiceID: repeatingInvoiceID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetRepeatingInvoiceAttachmentByFileNameExecute(r ApiGetRepeatingInvoiceAttachmentByFileNameRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetRepeatingInvoiceAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"RepeatingInvoiceID"+"}", url.PathEscape(parameterValueToString(r.repeatingInvoiceID, "repeatingInvoiceID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "contentType", r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepeatingInvoiceAttachmentByIdRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	repeatingInvoiceID string
	attachmentID string
	contentType *string
}

// Xero identifier for Tenant
func (r ApiGetRepeatingInvoiceAttachmentByIdRequest) XeroTenantId(xeroTenantId string) ApiGetRepeatingInvoiceAttachmentByIdRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
func (r ApiGetRepeatingInvoiceAttachmentByIdRequest) ContentType(contentType string) ApiGetRepeatingInvoiceAttachmentByIdRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetRepeatingInvoiceAttachmentByIdRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetRepeatingInvoiceAttachmentByIdExecute(r)
}

/*
GetRepeatingInvoiceAttachmentById Retrieves a specific attachment from a specific repeating invoice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repeatingInvoiceID Unique identifier for a Repeating Invoice
 @param attachmentID Unique identifier for Attachment object
 @return ApiGetRepeatingInvoiceAttachmentByIdRequest
*/
func (a *AccountingAPIService) GetRepeatingInvoiceAttachmentById(ctx context.Context, repeatingInvoiceID string, attachmentID string) ApiGetRepeatingInvoiceAttachmentByIdRequest {
	return ApiGetRepeatingInvoiceAttachmentByIdRequest{
		ApiService: a,
		ctx: ctx,
		repeatingInvoiceID: repeatingInvoiceID,
		attachmentID: attachmentID,
	}
}

// Execute executes the request
//  @return *os.File
func (a *AccountingAPIService) GetRepeatingInvoiceAttachmentByIdExecute(r ApiGetRepeatingInvoiceAttachmentByIdRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetRepeatingInvoiceAttachmentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{AttachmentID}"
	localVarPath = strings.Replace(localVarPath, "{"+"RepeatingInvoiceID"+"}", url.PathEscape(parameterValueToString(r.repeatingInvoiceID, "repeatingInvoiceID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"AttachmentID"+"}", url.PathEscape(parameterValueToString(r.attachmentID, "attachmentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "contentType", r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepeatingInvoiceAttachmentsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	repeatingInvoiceID string
}

// Xero identifier for Tenant
func (r ApiGetRepeatingInvoiceAttachmentsRequest) XeroTenantId(xeroTenantId string) ApiGetRepeatingInvoiceAttachmentsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetRepeatingInvoiceAttachmentsRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.GetRepeatingInvoiceAttachmentsExecute(r)
}

/*
GetRepeatingInvoiceAttachments Retrieves attachments from a specific repeating invoice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repeatingInvoiceID Unique identifier for a Repeating Invoice
 @return ApiGetRepeatingInvoiceAttachmentsRequest
*/
func (a *AccountingAPIService) GetRepeatingInvoiceAttachments(ctx context.Context, repeatingInvoiceID string) ApiGetRepeatingInvoiceAttachmentsRequest {
	return ApiGetRepeatingInvoiceAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
		repeatingInvoiceID: repeatingInvoiceID,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) GetRepeatingInvoiceAttachmentsExecute(r ApiGetRepeatingInvoiceAttachmentsRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetRepeatingInvoiceAttachments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/RepeatingInvoices/{RepeatingInvoiceID}/Attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"RepeatingInvoiceID"+"}", url.PathEscape(parameterValueToString(r.repeatingInvoiceID, "repeatingInvoiceID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepeatingInvoiceHistoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	repeatingInvoiceID string
}

// Xero identifier for Tenant
func (r ApiGetRepeatingInvoiceHistoryRequest) XeroTenantId(xeroTenantId string) ApiGetRepeatingInvoiceHistoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetRepeatingInvoiceHistoryRequest) Execute() (*HistoryRecords, *http.Response, error) {
	return r.ApiService.GetRepeatingInvoiceHistoryExecute(r)
}

/*
GetRepeatingInvoiceHistory Retrieves history record for a specific repeating invoice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repeatingInvoiceID Unique identifier for a Repeating Invoice
 @return ApiGetRepeatingInvoiceHistoryRequest
*/
func (a *AccountingAPIService) GetRepeatingInvoiceHistory(ctx context.Context, repeatingInvoiceID string) ApiGetRepeatingInvoiceHistoryRequest {
	return ApiGetRepeatingInvoiceHistoryRequest{
		ApiService: a,
		ctx: ctx,
		repeatingInvoiceID: repeatingInvoiceID,
	}
}

// Execute executes the request
//  @return HistoryRecords
func (a *AccountingAPIService) GetRepeatingInvoiceHistoryExecute(r ApiGetRepeatingInvoiceHistoryRequest) (*HistoryRecords, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryRecords
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetRepeatingInvoiceHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/RepeatingInvoices/{RepeatingInvoiceID}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"RepeatingInvoiceID"+"}", url.PathEscape(parameterValueToString(r.repeatingInvoiceID, "repeatingInvoiceID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepeatingInvoicesRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	where *string
	order *string
}

// Xero identifier for Tenant
func (r ApiGetRepeatingInvoicesRequest) XeroTenantId(xeroTenantId string) ApiGetRepeatingInvoicesRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Filter by an any element
func (r ApiGetRepeatingInvoicesRequest) Where(where string) ApiGetRepeatingInvoicesRequest {
	r.where = &where
	return r
}

// Order by an any element
func (r ApiGetRepeatingInvoicesRequest) Order(order string) ApiGetRepeatingInvoicesRequest {
	r.order = &order
	return r
}

func (r ApiGetRepeatingInvoicesRequest) Execute() (*RepeatingInvoices, *http.Response, error) {
	return r.ApiService.GetRepeatingInvoicesExecute(r)
}

/*
GetRepeatingInvoices Retrieves repeating invoices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRepeatingInvoicesRequest
*/
func (a *AccountingAPIService) GetRepeatingInvoices(ctx context.Context) ApiGetRepeatingInvoicesRequest {
	return ApiGetRepeatingInvoicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RepeatingInvoices
func (a *AccountingAPIService) GetRepeatingInvoicesExecute(r ApiGetRepeatingInvoicesRequest) (*RepeatingInvoices, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RepeatingInvoices
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetRepeatingInvoices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/RepeatingInvoices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReportAgedPayablesByContactRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	contactId *string
	date *string
	fromDate *string
	toDate *string
}

// Xero identifier for Tenant
func (r ApiGetReportAgedPayablesByContactRequest) XeroTenantId(xeroTenantId string) ApiGetReportAgedPayablesByContactRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Unique identifier for a Contact
func (r ApiGetReportAgedPayablesByContactRequest) ContactId(contactId string) ApiGetReportAgedPayablesByContactRequest {
	r.contactId = &contactId
	return r
}

// The date of the Aged Payables By Contact report
func (r ApiGetReportAgedPayablesByContactRequest) Date(date string) ApiGetReportAgedPayablesByContactRequest {
	r.date = &date
	return r
}

// filter by the from date of the report e.g. 2021-02-01
func (r ApiGetReportAgedPayablesByContactRequest) FromDate(fromDate string) ApiGetReportAgedPayablesByContactRequest {
	r.fromDate = &fromDate
	return r
}

// filter by the to date of the report e.g. 2021-02-28
func (r ApiGetReportAgedPayablesByContactRequest) ToDate(toDate string) ApiGetReportAgedPayablesByContactRequest {
	r.toDate = &toDate
	return r
}

func (r ApiGetReportAgedPayablesByContactRequest) Execute() (*ReportWithRows, *http.Response, error) {
	return r.ApiService.GetReportAgedPayablesByContactExecute(r)
}

/*
GetReportAgedPayablesByContact Retrieves report for aged payables by contact

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetReportAgedPayablesByContactRequest
*/
func (a *AccountingAPIService) GetReportAgedPayablesByContact(ctx context.Context) ApiGetReportAgedPayablesByContactRequest {
	return ApiGetReportAgedPayablesByContactRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReportWithRows
func (a *AccountingAPIService) GetReportAgedPayablesByContactExecute(r ApiGetReportAgedPayablesByContactRequest) (*ReportWithRows, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReportWithRows
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetReportAgedPayablesByContact")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Reports/AgedPayablesByContact"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contactId == nil {
		return localVarReturnValue, nil, reportError("contactId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "contactId", r.contactId, "")
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromDate", r.fromDate, "")
	}
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toDate", r.toDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReportAgedReceivablesByContactRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	contactId *string
	date *string
	fromDate *string
	toDate *string
}

// Xero identifier for Tenant
func (r ApiGetReportAgedReceivablesByContactRequest) XeroTenantId(xeroTenantId string) ApiGetReportAgedReceivablesByContactRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Unique identifier for a Contact
func (r ApiGetReportAgedReceivablesByContactRequest) ContactId(contactId string) ApiGetReportAgedReceivablesByContactRequest {
	r.contactId = &contactId
	return r
}

// The date of the Aged Receivables By Contact report
func (r ApiGetReportAgedReceivablesByContactRequest) Date(date string) ApiGetReportAgedReceivablesByContactRequest {
	r.date = &date
	return r
}

// filter by the from date of the report e.g. 2021-02-01
func (r ApiGetReportAgedReceivablesByContactRequest) FromDate(fromDate string) ApiGetReportAgedReceivablesByContactRequest {
	r.fromDate = &fromDate
	return r
}

// filter by the to date of the report e.g. 2021-02-28
func (r ApiGetReportAgedReceivablesByContactRequest) ToDate(toDate string) ApiGetReportAgedReceivablesByContactRequest {
	r.toDate = &toDate
	return r
}

func (r ApiGetReportAgedReceivablesByContactRequest) Execute() (*ReportWithRows, *http.Response, error) {
	return r.ApiService.GetReportAgedReceivablesByContactExecute(r)
}

/*
GetReportAgedReceivablesByContact Retrieves report for aged receivables by contact

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetReportAgedReceivablesByContactRequest
*/
func (a *AccountingAPIService) GetReportAgedReceivablesByContact(ctx context.Context) ApiGetReportAgedReceivablesByContactRequest {
	return ApiGetReportAgedReceivablesByContactRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReportWithRows
func (a *AccountingAPIService) GetReportAgedReceivablesByContactExecute(r ApiGetReportAgedReceivablesByContactRequest) (*ReportWithRows, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReportWithRows
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetReportAgedReceivablesByContact")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Reports/AgedReceivablesByContact"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contactId == nil {
		return localVarReturnValue, nil, reportError("contactId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "contactId", r.contactId, "")
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromDate", r.fromDate, "")
	}
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toDate", r.toDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReportBalanceSheetRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	date *string
	periods *int32
	timeframe *string
	trackingOptionID1 *string
	trackingOptionID2 *string
	standardLayout *bool
	paymentsOnly *bool
}

// Xero identifier for Tenant
func (r ApiGetReportBalanceSheetRequest) XeroTenantId(xeroTenantId string) ApiGetReportBalanceSheetRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The date of the Balance Sheet report
func (r ApiGetReportBalanceSheetRequest) Date(date string) ApiGetReportBalanceSheetRequest {
	r.date = &date
	return r
}

// The number of periods for the Balance Sheet report
func (r ApiGetReportBalanceSheetRequest) Periods(periods int32) ApiGetReportBalanceSheetRequest {
	r.periods = &periods
	return r
}

// The period size to compare to (MONTH, QUARTER, YEAR)
func (r ApiGetReportBalanceSheetRequest) Timeframe(timeframe string) ApiGetReportBalanceSheetRequest {
	r.timeframe = &timeframe
	return r
}

// The tracking option 1 for the Balance Sheet report
func (r ApiGetReportBalanceSheetRequest) TrackingOptionID1(trackingOptionID1 string) ApiGetReportBalanceSheetRequest {
	r.trackingOptionID1 = &trackingOptionID1
	return r
}

// The tracking option 2 for the Balance Sheet report
func (r ApiGetReportBalanceSheetRequest) TrackingOptionID2(trackingOptionID2 string) ApiGetReportBalanceSheetRequest {
	r.trackingOptionID2 = &trackingOptionID2
	return r
}

// The standard layout boolean for the Balance Sheet report
func (r ApiGetReportBalanceSheetRequest) StandardLayout(standardLayout bool) ApiGetReportBalanceSheetRequest {
	r.standardLayout = &standardLayout
	return r
}

// return a cash basis for the Balance Sheet report
func (r ApiGetReportBalanceSheetRequest) PaymentsOnly(paymentsOnly bool) ApiGetReportBalanceSheetRequest {
	r.paymentsOnly = &paymentsOnly
	return r
}

func (r ApiGetReportBalanceSheetRequest) Execute() (*ReportWithRows, *http.Response, error) {
	return r.ApiService.GetReportBalanceSheetExecute(r)
}

/*
GetReportBalanceSheet Retrieves report for balancesheet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetReportBalanceSheetRequest
*/
func (a *AccountingAPIService) GetReportBalanceSheet(ctx context.Context) ApiGetReportBalanceSheetRequest {
	return ApiGetReportBalanceSheetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReportWithRows
func (a *AccountingAPIService) GetReportBalanceSheetExecute(r ApiGetReportBalanceSheetRequest) (*ReportWithRows, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReportWithRows
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetReportBalanceSheet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Reports/BalanceSheet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.periods != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "periods", r.periods, "")
	}
	if r.timeframe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeframe", r.timeframe, "")
	}
	if r.trackingOptionID1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trackingOptionID1", r.trackingOptionID1, "")
	}
	if r.trackingOptionID2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trackingOptionID2", r.trackingOptionID2, "")
	}
	if r.standardLayout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "standardLayout", r.standardLayout, "")
	}
	if r.paymentsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentsOnly", r.paymentsOnly, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReportBankSummaryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	fromDate *string
	toDate *string
}

// Xero identifier for Tenant
func (r ApiGetReportBankSummaryRequest) XeroTenantId(xeroTenantId string) ApiGetReportBankSummaryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// filter by the from date of the report e.g. 2021-02-01
func (r ApiGetReportBankSummaryRequest) FromDate(fromDate string) ApiGetReportBankSummaryRequest {
	r.fromDate = &fromDate
	return r
}

// filter by the to date of the report e.g. 2021-02-28
func (r ApiGetReportBankSummaryRequest) ToDate(toDate string) ApiGetReportBankSummaryRequest {
	r.toDate = &toDate
	return r
}

func (r ApiGetReportBankSummaryRequest) Execute() (*ReportWithRows, *http.Response, error) {
	return r.ApiService.GetReportBankSummaryExecute(r)
}

/*
GetReportBankSummary Retrieves report for bank summary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetReportBankSummaryRequest
*/
func (a *AccountingAPIService) GetReportBankSummary(ctx context.Context) ApiGetReportBankSummaryRequest {
	return ApiGetReportBankSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReportWithRows
func (a *AccountingAPIService) GetReportBankSummaryExecute(r ApiGetReportBankSummaryRequest) (*ReportWithRows, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReportWithRows
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetReportBankSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Reports/BankSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromDate", r.fromDate, "")
	}
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toDate", r.toDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReportBudgetSummaryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	date *string
	periods *int32
	timeframe *int32
}

// Xero identifier for Tenant
func (r ApiGetReportBudgetSummaryRequest) XeroTenantId(xeroTenantId string) ApiGetReportBudgetSummaryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The date for the Bank Summary report e.g. 2018-03-31
func (r ApiGetReportBudgetSummaryRequest) Date(date string) ApiGetReportBudgetSummaryRequest {
	r.date = &date
	return r
}

// The number of periods to compare (integer between 1 and 12)
func (r ApiGetReportBudgetSummaryRequest) Periods(periods int32) ApiGetReportBudgetSummaryRequest {
	r.periods = &periods
	return r
}

// The period size to compare to (1&#x3D;month, 3&#x3D;quarter, 12&#x3D;year)
func (r ApiGetReportBudgetSummaryRequest) Timeframe(timeframe int32) ApiGetReportBudgetSummaryRequest {
	r.timeframe = &timeframe
	return r
}

func (r ApiGetReportBudgetSummaryRequest) Execute() (*ReportWithRows, *http.Response, error) {
	return r.ApiService.GetReportBudgetSummaryExecute(r)
}

/*
GetReportBudgetSummary Retrieves report for budget summary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetReportBudgetSummaryRequest
*/
func (a *AccountingAPIService) GetReportBudgetSummary(ctx context.Context) ApiGetReportBudgetSummaryRequest {
	return ApiGetReportBudgetSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReportWithRows
func (a *AccountingAPIService) GetReportBudgetSummaryExecute(r ApiGetReportBudgetSummaryRequest) (*ReportWithRows, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReportWithRows
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetReportBudgetSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Reports/BudgetSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.periods != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "periods", r.periods, "")
	}
	if r.timeframe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeframe", r.timeframe, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReportExecutiveSummaryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	date *string
}

// Xero identifier for Tenant
func (r ApiGetReportExecutiveSummaryRequest) XeroTenantId(xeroTenantId string) ApiGetReportExecutiveSummaryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The date for the Bank Summary report e.g. 2018-03-31
func (r ApiGetReportExecutiveSummaryRequest) Date(date string) ApiGetReportExecutiveSummaryRequest {
	r.date = &date
	return r
}

func (r ApiGetReportExecutiveSummaryRequest) Execute() (*ReportWithRows, *http.Response, error) {
	return r.ApiService.GetReportExecutiveSummaryExecute(r)
}

/*
GetReportExecutiveSummary Retrieves report for executive summary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetReportExecutiveSummaryRequest
*/
func (a *AccountingAPIService) GetReportExecutiveSummary(ctx context.Context) ApiGetReportExecutiveSummaryRequest {
	return ApiGetReportExecutiveSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReportWithRows
func (a *AccountingAPIService) GetReportExecutiveSummaryExecute(r ApiGetReportExecutiveSummaryRequest) (*ReportWithRows, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReportWithRows
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetReportExecutiveSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Reports/ExecutiveSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReportFromIdRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	reportID string
}

// Xero identifier for Tenant
func (r ApiGetReportFromIdRequest) XeroTenantId(xeroTenantId string) ApiGetReportFromIdRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetReportFromIdRequest) Execute() (*ReportWithRows, *http.Response, error) {
	return r.ApiService.GetReportFromIdExecute(r)
}

/*
GetReportFromId Retrieves a specific report using a unique ReportID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reportID Unique identifier for a Report
 @return ApiGetReportFromIdRequest
*/
func (a *AccountingAPIService) GetReportFromId(ctx context.Context, reportID string) ApiGetReportFromIdRequest {
	return ApiGetReportFromIdRequest{
		ApiService: a,
		ctx: ctx,
		reportID: reportID,
	}
}

// Execute executes the request
//  @return ReportWithRows
func (a *AccountingAPIService) GetReportFromIdExecute(r ApiGetReportFromIdRequest) (*ReportWithRows, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReportWithRows
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetReportFromId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Reports/{ReportID}"
	localVarPath = strings.Replace(localVarPath, "{"+"ReportID"+"}", url.PathEscape(parameterValueToString(r.reportID, "reportID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReportProfitAndLossRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	fromDate *string
	toDate *string
	periods *int32
	timeframe *string
	trackingCategoryID *string
	trackingCategoryID2 *string
	trackingOptionID *string
	trackingOptionID2 *string
	standardLayout *bool
	paymentsOnly *bool
}

// Xero identifier for Tenant
func (r ApiGetReportProfitAndLossRequest) XeroTenantId(xeroTenantId string) ApiGetReportProfitAndLossRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// filter by the from date of the report e.g. 2021-02-01
func (r ApiGetReportProfitAndLossRequest) FromDate(fromDate string) ApiGetReportProfitAndLossRequest {
	r.fromDate = &fromDate
	return r
}

// filter by the to date of the report e.g. 2021-02-28
func (r ApiGetReportProfitAndLossRequest) ToDate(toDate string) ApiGetReportProfitAndLossRequest {
	r.toDate = &toDate
	return r
}

// The number of periods to compare (integer between 1 and 12)
func (r ApiGetReportProfitAndLossRequest) Periods(periods int32) ApiGetReportProfitAndLossRequest {
	r.periods = &periods
	return r
}

// The period size to compare to (MONTH, QUARTER, YEAR)
func (r ApiGetReportProfitAndLossRequest) Timeframe(timeframe string) ApiGetReportProfitAndLossRequest {
	r.timeframe = &timeframe
	return r
}

// The trackingCategory 1 for the ProfitAndLoss report
func (r ApiGetReportProfitAndLossRequest) TrackingCategoryID(trackingCategoryID string) ApiGetReportProfitAndLossRequest {
	r.trackingCategoryID = &trackingCategoryID
	return r
}

// The trackingCategory 2 for the ProfitAndLoss report
func (r ApiGetReportProfitAndLossRequest) TrackingCategoryID2(trackingCategoryID2 string) ApiGetReportProfitAndLossRequest {
	r.trackingCategoryID2 = &trackingCategoryID2
	return r
}

// The tracking option 1 for the ProfitAndLoss report
func (r ApiGetReportProfitAndLossRequest) TrackingOptionID(trackingOptionID string) ApiGetReportProfitAndLossRequest {
	r.trackingOptionID = &trackingOptionID
	return r
}

// The tracking option 2 for the ProfitAndLoss report
func (r ApiGetReportProfitAndLossRequest) TrackingOptionID2(trackingOptionID2 string) ApiGetReportProfitAndLossRequest {
	r.trackingOptionID2 = &trackingOptionID2
	return r
}

// Return the standard layout for the ProfitAndLoss report
func (r ApiGetReportProfitAndLossRequest) StandardLayout(standardLayout bool) ApiGetReportProfitAndLossRequest {
	r.standardLayout = &standardLayout
	return r
}

// Return cash only basis for the ProfitAndLoss report
func (r ApiGetReportProfitAndLossRequest) PaymentsOnly(paymentsOnly bool) ApiGetReportProfitAndLossRequest {
	r.paymentsOnly = &paymentsOnly
	return r
}

func (r ApiGetReportProfitAndLossRequest) Execute() (*ReportWithRows, *http.Response, error) {
	return r.ApiService.GetReportProfitAndLossExecute(r)
}

/*
GetReportProfitAndLoss Retrieves report for profit and loss

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetReportProfitAndLossRequest
*/
func (a *AccountingAPIService) GetReportProfitAndLoss(ctx context.Context) ApiGetReportProfitAndLossRequest {
	return ApiGetReportProfitAndLossRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReportWithRows
func (a *AccountingAPIService) GetReportProfitAndLossExecute(r ApiGetReportProfitAndLossRequest) (*ReportWithRows, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReportWithRows
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetReportProfitAndLoss")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Reports/ProfitAndLoss"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromDate", r.fromDate, "")
	}
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toDate", r.toDate, "")
	}
	if r.periods != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "periods", r.periods, "")
	}
	if r.timeframe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeframe", r.timeframe, "")
	}
	if r.trackingCategoryID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trackingCategoryID", r.trackingCategoryID, "")
	}
	if r.trackingCategoryID2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trackingCategoryID2", r.trackingCategoryID2, "")
	}
	if r.trackingOptionID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trackingOptionID", r.trackingOptionID, "")
	}
	if r.trackingOptionID2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "trackingOptionID2", r.trackingOptionID2, "")
	}
	if r.standardLayout != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "standardLayout", r.standardLayout, "")
	}
	if r.paymentsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentsOnly", r.paymentsOnly, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReportTenNinetyNineRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	reportYear *string
}

// Xero identifier for Tenant
func (r ApiGetReportTenNinetyNineRequest) XeroTenantId(xeroTenantId string) ApiGetReportTenNinetyNineRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The year of the 1099 report
func (r ApiGetReportTenNinetyNineRequest) ReportYear(reportYear string) ApiGetReportTenNinetyNineRequest {
	r.reportYear = &reportYear
	return r
}

func (r ApiGetReportTenNinetyNineRequest) Execute() (*Reports, *http.Response, error) {
	return r.ApiService.GetReportTenNinetyNineExecute(r)
}

/*
GetReportTenNinetyNine Retrieve reports for 1099

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetReportTenNinetyNineRequest
*/
func (a *AccountingAPIService) GetReportTenNinetyNine(ctx context.Context) ApiGetReportTenNinetyNineRequest {
	return ApiGetReportTenNinetyNineRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Reports
func (a *AccountingAPIService) GetReportTenNinetyNineExecute(r ApiGetReportTenNinetyNineRequest) (*Reports, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Reports
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetReportTenNinetyNine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Reports/TenNinetyNine"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.reportYear != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reportYear", r.reportYear, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReportTrialBalanceRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	date *string
	paymentsOnly *bool
}

// Xero identifier for Tenant
func (r ApiGetReportTrialBalanceRequest) XeroTenantId(xeroTenantId string) ApiGetReportTrialBalanceRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// The date for the Trial Balance report e.g. 2018-03-31
func (r ApiGetReportTrialBalanceRequest) Date(date string) ApiGetReportTrialBalanceRequest {
	r.date = &date
	return r
}

// Return cash only basis for the Trial Balance report
func (r ApiGetReportTrialBalanceRequest) PaymentsOnly(paymentsOnly bool) ApiGetReportTrialBalanceRequest {
	r.paymentsOnly = &paymentsOnly
	return r
}

func (r ApiGetReportTrialBalanceRequest) Execute() (*ReportWithRows, *http.Response, error) {
	return r.ApiService.GetReportTrialBalanceExecute(r)
}

/*
GetReportTrialBalance Retrieves report for trial balance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetReportTrialBalanceRequest
*/
func (a *AccountingAPIService) GetReportTrialBalance(ctx context.Context) ApiGetReportTrialBalanceRequest {
	return ApiGetReportTrialBalanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReportWithRows
func (a *AccountingAPIService) GetReportTrialBalanceExecute(r ApiGetReportTrialBalanceRequest) (*ReportWithRows, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReportWithRows
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetReportTrialBalance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Reports/TrialBalance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.paymentsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentsOnly", r.paymentsOnly, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReportsListRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
}

// Xero identifier for Tenant
func (r ApiGetReportsListRequest) XeroTenantId(xeroTenantId string) ApiGetReportsListRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetReportsListRequest) Execute() (*ReportWithRows, *http.Response, error) {
	return r.ApiService.GetReportsListExecute(r)
}

/*
GetReportsList Retrieves a list of the organistaions unique reports that require a uuid to fetch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetReportsListRequest
*/
func (a *AccountingAPIService) GetReportsList(ctx context.Context) ApiGetReportsListRequest {
	return ApiGetReportsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReportWithRows
func (a *AccountingAPIService) GetReportsListExecute(r ApiGetReportsListRequest) (*ReportWithRows, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReportWithRows
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetReportsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Reports"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTaxRatesRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	where *string
	order *string
	taxType *string
}

// Xero identifier for Tenant
func (r ApiGetTaxRatesRequest) XeroTenantId(xeroTenantId string) ApiGetTaxRatesRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Filter by an any element
func (r ApiGetTaxRatesRequest) Where(where string) ApiGetTaxRatesRequest {
	r.where = &where
	return r
}

// Order by an any element
func (r ApiGetTaxRatesRequest) Order(order string) ApiGetTaxRatesRequest {
	r.order = &order
	return r
}

// Filter by tax type
func (r ApiGetTaxRatesRequest) TaxType(taxType string) ApiGetTaxRatesRequest {
	r.taxType = &taxType
	return r
}

func (r ApiGetTaxRatesRequest) Execute() (*TaxRates, *http.Response, error) {
	return r.ApiService.GetTaxRatesExecute(r)
}

/*
GetTaxRates Retrieves tax rates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTaxRatesRequest
*/
func (a *AccountingAPIService) GetTaxRates(ctx context.Context) ApiGetTaxRatesRequest {
	return ApiGetTaxRatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TaxRates
func (a *AccountingAPIService) GetTaxRatesExecute(r ApiGetTaxRatesRequest) (*TaxRates, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaxRates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetTaxRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/TaxRates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.taxType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "TaxType", r.taxType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTrackingCategoriesRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	where *string
	order *string
	includeArchived *bool
}

// Xero identifier for Tenant
func (r ApiGetTrackingCategoriesRequest) XeroTenantId(xeroTenantId string) ApiGetTrackingCategoriesRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Filter by an any element
func (r ApiGetTrackingCategoriesRequest) Where(where string) ApiGetTrackingCategoriesRequest {
	r.where = &where
	return r
}

// Order by an any element
func (r ApiGetTrackingCategoriesRequest) Order(order string) ApiGetTrackingCategoriesRequest {
	r.order = &order
	return r
}

// e.g. includeArchived&#x3D;true - Categories and options with a status of ARCHIVED will be included in the response
func (r ApiGetTrackingCategoriesRequest) IncludeArchived(includeArchived bool) ApiGetTrackingCategoriesRequest {
	r.includeArchived = &includeArchived
	return r
}

func (r ApiGetTrackingCategoriesRequest) Execute() (*TrackingCategories, *http.Response, error) {
	return r.ApiService.GetTrackingCategoriesExecute(r)
}

/*
GetTrackingCategories Retrieves tracking categories and options

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTrackingCategoriesRequest
*/
func (a *AccountingAPIService) GetTrackingCategories(ctx context.Context) ApiGetTrackingCategoriesRequest {
	return ApiGetTrackingCategoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TrackingCategories
func (a *AccountingAPIService) GetTrackingCategoriesExecute(r ApiGetTrackingCategoriesRequest) (*TrackingCategories, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrackingCategories
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetTrackingCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/TrackingCategories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.includeArchived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeArchived", r.includeArchived, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTrackingCategoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	trackingCategoryID string
}

// Xero identifier for Tenant
func (r ApiGetTrackingCategoryRequest) XeroTenantId(xeroTenantId string) ApiGetTrackingCategoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetTrackingCategoryRequest) Execute() (*TrackingCategories, *http.Response, error) {
	return r.ApiService.GetTrackingCategoryExecute(r)
}

/*
GetTrackingCategory Retrieves specific tracking categories and options using a unique tracking category Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trackingCategoryID Unique identifier for a TrackingCategory
 @return ApiGetTrackingCategoryRequest
*/
func (a *AccountingAPIService) GetTrackingCategory(ctx context.Context, trackingCategoryID string) ApiGetTrackingCategoryRequest {
	return ApiGetTrackingCategoryRequest{
		ApiService: a,
		ctx: ctx,
		trackingCategoryID: trackingCategoryID,
	}
}

// Execute executes the request
//  @return TrackingCategories
func (a *AccountingAPIService) GetTrackingCategoryExecute(r ApiGetTrackingCategoryRequest) (*TrackingCategories, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrackingCategories
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetTrackingCategory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/TrackingCategories/{TrackingCategoryID}"
	localVarPath = strings.Replace(localVarPath, "{"+"TrackingCategoryID"+"}", url.PathEscape(parameterValueToString(r.trackingCategoryID, "trackingCategoryID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	userID string
}

// Xero identifier for Tenant
func (r ApiGetUserRequest) XeroTenantId(xeroTenantId string) ApiGetUserRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiGetUserRequest) Execute() (*Users, *http.Response, error) {
	return r.ApiService.GetUserExecute(r)
}

/*
GetUser Retrieves a specific user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userID Unique identifier for a User
 @return ApiGetUserRequest
*/
func (a *AccountingAPIService) GetUser(ctx context.Context, userID string) ApiGetUserRequest {
	return ApiGetUserRequest{
		ApiService: a,
		ctx: ctx,
		userID: userID,
	}
}

// Execute executes the request
//  @return Users
func (a *AccountingAPIService) GetUserExecute(r ApiGetUserRequest) (*Users, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Users
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users/{UserID}"
	localVarPath = strings.Replace(localVarPath, "{"+"UserID"+"}", url.PathEscape(parameterValueToString(r.userID, "userID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsersRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	ifModifiedSince *time.Time
	where *string
	order *string
}

// Xero identifier for Tenant
func (r ApiGetUsersRequest) XeroTenantId(xeroTenantId string) ApiGetUsersRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Only records created or modified since this timestamp will be returned
func (r ApiGetUsersRequest) IfModifiedSince(ifModifiedSince time.Time) ApiGetUsersRequest {
	r.ifModifiedSince = &ifModifiedSince
	return r
}

// Filter by an any element
func (r ApiGetUsersRequest) Where(where string) ApiGetUsersRequest {
	r.where = &where
	return r
}

// Order by an any element
func (r ApiGetUsersRequest) Order(order string) ApiGetUsersRequest {
	r.order = &order
	return r
}

func (r ApiGetUsersRequest) Execute() (*Users, *http.Response, error) {
	return r.ApiService.GetUsersExecute(r)
}

/*
GetUsers Retrieves users

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUsersRequest
*/
func (a *AccountingAPIService) GetUsers(ctx context.Context) ApiGetUsersRequest {
	return ApiGetUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Users
func (a *AccountingAPIService) GetUsersExecute(r ApiGetUsersRequest) (*Users, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Users
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.GetUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}

	if r.where != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "where", r.where, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.ifModifiedSince != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Modified-Since", r.ifModifiedSince, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetupRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	setup *Setup
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiPostSetupRequest) XeroTenantId(xeroTenantId string) ApiPostSetupRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Object including an accounts array, a conversion balances array and a conversion date object in body of request
func (r ApiPostSetupRequest) Setup(setup Setup) ApiPostSetupRequest {
	r.setup = &setup
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiPostSetupRequest) IdempotencyKey(idempotencyKey string) ApiPostSetupRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiPostSetupRequest) Execute() (*ImportSummaryObject, *http.Response, error) {
	return r.ApiService.PostSetupExecute(r)
}

/*
PostSetup Sets the chart of accounts, the conversion date and conversion balances

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetupRequest
*/
func (a *AccountingAPIService) PostSetup(ctx context.Context) ApiPostSetupRequest {
	return ApiPostSetupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ImportSummaryObject
func (a *AccountingAPIService) PostSetupExecute(r ApiPostSetupRequest) (*ImportSummaryObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ImportSummaryObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.PostSetup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Setup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.setup == nil {
		return localVarReturnValue, nil, reportError("setup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.setup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAccountRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	accountID string
	accounts *Accounts
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiUpdateAccountRequest) XeroTenantId(xeroTenantId string) ApiUpdateAccountRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Request of type Accounts array with one Account
func (r ApiUpdateAccountRequest) Accounts(accounts Accounts) ApiUpdateAccountRequest {
	r.accounts = &accounts
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateAccountRequest) IdempotencyKey(idempotencyKey string) ApiUpdateAccountRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiUpdateAccountRequest) Execute() (*Accounts, *http.Response, error) {
	return r.ApiService.UpdateAccountExecute(r)
}

/*
UpdateAccount Updates a chart of accounts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID Unique identifier for Account object
 @return ApiUpdateAccountRequest
*/
func (a *AccountingAPIService) UpdateAccount(ctx context.Context, accountID string) ApiUpdateAccountRequest {
	return ApiUpdateAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
	}
}

// Execute executes the request
//  @return Accounts
func (a *AccountingAPIService) UpdateAccountExecute(r ApiUpdateAccountRequest) (*Accounts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Accounts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Accounts/{AccountID}"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountID"+"}", url.PathEscape(parameterValueToString(r.accountID, "accountID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.accounts == nil {
		return localVarReturnValue, nil, reportError("accounts is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.accounts
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAccountAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	accountID string
	fileName string
	body *string
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiUpdateAccountAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiUpdateAccountAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Byte array of file in body of request
func (r ApiUpdateAccountAttachmentByFileNameRequest) Body(body string) ApiUpdateAccountAttachmentByFileNameRequest {
	r.body = &body
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateAccountAttachmentByFileNameRequest) IdempotencyKey(idempotencyKey string) ApiUpdateAccountAttachmentByFileNameRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiUpdateAccountAttachmentByFileNameRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.UpdateAccountAttachmentByFileNameExecute(r)
}

/*
UpdateAccountAttachmentByFileName Updates attachment on a specific account by filename

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID Unique identifier for Account object
 @param fileName Name of the attachment
 @return ApiUpdateAccountAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) UpdateAccountAttachmentByFileName(ctx context.Context, accountID string, fileName string) ApiUpdateAccountAttachmentByFileNameRequest {
	return ApiUpdateAccountAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) UpdateAccountAttachmentByFileNameExecute(r ApiUpdateAccountAttachmentByFileNameRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateAccountAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Accounts/{AccountID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountID"+"}", url.PathEscape(parameterValueToString(r.accountID, "accountID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBankTransactionRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	bankTransactionID string
	bankTransactions *BankTransactions
	idempotencyKey *string
	unitdp *int32
}

// Xero identifier for Tenant
func (r ApiUpdateBankTransactionRequest) XeroTenantId(xeroTenantId string) ApiUpdateBankTransactionRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiUpdateBankTransactionRequest) BankTransactions(bankTransactions BankTransactions) ApiUpdateBankTransactionRequest {
	r.bankTransactions = &bankTransactions
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateBankTransactionRequest) IdempotencyKey(idempotencyKey string) ApiUpdateBankTransactionRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiUpdateBankTransactionRequest) Unitdp(unitdp int32) ApiUpdateBankTransactionRequest {
	r.unitdp = &unitdp
	return r
}

func (r ApiUpdateBankTransactionRequest) Execute() (*BankTransactions, *http.Response, error) {
	return r.ApiService.UpdateBankTransactionExecute(r)
}

/*
UpdateBankTransaction Updates a single spent or received money transaction

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bankTransactionID Xero generated unique identifier for a bank transaction
 @return ApiUpdateBankTransactionRequest
*/
func (a *AccountingAPIService) UpdateBankTransaction(ctx context.Context, bankTransactionID string) ApiUpdateBankTransactionRequest {
	return ApiUpdateBankTransactionRequest{
		ApiService: a,
		ctx: ctx,
		bankTransactionID: bankTransactionID,
	}
}

// Execute executes the request
//  @return BankTransactions
func (a *AccountingAPIService) UpdateBankTransactionExecute(r ApiUpdateBankTransactionRequest) (*BankTransactions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BankTransactions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateBankTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BankTransactions/{BankTransactionID}"
	localVarPath = strings.Replace(localVarPath, "{"+"BankTransactionID"+"}", url.PathEscape(parameterValueToString(r.bankTransactionID, "bankTransactionID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.bankTransactions == nil {
		return localVarReturnValue, nil, reportError("bankTransactions is required and must be specified")
	}

	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.bankTransactions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBankTransactionAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	bankTransactionID string
	fileName string
	body *string
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiUpdateBankTransactionAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiUpdateBankTransactionAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Byte array of file in body of request
func (r ApiUpdateBankTransactionAttachmentByFileNameRequest) Body(body string) ApiUpdateBankTransactionAttachmentByFileNameRequest {
	r.body = &body
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateBankTransactionAttachmentByFileNameRequest) IdempotencyKey(idempotencyKey string) ApiUpdateBankTransactionAttachmentByFileNameRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiUpdateBankTransactionAttachmentByFileNameRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.UpdateBankTransactionAttachmentByFileNameExecute(r)
}

/*
UpdateBankTransactionAttachmentByFileName Updates a specific attachment from a specific bank transaction by filename

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bankTransactionID Xero generated unique identifier for a bank transaction
 @param fileName Name of the attachment
 @return ApiUpdateBankTransactionAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) UpdateBankTransactionAttachmentByFileName(ctx context.Context, bankTransactionID string, fileName string) ApiUpdateBankTransactionAttachmentByFileNameRequest {
	return ApiUpdateBankTransactionAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		bankTransactionID: bankTransactionID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) UpdateBankTransactionAttachmentByFileNameExecute(r ApiUpdateBankTransactionAttachmentByFileNameRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateBankTransactionAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BankTransactions/{BankTransactionID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"BankTransactionID"+"}", url.PathEscape(parameterValueToString(r.bankTransactionID, "bankTransactionID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBankTransferAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	bankTransferID string
	fileName string
	body *string
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiUpdateBankTransferAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiUpdateBankTransferAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Byte array of file in body of request
func (r ApiUpdateBankTransferAttachmentByFileNameRequest) Body(body string) ApiUpdateBankTransferAttachmentByFileNameRequest {
	r.body = &body
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateBankTransferAttachmentByFileNameRequest) IdempotencyKey(idempotencyKey string) ApiUpdateBankTransferAttachmentByFileNameRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiUpdateBankTransferAttachmentByFileNameRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.UpdateBankTransferAttachmentByFileNameExecute(r)
}

/*
UpdateBankTransferAttachmentByFileName Method for UpdateBankTransferAttachmentByFileName

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bankTransferID Xero generated unique identifier for a bank transfer
 @param fileName Name of the attachment
 @return ApiUpdateBankTransferAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) UpdateBankTransferAttachmentByFileName(ctx context.Context, bankTransferID string, fileName string) ApiUpdateBankTransferAttachmentByFileNameRequest {
	return ApiUpdateBankTransferAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		bankTransferID: bankTransferID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) UpdateBankTransferAttachmentByFileNameExecute(r ApiUpdateBankTransferAttachmentByFileNameRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateBankTransferAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BankTransfers/{BankTransferID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"BankTransferID"+"}", url.PathEscape(parameterValueToString(r.bankTransferID, "bankTransferID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateContactRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	contactID string
	contacts *Contacts
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiUpdateContactRequest) XeroTenantId(xeroTenantId string) ApiUpdateContactRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// an array of Contacts containing single Contact object with properties to update
func (r ApiUpdateContactRequest) Contacts(contacts Contacts) ApiUpdateContactRequest {
	r.contacts = &contacts
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateContactRequest) IdempotencyKey(idempotencyKey string) ApiUpdateContactRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiUpdateContactRequest) Execute() (*Contacts, *http.Response, error) {
	return r.ApiService.UpdateContactExecute(r)
}

/*
UpdateContact Updates a specific contact in a Xero organisation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactID Unique identifier for a Contact
 @return ApiUpdateContactRequest
*/
func (a *AccountingAPIService) UpdateContact(ctx context.Context, contactID string) ApiUpdateContactRequest {
	return ApiUpdateContactRequest{
		ApiService: a,
		ctx: ctx,
		contactID: contactID,
	}
}

// Execute executes the request
//  @return Contacts
func (a *AccountingAPIService) UpdateContactExecute(r ApiUpdateContactRequest) (*Contacts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Contacts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateContact")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Contacts/{ContactID}"
	localVarPath = strings.Replace(localVarPath, "{"+"ContactID"+"}", url.PathEscape(parameterValueToString(r.contactID, "contactID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contacts == nil {
		return localVarReturnValue, nil, reportError("contacts is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.contacts
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateContactAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	contactID string
	fileName string
	body *string
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiUpdateContactAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiUpdateContactAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Byte array of file in body of request
func (r ApiUpdateContactAttachmentByFileNameRequest) Body(body string) ApiUpdateContactAttachmentByFileNameRequest {
	r.body = &body
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateContactAttachmentByFileNameRequest) IdempotencyKey(idempotencyKey string) ApiUpdateContactAttachmentByFileNameRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiUpdateContactAttachmentByFileNameRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.UpdateContactAttachmentByFileNameExecute(r)
}

/*
UpdateContactAttachmentByFileName Method for UpdateContactAttachmentByFileName

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactID Unique identifier for a Contact
 @param fileName Name of the attachment
 @return ApiUpdateContactAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) UpdateContactAttachmentByFileName(ctx context.Context, contactID string, fileName string) ApiUpdateContactAttachmentByFileNameRequest {
	return ApiUpdateContactAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		contactID: contactID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) UpdateContactAttachmentByFileNameExecute(r ApiUpdateContactAttachmentByFileNameRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateContactAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Contacts/{ContactID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"ContactID"+"}", url.PathEscape(parameterValueToString(r.contactID, "contactID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateContactGroupRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	contactGroupID string
	contactGroups *ContactGroups
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiUpdateContactGroupRequest) XeroTenantId(xeroTenantId string) ApiUpdateContactGroupRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// an array of Contact groups with Name of specific group to update
func (r ApiUpdateContactGroupRequest) ContactGroups(contactGroups ContactGroups) ApiUpdateContactGroupRequest {
	r.contactGroups = &contactGroups
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateContactGroupRequest) IdempotencyKey(idempotencyKey string) ApiUpdateContactGroupRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiUpdateContactGroupRequest) Execute() (*ContactGroups, *http.Response, error) {
	return r.ApiService.UpdateContactGroupExecute(r)
}

/*
UpdateContactGroup Updates a specific contact group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contactGroupID Unique identifier for a Contact Group
 @return ApiUpdateContactGroupRequest
*/
func (a *AccountingAPIService) UpdateContactGroup(ctx context.Context, contactGroupID string) ApiUpdateContactGroupRequest {
	return ApiUpdateContactGroupRequest{
		ApiService: a,
		ctx: ctx,
		contactGroupID: contactGroupID,
	}
}

// Execute executes the request
//  @return ContactGroups
func (a *AccountingAPIService) UpdateContactGroupExecute(r ApiUpdateContactGroupRequest) (*ContactGroups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContactGroups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateContactGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ContactGroups/{ContactGroupID}"
	localVarPath = strings.Replace(localVarPath, "{"+"ContactGroupID"+"}", url.PathEscape(parameterValueToString(r.contactGroupID, "contactGroupID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contactGroups == nil {
		return localVarReturnValue, nil, reportError("contactGroups is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.contactGroups
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCreditNoteRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	creditNoteID string
	creditNotes *CreditNotes
	idempotencyKey *string
	unitdp *int32
}

// Xero identifier for Tenant
func (r ApiUpdateCreditNoteRequest) XeroTenantId(xeroTenantId string) ApiUpdateCreditNoteRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// an array of Credit Notes containing credit note details to update
func (r ApiUpdateCreditNoteRequest) CreditNotes(creditNotes CreditNotes) ApiUpdateCreditNoteRequest {
	r.creditNotes = &creditNotes
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateCreditNoteRequest) IdempotencyKey(idempotencyKey string) ApiUpdateCreditNoteRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiUpdateCreditNoteRequest) Unitdp(unitdp int32) ApiUpdateCreditNoteRequest {
	r.unitdp = &unitdp
	return r
}

func (r ApiUpdateCreditNoteRequest) Execute() (*CreditNotes, *http.Response, error) {
	return r.ApiService.UpdateCreditNoteExecute(r)
}

/*
UpdateCreditNote Updates a specific credit note

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param creditNoteID Unique identifier for a Credit Note
 @return ApiUpdateCreditNoteRequest
*/
func (a *AccountingAPIService) UpdateCreditNote(ctx context.Context, creditNoteID string) ApiUpdateCreditNoteRequest {
	return ApiUpdateCreditNoteRequest{
		ApiService: a,
		ctx: ctx,
		creditNoteID: creditNoteID,
	}
}

// Execute executes the request
//  @return CreditNotes
func (a *AccountingAPIService) UpdateCreditNoteExecute(r ApiUpdateCreditNoteRequest) (*CreditNotes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreditNotes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateCreditNote")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CreditNotes/{CreditNoteID}"
	localVarPath = strings.Replace(localVarPath, "{"+"CreditNoteID"+"}", url.PathEscape(parameterValueToString(r.creditNoteID, "creditNoteID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.creditNotes == nil {
		return localVarReturnValue, nil, reportError("creditNotes is required and must be specified")
	}

	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.creditNotes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCreditNoteAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	creditNoteID string
	fileName string
	body *string
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiUpdateCreditNoteAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiUpdateCreditNoteAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Byte array of file in body of request
func (r ApiUpdateCreditNoteAttachmentByFileNameRequest) Body(body string) ApiUpdateCreditNoteAttachmentByFileNameRequest {
	r.body = &body
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateCreditNoteAttachmentByFileNameRequest) IdempotencyKey(idempotencyKey string) ApiUpdateCreditNoteAttachmentByFileNameRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiUpdateCreditNoteAttachmentByFileNameRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.UpdateCreditNoteAttachmentByFileNameExecute(r)
}

/*
UpdateCreditNoteAttachmentByFileName Updates attachments on a specific credit note by file name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param creditNoteID Unique identifier for a Credit Note
 @param fileName Name of the attachment
 @return ApiUpdateCreditNoteAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) UpdateCreditNoteAttachmentByFileName(ctx context.Context, creditNoteID string, fileName string) ApiUpdateCreditNoteAttachmentByFileNameRequest {
	return ApiUpdateCreditNoteAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		creditNoteID: creditNoteID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) UpdateCreditNoteAttachmentByFileNameExecute(r ApiUpdateCreditNoteAttachmentByFileNameRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateCreditNoteAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CreditNotes/{CreditNoteID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"CreditNoteID"+"}", url.PathEscape(parameterValueToString(r.creditNoteID, "creditNoteID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateExpenseClaimRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	expenseClaimID string
	expenseClaims *ExpenseClaims
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiUpdateExpenseClaimRequest) XeroTenantId(xeroTenantId string) ApiUpdateExpenseClaimRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiUpdateExpenseClaimRequest) ExpenseClaims(expenseClaims ExpenseClaims) ApiUpdateExpenseClaimRequest {
	r.expenseClaims = &expenseClaims
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateExpenseClaimRequest) IdempotencyKey(idempotencyKey string) ApiUpdateExpenseClaimRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiUpdateExpenseClaimRequest) Execute() (*ExpenseClaims, *http.Response, error) {
	return r.ApiService.UpdateExpenseClaimExecute(r)
}

/*
UpdateExpenseClaim Updates a specific expense claims

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param expenseClaimID Unique identifier for a ExpenseClaim
 @return ApiUpdateExpenseClaimRequest
*/
func (a *AccountingAPIService) UpdateExpenseClaim(ctx context.Context, expenseClaimID string) ApiUpdateExpenseClaimRequest {
	return ApiUpdateExpenseClaimRequest{
		ApiService: a,
		ctx: ctx,
		expenseClaimID: expenseClaimID,
	}
}

// Execute executes the request
//  @return ExpenseClaims
func (a *AccountingAPIService) UpdateExpenseClaimExecute(r ApiUpdateExpenseClaimRequest) (*ExpenseClaims, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExpenseClaims
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateExpenseClaim")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ExpenseClaims/{ExpenseClaimID}"
	localVarPath = strings.Replace(localVarPath, "{"+"ExpenseClaimID"+"}", url.PathEscape(parameterValueToString(r.expenseClaimID, "expenseClaimID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.expenseClaims == nil {
		return localVarReturnValue, nil, reportError("expenseClaims is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.expenseClaims
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateInvoiceRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	invoiceID string
	invoices *Invoices
	idempotencyKey *string
	unitdp *int32
}

// Xero identifier for Tenant
func (r ApiUpdateInvoiceRequest) XeroTenantId(xeroTenantId string) ApiUpdateInvoiceRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiUpdateInvoiceRequest) Invoices(invoices Invoices) ApiUpdateInvoiceRequest {
	r.invoices = &invoices
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateInvoiceRequest) IdempotencyKey(idempotencyKey string) ApiUpdateInvoiceRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiUpdateInvoiceRequest) Unitdp(unitdp int32) ApiUpdateInvoiceRequest {
	r.unitdp = &unitdp
	return r
}

func (r ApiUpdateInvoiceRequest) Execute() (*Invoices, *http.Response, error) {
	return r.ApiService.UpdateInvoiceExecute(r)
}

/*
UpdateInvoice Updates a specific sales invoices or purchase bills

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceID Unique identifier for an Invoice
 @return ApiUpdateInvoiceRequest
*/
func (a *AccountingAPIService) UpdateInvoice(ctx context.Context, invoiceID string) ApiUpdateInvoiceRequest {
	return ApiUpdateInvoiceRequest{
		ApiService: a,
		ctx: ctx,
		invoiceID: invoiceID,
	}
}

// Execute executes the request
//  @return Invoices
func (a *AccountingAPIService) UpdateInvoiceExecute(r ApiUpdateInvoiceRequest) (*Invoices, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Invoices
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Invoices/{InvoiceID}"
	localVarPath = strings.Replace(localVarPath, "{"+"InvoiceID"+"}", url.PathEscape(parameterValueToString(r.invoiceID, "invoiceID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.invoices == nil {
		return localVarReturnValue, nil, reportError("invoices is required and must be specified")
	}

	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.invoices
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateInvoiceAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	invoiceID string
	fileName string
	body *string
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiUpdateInvoiceAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiUpdateInvoiceAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Byte array of file in body of request
func (r ApiUpdateInvoiceAttachmentByFileNameRequest) Body(body string) ApiUpdateInvoiceAttachmentByFileNameRequest {
	r.body = &body
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateInvoiceAttachmentByFileNameRequest) IdempotencyKey(idempotencyKey string) ApiUpdateInvoiceAttachmentByFileNameRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiUpdateInvoiceAttachmentByFileNameRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.UpdateInvoiceAttachmentByFileNameExecute(r)
}

/*
UpdateInvoiceAttachmentByFileName Updates an attachment from a specific invoices or purchase bill by filename

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceID Unique identifier for an Invoice
 @param fileName Name of the attachment
 @return ApiUpdateInvoiceAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) UpdateInvoiceAttachmentByFileName(ctx context.Context, invoiceID string, fileName string) ApiUpdateInvoiceAttachmentByFileNameRequest {
	return ApiUpdateInvoiceAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		invoiceID: invoiceID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) UpdateInvoiceAttachmentByFileNameExecute(r ApiUpdateInvoiceAttachmentByFileNameRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateInvoiceAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Invoices/{InvoiceID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"InvoiceID"+"}", url.PathEscape(parameterValueToString(r.invoiceID, "invoiceID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateItemRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	itemID string
	items *Items
	idempotencyKey *string
	unitdp *int32
}

// Xero identifier for Tenant
func (r ApiUpdateItemRequest) XeroTenantId(xeroTenantId string) ApiUpdateItemRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiUpdateItemRequest) Items(items Items) ApiUpdateItemRequest {
	r.items = &items
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateItemRequest) IdempotencyKey(idempotencyKey string) ApiUpdateItemRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiUpdateItemRequest) Unitdp(unitdp int32) ApiUpdateItemRequest {
	r.unitdp = &unitdp
	return r
}

func (r ApiUpdateItemRequest) Execute() (*Items, *http.Response, error) {
	return r.ApiService.UpdateItemExecute(r)
}

/*
UpdateItem Updates a specific item

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemID Unique identifier for an Item
 @return ApiUpdateItemRequest
*/
func (a *AccountingAPIService) UpdateItem(ctx context.Context, itemID string) ApiUpdateItemRequest {
	return ApiUpdateItemRequest{
		ApiService: a,
		ctx: ctx,
		itemID: itemID,
	}
}

// Execute executes the request
//  @return Items
func (a *AccountingAPIService) UpdateItemExecute(r ApiUpdateItemRequest) (*Items, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Items
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{ItemID}"
	localVarPath = strings.Replace(localVarPath, "{"+"ItemID"+"}", url.PathEscape(parameterValueToString(r.itemID, "itemID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.items == nil {
		return localVarReturnValue, nil, reportError("items is required and must be specified")
	}

	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.items
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateLinkedTransactionRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	linkedTransactionID string
	linkedTransactions *LinkedTransactions
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiUpdateLinkedTransactionRequest) XeroTenantId(xeroTenantId string) ApiUpdateLinkedTransactionRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiUpdateLinkedTransactionRequest) LinkedTransactions(linkedTransactions LinkedTransactions) ApiUpdateLinkedTransactionRequest {
	r.linkedTransactions = &linkedTransactions
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateLinkedTransactionRequest) IdempotencyKey(idempotencyKey string) ApiUpdateLinkedTransactionRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiUpdateLinkedTransactionRequest) Execute() (*LinkedTransactions, *http.Response, error) {
	return r.ApiService.UpdateLinkedTransactionExecute(r)
}

/*
UpdateLinkedTransaction Updates a specific linked transactions (billable expenses)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param linkedTransactionID Unique identifier for a LinkedTransaction
 @return ApiUpdateLinkedTransactionRequest
*/
func (a *AccountingAPIService) UpdateLinkedTransaction(ctx context.Context, linkedTransactionID string) ApiUpdateLinkedTransactionRequest {
	return ApiUpdateLinkedTransactionRequest{
		ApiService: a,
		ctx: ctx,
		linkedTransactionID: linkedTransactionID,
	}
}

// Execute executes the request
//  @return LinkedTransactions
func (a *AccountingAPIService) UpdateLinkedTransactionExecute(r ApiUpdateLinkedTransactionRequest) (*LinkedTransactions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LinkedTransactions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateLinkedTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LinkedTransactions/{LinkedTransactionID}"
	localVarPath = strings.Replace(localVarPath, "{"+"LinkedTransactionID"+"}", url.PathEscape(parameterValueToString(r.linkedTransactionID, "linkedTransactionID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.linkedTransactions == nil {
		return localVarReturnValue, nil, reportError("linkedTransactions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.linkedTransactions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateManualJournalRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	manualJournalID string
	manualJournals *ManualJournals
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiUpdateManualJournalRequest) XeroTenantId(xeroTenantId string) ApiUpdateManualJournalRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiUpdateManualJournalRequest) ManualJournals(manualJournals ManualJournals) ApiUpdateManualJournalRequest {
	r.manualJournals = &manualJournals
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateManualJournalRequest) IdempotencyKey(idempotencyKey string) ApiUpdateManualJournalRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiUpdateManualJournalRequest) Execute() (*ManualJournals, *http.Response, error) {
	return r.ApiService.UpdateManualJournalExecute(r)
}

/*
UpdateManualJournal Updates a specific manual journal

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param manualJournalID Unique identifier for a ManualJournal
 @return ApiUpdateManualJournalRequest
*/
func (a *AccountingAPIService) UpdateManualJournal(ctx context.Context, manualJournalID string) ApiUpdateManualJournalRequest {
	return ApiUpdateManualJournalRequest{
		ApiService: a,
		ctx: ctx,
		manualJournalID: manualJournalID,
	}
}

// Execute executes the request
//  @return ManualJournals
func (a *AccountingAPIService) UpdateManualJournalExecute(r ApiUpdateManualJournalRequest) (*ManualJournals, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManualJournals
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateManualJournal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ManualJournals/{ManualJournalID}"
	localVarPath = strings.Replace(localVarPath, "{"+"ManualJournalID"+"}", url.PathEscape(parameterValueToString(r.manualJournalID, "manualJournalID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.manualJournals == nil {
		return localVarReturnValue, nil, reportError("manualJournals is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.manualJournals
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateManualJournalAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	manualJournalID string
	fileName string
	body *string
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiUpdateManualJournalAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiUpdateManualJournalAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Byte array of file in body of request
func (r ApiUpdateManualJournalAttachmentByFileNameRequest) Body(body string) ApiUpdateManualJournalAttachmentByFileNameRequest {
	r.body = &body
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateManualJournalAttachmentByFileNameRequest) IdempotencyKey(idempotencyKey string) ApiUpdateManualJournalAttachmentByFileNameRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiUpdateManualJournalAttachmentByFileNameRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.UpdateManualJournalAttachmentByFileNameExecute(r)
}

/*
UpdateManualJournalAttachmentByFileName Updates a specific attachment from a specific manual journal by file name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param manualJournalID Unique identifier for a ManualJournal
 @param fileName Name of the attachment
 @return ApiUpdateManualJournalAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) UpdateManualJournalAttachmentByFileName(ctx context.Context, manualJournalID string, fileName string) ApiUpdateManualJournalAttachmentByFileNameRequest {
	return ApiUpdateManualJournalAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		manualJournalID: manualJournalID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) UpdateManualJournalAttachmentByFileNameExecute(r ApiUpdateManualJournalAttachmentByFileNameRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateManualJournalAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ManualJournals/{ManualJournalID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"ManualJournalID"+"}", url.PathEscape(parameterValueToString(r.manualJournalID, "manualJournalID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateOrCreateBankTransactionsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	bankTransactions *BankTransactions
	idempotencyKey *string
	summarizeErrors *bool
	unitdp *int32
}

// Xero identifier for Tenant
func (r ApiUpdateOrCreateBankTransactionsRequest) XeroTenantId(xeroTenantId string) ApiUpdateOrCreateBankTransactionsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiUpdateOrCreateBankTransactionsRequest) BankTransactions(bankTransactions BankTransactions) ApiUpdateOrCreateBankTransactionsRequest {
	r.bankTransactions = &bankTransactions
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateOrCreateBankTransactionsRequest) IdempotencyKey(idempotencyKey string) ApiUpdateOrCreateBankTransactionsRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// If false return 200 OK and mix of successfully created objects and any with validation errors
func (r ApiUpdateOrCreateBankTransactionsRequest) SummarizeErrors(summarizeErrors bool) ApiUpdateOrCreateBankTransactionsRequest {
	r.summarizeErrors = &summarizeErrors
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiUpdateOrCreateBankTransactionsRequest) Unitdp(unitdp int32) ApiUpdateOrCreateBankTransactionsRequest {
	r.unitdp = &unitdp
	return r
}

func (r ApiUpdateOrCreateBankTransactionsRequest) Execute() (*BankTransactions, *http.Response, error) {
	return r.ApiService.UpdateOrCreateBankTransactionsExecute(r)
}

/*
UpdateOrCreateBankTransactions Updates or creates one or more spent or received money transaction

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateOrCreateBankTransactionsRequest
*/
func (a *AccountingAPIService) UpdateOrCreateBankTransactions(ctx context.Context) ApiUpdateOrCreateBankTransactionsRequest {
	return ApiUpdateOrCreateBankTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BankTransactions
func (a *AccountingAPIService) UpdateOrCreateBankTransactionsExecute(r ApiUpdateOrCreateBankTransactionsRequest) (*BankTransactions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BankTransactions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateOrCreateBankTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/BankTransactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.bankTransactions == nil {
		return localVarReturnValue, nil, reportError("bankTransactions is required and must be specified")
	}

	if r.summarizeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarizeErrors", r.summarizeErrors, "")
	}
	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.bankTransactions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateOrCreateContactsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	contacts *Contacts
	idempotencyKey *string
	summarizeErrors *bool
}

// Xero identifier for Tenant
func (r ApiUpdateOrCreateContactsRequest) XeroTenantId(xeroTenantId string) ApiUpdateOrCreateContactsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiUpdateOrCreateContactsRequest) Contacts(contacts Contacts) ApiUpdateOrCreateContactsRequest {
	r.contacts = &contacts
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateOrCreateContactsRequest) IdempotencyKey(idempotencyKey string) ApiUpdateOrCreateContactsRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// If false return 200 OK and mix of successfully created objects and any with validation errors
func (r ApiUpdateOrCreateContactsRequest) SummarizeErrors(summarizeErrors bool) ApiUpdateOrCreateContactsRequest {
	r.summarizeErrors = &summarizeErrors
	return r
}

func (r ApiUpdateOrCreateContactsRequest) Execute() (*Contacts, *http.Response, error) {
	return r.ApiService.UpdateOrCreateContactsExecute(r)
}

/*
UpdateOrCreateContacts Updates or creates one or more contacts in a Xero organisation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateOrCreateContactsRequest
*/
func (a *AccountingAPIService) UpdateOrCreateContacts(ctx context.Context) ApiUpdateOrCreateContactsRequest {
	return ApiUpdateOrCreateContactsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Contacts
func (a *AccountingAPIService) UpdateOrCreateContactsExecute(r ApiUpdateOrCreateContactsRequest) (*Contacts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Contacts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateOrCreateContacts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Contacts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.contacts == nil {
		return localVarReturnValue, nil, reportError("contacts is required and must be specified")
	}

	if r.summarizeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarizeErrors", r.summarizeErrors, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.contacts
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateOrCreateCreditNotesRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	creditNotes *CreditNotes
	idempotencyKey *string
	summarizeErrors *bool
	unitdp *int32
}

// Xero identifier for Tenant
func (r ApiUpdateOrCreateCreditNotesRequest) XeroTenantId(xeroTenantId string) ApiUpdateOrCreateCreditNotesRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// an array of Credit Notes with a single CreditNote object.
func (r ApiUpdateOrCreateCreditNotesRequest) CreditNotes(creditNotes CreditNotes) ApiUpdateOrCreateCreditNotesRequest {
	r.creditNotes = &creditNotes
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateOrCreateCreditNotesRequest) IdempotencyKey(idempotencyKey string) ApiUpdateOrCreateCreditNotesRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// If false return 200 OK and mix of successfully created objects and any with validation errors
func (r ApiUpdateOrCreateCreditNotesRequest) SummarizeErrors(summarizeErrors bool) ApiUpdateOrCreateCreditNotesRequest {
	r.summarizeErrors = &summarizeErrors
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiUpdateOrCreateCreditNotesRequest) Unitdp(unitdp int32) ApiUpdateOrCreateCreditNotesRequest {
	r.unitdp = &unitdp
	return r
}

func (r ApiUpdateOrCreateCreditNotesRequest) Execute() (*CreditNotes, *http.Response, error) {
	return r.ApiService.UpdateOrCreateCreditNotesExecute(r)
}

/*
UpdateOrCreateCreditNotes Updates or creates one or more credit notes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateOrCreateCreditNotesRequest
*/
func (a *AccountingAPIService) UpdateOrCreateCreditNotes(ctx context.Context) ApiUpdateOrCreateCreditNotesRequest {
	return ApiUpdateOrCreateCreditNotesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreditNotes
func (a *AccountingAPIService) UpdateOrCreateCreditNotesExecute(r ApiUpdateOrCreateCreditNotesRequest) (*CreditNotes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreditNotes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateOrCreateCreditNotes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CreditNotes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.creditNotes == nil {
		return localVarReturnValue, nil, reportError("creditNotes is required and must be specified")
	}

	if r.summarizeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarizeErrors", r.summarizeErrors, "")
	}
	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.creditNotes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateOrCreateEmployeesRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	employees *Employees
	idempotencyKey *string
	summarizeErrors *bool
}

// Xero identifier for Tenant
func (r ApiUpdateOrCreateEmployeesRequest) XeroTenantId(xeroTenantId string) ApiUpdateOrCreateEmployeesRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Employees with array of Employee object in body of request
func (r ApiUpdateOrCreateEmployeesRequest) Employees(employees Employees) ApiUpdateOrCreateEmployeesRequest {
	r.employees = &employees
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateOrCreateEmployeesRequest) IdempotencyKey(idempotencyKey string) ApiUpdateOrCreateEmployeesRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// If false return 200 OK and mix of successfully created objects and any with validation errors
func (r ApiUpdateOrCreateEmployeesRequest) SummarizeErrors(summarizeErrors bool) ApiUpdateOrCreateEmployeesRequest {
	r.summarizeErrors = &summarizeErrors
	return r
}

func (r ApiUpdateOrCreateEmployeesRequest) Execute() (*Employees, *http.Response, error) {
	return r.ApiService.UpdateOrCreateEmployeesExecute(r)
}

/*
UpdateOrCreateEmployees Creates a single new employees used in Xero payrun

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateOrCreateEmployeesRequest
*/
func (a *AccountingAPIService) UpdateOrCreateEmployees(ctx context.Context) ApiUpdateOrCreateEmployeesRequest {
	return ApiUpdateOrCreateEmployeesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Employees
func (a *AccountingAPIService) UpdateOrCreateEmployeesExecute(r ApiUpdateOrCreateEmployeesRequest) (*Employees, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Employees
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateOrCreateEmployees")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Employees"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.employees == nil {
		return localVarReturnValue, nil, reportError("employees is required and must be specified")
	}

	if r.summarizeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarizeErrors", r.summarizeErrors, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.employees
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateOrCreateInvoicesRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	invoices *Invoices
	idempotencyKey *string
	summarizeErrors *bool
	unitdp *int32
}

// Xero identifier for Tenant
func (r ApiUpdateOrCreateInvoicesRequest) XeroTenantId(xeroTenantId string) ApiUpdateOrCreateInvoicesRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiUpdateOrCreateInvoicesRequest) Invoices(invoices Invoices) ApiUpdateOrCreateInvoicesRequest {
	r.invoices = &invoices
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateOrCreateInvoicesRequest) IdempotencyKey(idempotencyKey string) ApiUpdateOrCreateInvoicesRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// If false return 200 OK and mix of successfully created objects and any with validation errors
func (r ApiUpdateOrCreateInvoicesRequest) SummarizeErrors(summarizeErrors bool) ApiUpdateOrCreateInvoicesRequest {
	r.summarizeErrors = &summarizeErrors
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiUpdateOrCreateInvoicesRequest) Unitdp(unitdp int32) ApiUpdateOrCreateInvoicesRequest {
	r.unitdp = &unitdp
	return r
}

func (r ApiUpdateOrCreateInvoicesRequest) Execute() (*Invoices, *http.Response, error) {
	return r.ApiService.UpdateOrCreateInvoicesExecute(r)
}

/*
UpdateOrCreateInvoices Updates or creates one or more sales invoices or purchase bills

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateOrCreateInvoicesRequest
*/
func (a *AccountingAPIService) UpdateOrCreateInvoices(ctx context.Context) ApiUpdateOrCreateInvoicesRequest {
	return ApiUpdateOrCreateInvoicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Invoices
func (a *AccountingAPIService) UpdateOrCreateInvoicesExecute(r ApiUpdateOrCreateInvoicesRequest) (*Invoices, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Invoices
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateOrCreateInvoices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Invoices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.invoices == nil {
		return localVarReturnValue, nil, reportError("invoices is required and must be specified")
	}

	if r.summarizeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarizeErrors", r.summarizeErrors, "")
	}
	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.invoices
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateOrCreateItemsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	items *Items
	idempotencyKey *string
	summarizeErrors *bool
	unitdp *int32
}

// Xero identifier for Tenant
func (r ApiUpdateOrCreateItemsRequest) XeroTenantId(xeroTenantId string) ApiUpdateOrCreateItemsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiUpdateOrCreateItemsRequest) Items(items Items) ApiUpdateOrCreateItemsRequest {
	r.items = &items
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateOrCreateItemsRequest) IdempotencyKey(idempotencyKey string) ApiUpdateOrCreateItemsRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// If false return 200 OK and mix of successfully created objects and any with validation errors
func (r ApiUpdateOrCreateItemsRequest) SummarizeErrors(summarizeErrors bool) ApiUpdateOrCreateItemsRequest {
	r.summarizeErrors = &summarizeErrors
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiUpdateOrCreateItemsRequest) Unitdp(unitdp int32) ApiUpdateOrCreateItemsRequest {
	r.unitdp = &unitdp
	return r
}

func (r ApiUpdateOrCreateItemsRequest) Execute() (*Items, *http.Response, error) {
	return r.ApiService.UpdateOrCreateItemsExecute(r)
}

/*
UpdateOrCreateItems Updates or creates one or more items

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateOrCreateItemsRequest
*/
func (a *AccountingAPIService) UpdateOrCreateItems(ctx context.Context) ApiUpdateOrCreateItemsRequest {
	return ApiUpdateOrCreateItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Items
func (a *AccountingAPIService) UpdateOrCreateItemsExecute(r ApiUpdateOrCreateItemsRequest) (*Items, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Items
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateOrCreateItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.items == nil {
		return localVarReturnValue, nil, reportError("items is required and must be specified")
	}

	if r.summarizeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarizeErrors", r.summarizeErrors, "")
	}
	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.items
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateOrCreateManualJournalsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	manualJournals *ManualJournals
	idempotencyKey *string
	summarizeErrors *bool
}

// Xero identifier for Tenant
func (r ApiUpdateOrCreateManualJournalsRequest) XeroTenantId(xeroTenantId string) ApiUpdateOrCreateManualJournalsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// ManualJournals array with ManualJournal object in body of request
func (r ApiUpdateOrCreateManualJournalsRequest) ManualJournals(manualJournals ManualJournals) ApiUpdateOrCreateManualJournalsRequest {
	r.manualJournals = &manualJournals
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateOrCreateManualJournalsRequest) IdempotencyKey(idempotencyKey string) ApiUpdateOrCreateManualJournalsRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// If false return 200 OK and mix of successfully created objects and any with validation errors
func (r ApiUpdateOrCreateManualJournalsRequest) SummarizeErrors(summarizeErrors bool) ApiUpdateOrCreateManualJournalsRequest {
	r.summarizeErrors = &summarizeErrors
	return r
}

func (r ApiUpdateOrCreateManualJournalsRequest) Execute() (*ManualJournals, *http.Response, error) {
	return r.ApiService.UpdateOrCreateManualJournalsExecute(r)
}

/*
UpdateOrCreateManualJournals Updates or creates a single manual journal

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateOrCreateManualJournalsRequest
*/
func (a *AccountingAPIService) UpdateOrCreateManualJournals(ctx context.Context) ApiUpdateOrCreateManualJournalsRequest {
	return ApiUpdateOrCreateManualJournalsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ManualJournals
func (a *AccountingAPIService) UpdateOrCreateManualJournalsExecute(r ApiUpdateOrCreateManualJournalsRequest) (*ManualJournals, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManualJournals
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateOrCreateManualJournals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ManualJournals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.manualJournals == nil {
		return localVarReturnValue, nil, reportError("manualJournals is required and must be specified")
	}

	if r.summarizeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarizeErrors", r.summarizeErrors, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.manualJournals
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateOrCreatePurchaseOrdersRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	purchaseOrders *PurchaseOrders
	idempotencyKey *string
	summarizeErrors *bool
}

// Xero identifier for Tenant
func (r ApiUpdateOrCreatePurchaseOrdersRequest) XeroTenantId(xeroTenantId string) ApiUpdateOrCreatePurchaseOrdersRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiUpdateOrCreatePurchaseOrdersRequest) PurchaseOrders(purchaseOrders PurchaseOrders) ApiUpdateOrCreatePurchaseOrdersRequest {
	r.purchaseOrders = &purchaseOrders
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateOrCreatePurchaseOrdersRequest) IdempotencyKey(idempotencyKey string) ApiUpdateOrCreatePurchaseOrdersRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// If false return 200 OK and mix of successfully created objects and any with validation errors
func (r ApiUpdateOrCreatePurchaseOrdersRequest) SummarizeErrors(summarizeErrors bool) ApiUpdateOrCreatePurchaseOrdersRequest {
	r.summarizeErrors = &summarizeErrors
	return r
}

func (r ApiUpdateOrCreatePurchaseOrdersRequest) Execute() (*PurchaseOrders, *http.Response, error) {
	return r.ApiService.UpdateOrCreatePurchaseOrdersExecute(r)
}

/*
UpdateOrCreatePurchaseOrders Updates or creates one or more purchase orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateOrCreatePurchaseOrdersRequest
*/
func (a *AccountingAPIService) UpdateOrCreatePurchaseOrders(ctx context.Context) ApiUpdateOrCreatePurchaseOrdersRequest {
	return ApiUpdateOrCreatePurchaseOrdersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PurchaseOrders
func (a *AccountingAPIService) UpdateOrCreatePurchaseOrdersExecute(r ApiUpdateOrCreatePurchaseOrdersRequest) (*PurchaseOrders, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PurchaseOrders
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateOrCreatePurchaseOrders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PurchaseOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.purchaseOrders == nil {
		return localVarReturnValue, nil, reportError("purchaseOrders is required and must be specified")
	}

	if r.summarizeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarizeErrors", r.summarizeErrors, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.purchaseOrders
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateOrCreateQuotesRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	quotes *Quotes
	idempotencyKey *string
	summarizeErrors *bool
}

// Xero identifier for Tenant
func (r ApiUpdateOrCreateQuotesRequest) XeroTenantId(xeroTenantId string) ApiUpdateOrCreateQuotesRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiUpdateOrCreateQuotesRequest) Quotes(quotes Quotes) ApiUpdateOrCreateQuotesRequest {
	r.quotes = &quotes
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateOrCreateQuotesRequest) IdempotencyKey(idempotencyKey string) ApiUpdateOrCreateQuotesRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// If false return 200 OK and mix of successfully created objects and any with validation errors
func (r ApiUpdateOrCreateQuotesRequest) SummarizeErrors(summarizeErrors bool) ApiUpdateOrCreateQuotesRequest {
	r.summarizeErrors = &summarizeErrors
	return r
}

func (r ApiUpdateOrCreateQuotesRequest) Execute() (*Quotes, *http.Response, error) {
	return r.ApiService.UpdateOrCreateQuotesExecute(r)
}

/*
UpdateOrCreateQuotes Updates or creates one or more quotes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateOrCreateQuotesRequest
*/
func (a *AccountingAPIService) UpdateOrCreateQuotes(ctx context.Context) ApiUpdateOrCreateQuotesRequest {
	return ApiUpdateOrCreateQuotesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Quotes
func (a *AccountingAPIService) UpdateOrCreateQuotesExecute(r ApiUpdateOrCreateQuotesRequest) (*Quotes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Quotes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateOrCreateQuotes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Quotes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.quotes == nil {
		return localVarReturnValue, nil, reportError("quotes is required and must be specified")
	}

	if r.summarizeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarizeErrors", r.summarizeErrors, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.quotes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateOrCreateRepeatingInvoicesRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	repeatingInvoices *RepeatingInvoices
	idempotencyKey *string
	summarizeErrors *bool
}

// Xero identifier for Tenant
func (r ApiUpdateOrCreateRepeatingInvoicesRequest) XeroTenantId(xeroTenantId string) ApiUpdateOrCreateRepeatingInvoicesRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// RepeatingInvoices with an array of repeating invoice objects in body of request
func (r ApiUpdateOrCreateRepeatingInvoicesRequest) RepeatingInvoices(repeatingInvoices RepeatingInvoices) ApiUpdateOrCreateRepeatingInvoicesRequest {
	r.repeatingInvoices = &repeatingInvoices
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateOrCreateRepeatingInvoicesRequest) IdempotencyKey(idempotencyKey string) ApiUpdateOrCreateRepeatingInvoicesRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// If false return 200 OK and mix of successfully created objects and any with validation errors
func (r ApiUpdateOrCreateRepeatingInvoicesRequest) SummarizeErrors(summarizeErrors bool) ApiUpdateOrCreateRepeatingInvoicesRequest {
	r.summarizeErrors = &summarizeErrors
	return r
}

func (r ApiUpdateOrCreateRepeatingInvoicesRequest) Execute() (*RepeatingInvoices, *http.Response, error) {
	return r.ApiService.UpdateOrCreateRepeatingInvoicesExecute(r)
}

/*
UpdateOrCreateRepeatingInvoices Creates or deletes one or more repeating invoice templates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateOrCreateRepeatingInvoicesRequest
*/
func (a *AccountingAPIService) UpdateOrCreateRepeatingInvoices(ctx context.Context) ApiUpdateOrCreateRepeatingInvoicesRequest {
	return ApiUpdateOrCreateRepeatingInvoicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RepeatingInvoices
func (a *AccountingAPIService) UpdateOrCreateRepeatingInvoicesExecute(r ApiUpdateOrCreateRepeatingInvoicesRequest) (*RepeatingInvoices, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RepeatingInvoices
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateOrCreateRepeatingInvoices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/RepeatingInvoices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.repeatingInvoices == nil {
		return localVarReturnValue, nil, reportError("repeatingInvoices is required and must be specified")
	}

	if r.summarizeErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summarizeErrors", r.summarizeErrors, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.repeatingInvoices
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePurchaseOrderRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	purchaseOrderID string
	purchaseOrders *PurchaseOrders
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiUpdatePurchaseOrderRequest) XeroTenantId(xeroTenantId string) ApiUpdatePurchaseOrderRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiUpdatePurchaseOrderRequest) PurchaseOrders(purchaseOrders PurchaseOrders) ApiUpdatePurchaseOrderRequest {
	r.purchaseOrders = &purchaseOrders
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdatePurchaseOrderRequest) IdempotencyKey(idempotencyKey string) ApiUpdatePurchaseOrderRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiUpdatePurchaseOrderRequest) Execute() (*PurchaseOrders, *http.Response, error) {
	return r.ApiService.UpdatePurchaseOrderExecute(r)
}

/*
UpdatePurchaseOrder Updates a specific purchase order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param purchaseOrderID Unique identifier for an Purchase Order
 @return ApiUpdatePurchaseOrderRequest
*/
func (a *AccountingAPIService) UpdatePurchaseOrder(ctx context.Context, purchaseOrderID string) ApiUpdatePurchaseOrderRequest {
	return ApiUpdatePurchaseOrderRequest{
		ApiService: a,
		ctx: ctx,
		purchaseOrderID: purchaseOrderID,
	}
}

// Execute executes the request
//  @return PurchaseOrders
func (a *AccountingAPIService) UpdatePurchaseOrderExecute(r ApiUpdatePurchaseOrderRequest) (*PurchaseOrders, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PurchaseOrders
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdatePurchaseOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PurchaseOrders/{PurchaseOrderID}"
	localVarPath = strings.Replace(localVarPath, "{"+"PurchaseOrderID"+"}", url.PathEscape(parameterValueToString(r.purchaseOrderID, "purchaseOrderID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.purchaseOrders == nil {
		return localVarReturnValue, nil, reportError("purchaseOrders is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.purchaseOrders
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePurchaseOrderAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	purchaseOrderID string
	fileName string
	body *string
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiUpdatePurchaseOrderAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiUpdatePurchaseOrderAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Byte array of file in body of request
func (r ApiUpdatePurchaseOrderAttachmentByFileNameRequest) Body(body string) ApiUpdatePurchaseOrderAttachmentByFileNameRequest {
	r.body = &body
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdatePurchaseOrderAttachmentByFileNameRequest) IdempotencyKey(idempotencyKey string) ApiUpdatePurchaseOrderAttachmentByFileNameRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiUpdatePurchaseOrderAttachmentByFileNameRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.UpdatePurchaseOrderAttachmentByFileNameExecute(r)
}

/*
UpdatePurchaseOrderAttachmentByFileName Updates a specific attachment for a specific purchase order by filename

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param purchaseOrderID Unique identifier for an Purchase Order
 @param fileName Name of the attachment
 @return ApiUpdatePurchaseOrderAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) UpdatePurchaseOrderAttachmentByFileName(ctx context.Context, purchaseOrderID string, fileName string) ApiUpdatePurchaseOrderAttachmentByFileNameRequest {
	return ApiUpdatePurchaseOrderAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		purchaseOrderID: purchaseOrderID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) UpdatePurchaseOrderAttachmentByFileNameExecute(r ApiUpdatePurchaseOrderAttachmentByFileNameRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdatePurchaseOrderAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PurchaseOrders/{PurchaseOrderID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"PurchaseOrderID"+"}", url.PathEscape(parameterValueToString(r.purchaseOrderID, "purchaseOrderID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateQuoteRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	quoteID string
	quotes *Quotes
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiUpdateQuoteRequest) XeroTenantId(xeroTenantId string) ApiUpdateQuoteRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiUpdateQuoteRequest) Quotes(quotes Quotes) ApiUpdateQuoteRequest {
	r.quotes = &quotes
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateQuoteRequest) IdempotencyKey(idempotencyKey string) ApiUpdateQuoteRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiUpdateQuoteRequest) Execute() (*Quotes, *http.Response, error) {
	return r.ApiService.UpdateQuoteExecute(r)
}

/*
UpdateQuote Updates a specific quote

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param quoteID Unique identifier for an Quote
 @return ApiUpdateQuoteRequest
*/
func (a *AccountingAPIService) UpdateQuote(ctx context.Context, quoteID string) ApiUpdateQuoteRequest {
	return ApiUpdateQuoteRequest{
		ApiService: a,
		ctx: ctx,
		quoteID: quoteID,
	}
}

// Execute executes the request
//  @return Quotes
func (a *AccountingAPIService) UpdateQuoteExecute(r ApiUpdateQuoteRequest) (*Quotes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Quotes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateQuote")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Quotes/{QuoteID}"
	localVarPath = strings.Replace(localVarPath, "{"+"QuoteID"+"}", url.PathEscape(parameterValueToString(r.quoteID, "quoteID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.quotes == nil {
		return localVarReturnValue, nil, reportError("quotes is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.quotes
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateQuoteAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	quoteID string
	fileName string
	body *string
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiUpdateQuoteAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiUpdateQuoteAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Byte array of file in body of request
func (r ApiUpdateQuoteAttachmentByFileNameRequest) Body(body string) ApiUpdateQuoteAttachmentByFileNameRequest {
	r.body = &body
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateQuoteAttachmentByFileNameRequest) IdempotencyKey(idempotencyKey string) ApiUpdateQuoteAttachmentByFileNameRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiUpdateQuoteAttachmentByFileNameRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.UpdateQuoteAttachmentByFileNameExecute(r)
}

/*
UpdateQuoteAttachmentByFileName Updates a specific attachment from a specific quote by filename

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param quoteID Unique identifier for an Quote
 @param fileName Name of the attachment
 @return ApiUpdateQuoteAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) UpdateQuoteAttachmentByFileName(ctx context.Context, quoteID string, fileName string) ApiUpdateQuoteAttachmentByFileNameRequest {
	return ApiUpdateQuoteAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		quoteID: quoteID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) UpdateQuoteAttachmentByFileNameExecute(r ApiUpdateQuoteAttachmentByFileNameRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateQuoteAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Quotes/{QuoteID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"QuoteID"+"}", url.PathEscape(parameterValueToString(r.quoteID, "quoteID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateReceiptRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	receiptID string
	receipts *Receipts
	idempotencyKey *string
	unitdp *int32
}

// Xero identifier for Tenant
func (r ApiUpdateReceiptRequest) XeroTenantId(xeroTenantId string) ApiUpdateReceiptRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiUpdateReceiptRequest) Receipts(receipts Receipts) ApiUpdateReceiptRequest {
	r.receipts = &receipts
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateReceiptRequest) IdempotencyKey(idempotencyKey string) ApiUpdateReceiptRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// e.g. unitdp&#x3D;4 â€“ (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
func (r ApiUpdateReceiptRequest) Unitdp(unitdp int32) ApiUpdateReceiptRequest {
	r.unitdp = &unitdp
	return r
}

func (r ApiUpdateReceiptRequest) Execute() (*Receipts, *http.Response, error) {
	return r.ApiService.UpdateReceiptExecute(r)
}

/*
UpdateReceipt Updates a specific draft expense claim receipts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param receiptID Unique identifier for a Receipt
 @return ApiUpdateReceiptRequest
*/
func (a *AccountingAPIService) UpdateReceipt(ctx context.Context, receiptID string) ApiUpdateReceiptRequest {
	return ApiUpdateReceiptRequest{
		ApiService: a,
		ctx: ctx,
		receiptID: receiptID,
	}
}

// Execute executes the request
//  @return Receipts
func (a *AccountingAPIService) UpdateReceiptExecute(r ApiUpdateReceiptRequest) (*Receipts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Receipts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateReceipt")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Receipts/{ReceiptID}"
	localVarPath = strings.Replace(localVarPath, "{"+"ReceiptID"+"}", url.PathEscape(parameterValueToString(r.receiptID, "receiptID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.receipts == nil {
		return localVarReturnValue, nil, reportError("receipts is required and must be specified")
	}

	if r.unitdp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unitdp", r.unitdp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.receipts
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateReceiptAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	receiptID string
	fileName string
	body *string
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiUpdateReceiptAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiUpdateReceiptAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Byte array of file in body of request
func (r ApiUpdateReceiptAttachmentByFileNameRequest) Body(body string) ApiUpdateReceiptAttachmentByFileNameRequest {
	r.body = &body
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateReceiptAttachmentByFileNameRequest) IdempotencyKey(idempotencyKey string) ApiUpdateReceiptAttachmentByFileNameRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiUpdateReceiptAttachmentByFileNameRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.UpdateReceiptAttachmentByFileNameExecute(r)
}

/*
UpdateReceiptAttachmentByFileName Updates a specific attachment on a specific expense claim receipts by file name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param receiptID Unique identifier for a Receipt
 @param fileName Name of the attachment
 @return ApiUpdateReceiptAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) UpdateReceiptAttachmentByFileName(ctx context.Context, receiptID string, fileName string) ApiUpdateReceiptAttachmentByFileNameRequest {
	return ApiUpdateReceiptAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		receiptID: receiptID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) UpdateReceiptAttachmentByFileNameExecute(r ApiUpdateReceiptAttachmentByFileNameRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateReceiptAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Receipts/{ReceiptID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"ReceiptID"+"}", url.PathEscape(parameterValueToString(r.receiptID, "receiptID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateRepeatingInvoiceRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	repeatingInvoiceID string
	repeatingInvoices *RepeatingInvoices
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiUpdateRepeatingInvoiceRequest) XeroTenantId(xeroTenantId string) ApiUpdateRepeatingInvoiceRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiUpdateRepeatingInvoiceRequest) RepeatingInvoices(repeatingInvoices RepeatingInvoices) ApiUpdateRepeatingInvoiceRequest {
	r.repeatingInvoices = &repeatingInvoices
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateRepeatingInvoiceRequest) IdempotencyKey(idempotencyKey string) ApiUpdateRepeatingInvoiceRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiUpdateRepeatingInvoiceRequest) Execute() (*RepeatingInvoices, *http.Response, error) {
	return r.ApiService.UpdateRepeatingInvoiceExecute(r)
}

/*
UpdateRepeatingInvoice Deletes a specific repeating invoice template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repeatingInvoiceID Unique identifier for a Repeating Invoice
 @return ApiUpdateRepeatingInvoiceRequest
*/
func (a *AccountingAPIService) UpdateRepeatingInvoice(ctx context.Context, repeatingInvoiceID string) ApiUpdateRepeatingInvoiceRequest {
	return ApiUpdateRepeatingInvoiceRequest{
		ApiService: a,
		ctx: ctx,
		repeatingInvoiceID: repeatingInvoiceID,
	}
}

// Execute executes the request
//  @return RepeatingInvoices
func (a *AccountingAPIService) UpdateRepeatingInvoiceExecute(r ApiUpdateRepeatingInvoiceRequest) (*RepeatingInvoices, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RepeatingInvoices
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateRepeatingInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/RepeatingInvoices/{RepeatingInvoiceID}"
	localVarPath = strings.Replace(localVarPath, "{"+"RepeatingInvoiceID"+"}", url.PathEscape(parameterValueToString(r.repeatingInvoiceID, "repeatingInvoiceID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.repeatingInvoices == nil {
		return localVarReturnValue, nil, reportError("repeatingInvoices is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.repeatingInvoices
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateRepeatingInvoiceAttachmentByFileNameRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	repeatingInvoiceID string
	fileName string
	body *string
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiUpdateRepeatingInvoiceAttachmentByFileNameRequest) XeroTenantId(xeroTenantId string) ApiUpdateRepeatingInvoiceAttachmentByFileNameRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

// Byte array of file in body of request
func (r ApiUpdateRepeatingInvoiceAttachmentByFileNameRequest) Body(body string) ApiUpdateRepeatingInvoiceAttachmentByFileNameRequest {
	r.body = &body
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateRepeatingInvoiceAttachmentByFileNameRequest) IdempotencyKey(idempotencyKey string) ApiUpdateRepeatingInvoiceAttachmentByFileNameRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiUpdateRepeatingInvoiceAttachmentByFileNameRequest) Execute() (*Attachments, *http.Response, error) {
	return r.ApiService.UpdateRepeatingInvoiceAttachmentByFileNameExecute(r)
}

/*
UpdateRepeatingInvoiceAttachmentByFileName Updates a specific attachment from a specific repeating invoices by file name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repeatingInvoiceID Unique identifier for a Repeating Invoice
 @param fileName Name of the attachment
 @return ApiUpdateRepeatingInvoiceAttachmentByFileNameRequest
*/
func (a *AccountingAPIService) UpdateRepeatingInvoiceAttachmentByFileName(ctx context.Context, repeatingInvoiceID string, fileName string) ApiUpdateRepeatingInvoiceAttachmentByFileNameRequest {
	return ApiUpdateRepeatingInvoiceAttachmentByFileNameRequest{
		ApiService: a,
		ctx: ctx,
		repeatingInvoiceID: repeatingInvoiceID,
		fileName: fileName,
	}
}

// Execute executes the request
//  @return Attachments
func (a *AccountingAPIService) UpdateRepeatingInvoiceAttachmentByFileNameExecute(r ApiUpdateRepeatingInvoiceAttachmentByFileNameRequest) (*Attachments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Attachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateRepeatingInvoiceAttachmentByFileName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{FileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"RepeatingInvoiceID"+"}", url.PathEscape(parameterValueToString(r.repeatingInvoiceID, "repeatingInvoiceID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"FileName"+"}", url.PathEscape(parameterValueToString(r.fileName, "fileName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTaxRateRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	taxRates *TaxRates
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiUpdateTaxRateRequest) XeroTenantId(xeroTenantId string) ApiUpdateTaxRateRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiUpdateTaxRateRequest) TaxRates(taxRates TaxRates) ApiUpdateTaxRateRequest {
	r.taxRates = &taxRates
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateTaxRateRequest) IdempotencyKey(idempotencyKey string) ApiUpdateTaxRateRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiUpdateTaxRateRequest) Execute() (*TaxRates, *http.Response, error) {
	return r.ApiService.UpdateTaxRateExecute(r)
}

/*
UpdateTaxRate Updates tax rates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateTaxRateRequest
*/
func (a *AccountingAPIService) UpdateTaxRate(ctx context.Context) ApiUpdateTaxRateRequest {
	return ApiUpdateTaxRateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TaxRates
func (a *AccountingAPIService) UpdateTaxRateExecute(r ApiUpdateTaxRateRequest) (*TaxRates, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaxRates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateTaxRate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/TaxRates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.taxRates == nil {
		return localVarReturnValue, nil, reportError("taxRates is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.taxRates
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTrackingCategoryRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	trackingCategoryID string
	trackingCategory *TrackingCategory
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiUpdateTrackingCategoryRequest) XeroTenantId(xeroTenantId string) ApiUpdateTrackingCategoryRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiUpdateTrackingCategoryRequest) TrackingCategory(trackingCategory TrackingCategory) ApiUpdateTrackingCategoryRequest {
	r.trackingCategory = &trackingCategory
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateTrackingCategoryRequest) IdempotencyKey(idempotencyKey string) ApiUpdateTrackingCategoryRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiUpdateTrackingCategoryRequest) Execute() (*TrackingCategories, *http.Response, error) {
	return r.ApiService.UpdateTrackingCategoryExecute(r)
}

/*
UpdateTrackingCategory Updates a specific tracking category

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trackingCategoryID Unique identifier for a TrackingCategory
 @return ApiUpdateTrackingCategoryRequest
*/
func (a *AccountingAPIService) UpdateTrackingCategory(ctx context.Context, trackingCategoryID string) ApiUpdateTrackingCategoryRequest {
	return ApiUpdateTrackingCategoryRequest{
		ApiService: a,
		ctx: ctx,
		trackingCategoryID: trackingCategoryID,
	}
}

// Execute executes the request
//  @return TrackingCategories
func (a *AccountingAPIService) UpdateTrackingCategoryExecute(r ApiUpdateTrackingCategoryRequest) (*TrackingCategories, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrackingCategories
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateTrackingCategory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/TrackingCategories/{TrackingCategoryID}"
	localVarPath = strings.Replace(localVarPath, "{"+"TrackingCategoryID"+"}", url.PathEscape(parameterValueToString(r.trackingCategoryID, "trackingCategoryID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.trackingCategory == nil {
		return localVarReturnValue, nil, reportError("trackingCategory is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.trackingCategory
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTrackingOptionsRequest struct {
	ctx context.Context
	ApiService *AccountingAPIService
	xeroTenantId *string
	trackingCategoryID string
	trackingOptionID string
	trackingOption *TrackingOption
	idempotencyKey *string
}

// Xero identifier for Tenant
func (r ApiUpdateTrackingOptionsRequest) XeroTenantId(xeroTenantId string) ApiUpdateTrackingOptionsRequest {
	r.xeroTenantId = &xeroTenantId
	return r
}

func (r ApiUpdateTrackingOptionsRequest) TrackingOption(trackingOption TrackingOption) ApiUpdateTrackingOptionsRequest {
	r.trackingOption = &trackingOption
	return r
}

// This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
func (r ApiUpdateTrackingOptionsRequest) IdempotencyKey(idempotencyKey string) ApiUpdateTrackingOptionsRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiUpdateTrackingOptionsRequest) Execute() (*TrackingOptions, *http.Response, error) {
	return r.ApiService.UpdateTrackingOptionsExecute(r)
}

/*
UpdateTrackingOptions Updates a specific option for a specific tracking category

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trackingCategoryID Unique identifier for a TrackingCategory
 @param trackingOptionID Unique identifier for a Tracking Option
 @return ApiUpdateTrackingOptionsRequest
*/
func (a *AccountingAPIService) UpdateTrackingOptions(ctx context.Context, trackingCategoryID string, trackingOptionID string) ApiUpdateTrackingOptionsRequest {
	return ApiUpdateTrackingOptionsRequest{
		ApiService: a,
		ctx: ctx,
		trackingCategoryID: trackingCategoryID,
		trackingOptionID: trackingOptionID,
	}
}

// Execute executes the request
//  @return TrackingOptions
func (a *AccountingAPIService) UpdateTrackingOptionsExecute(r ApiUpdateTrackingOptionsRequest) (*TrackingOptions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrackingOptions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingAPIService.UpdateTrackingOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/TrackingCategories/{TrackingCategoryID}/Options/{TrackingOptionID}"
	localVarPath = strings.Replace(localVarPath, "{"+"TrackingCategoryID"+"}", url.PathEscape(parameterValueToString(r.trackingCategoryID, "trackingCategoryID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"TrackingOptionID"+"}", url.PathEscape(parameterValueToString(r.trackingOptionID, "trackingOptionID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xeroTenantId == nil {
		return localVarReturnValue, nil, reportError("xeroTenantId is required and must be specified")
	}
	if r.trackingOption == nil {
		return localVarReturnValue, nil, reportError("trackingOption is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "xero-tenant-id", r.xeroTenantId, "")
	if r.idempotencyKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Idempotency-Key", r.idempotencyKey, "")
	}
	// body params
	localVarPostBody = r.trackingOption
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
